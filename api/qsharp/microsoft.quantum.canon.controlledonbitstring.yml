### YamlMime:QSharpType
uid: microsoft.quantum.canon.controlledonbitstring
name: ControlledOnBitString
type: function
namespace: microsoft.quantum.canon
summary: >-
  Returnerar en enhetlig åtgärd som tillämpar en Oracle på mål registret om kontroll registerets tillstånd motsvarar en angiven bitmask.


  Resultatet av den här funktionen är en åtgärd som kan representeras av en enhetlig omvandling $U $ t. ex. \begin{align} U \ket{b_0 b_1 \cdots b_ {n-1}} \ket{\psi} = \ket{b_0 b_1 \cdots b_ {n-1}} \otimes \begin{Cases} V \ket{\psi} & \textrm{IF} (b_0 b_1 \cdots b_ {n-1}) = \texttt{BITS} \\ \\ \ket{\psi} & \textrm{otherwise} \end{Cases}, \end{align} där $V $ är en enhetlig omvandling som representerar åtgärdens åtgärd `oracle` .
remarks: >-
  Mönstret som anges av `bits` kan vara kortare än `controlRegister` , och i så fall ignoreras ytterligare kontroll qubits (det vill säga varken kontrol leras på $ \ket {0} $ eller $ \ket {1} $).

  Om `bits` är längre än `controlRegister` uppstår ett fel.


  `bits` `oracle` Resultatet av den här funktionen är en åtgärd som utför följande steg för att få en boolesk matris och en enhetlig åtgärd:


  * tillämpa en `X` åtgärd på varje qubit i kontroll registret som motsvarar `false` element i `bits` .

  * gäller `Controlled oracle` för kontroll-och mål registren.

  * tillämpa en `X` åtgärd på varje qubit i kontroll registret som motsvarar `false` elementet i `bits` igen för att returnera kontroll registret till det ursprungliga läget.


  Utdata från `Controlled` Functor är ett specialfall av `ControlledOnBitString` var `bits` är lika med `[true, ..., true]` .
examples: >-
  Följande kodfragment är likvärdiga:


  ```qsharp

  (ControlledOnBitString(bits, oracle))(controlRegister, targetRegister);

  ```


  och


  ```qsharp

  within {
      ApplyPauliFromBitString(PauliX, false, bits, controlRegister);
  } apply {
      Controlled oracle(controlRegister, targetRegister);
  }

  ```


  Följande kod förbereder ett tillstånd $ \frac {1} {2} (\ket {00} -\ket {01} + \ket {10} + \ket {11} ) $:


  ```qsharp

  using (register = Qubit[2]) {
      ApplyToEach(H, register);
      (ControlledOnBitString([false], Z))(register[0..0], register[1]);
  }

  ```
syntax: "function ControlledOnBitString (bits : Bool[], oracle : ('T => Unit is Adj + Ctl)) : ((Qubit[], 'T) => Unit is Adj + Ctl)"
input:
  content: "(bits : Bool[], oracle : ('T => Unit is Adj + Ctl))"
  types:
  - name: bits
    summary: Bit strängen som styr den åtgärd som åtgärdas.
    isArray: true
    isPrimitive: true
    uid: Bool
  - name: oracle
    summary: Den enhetliga åtgärd som ska tillämpas på mål registret.
    isOperation: true
    input:
      types:
      - uid: "'T"
        isLocal: true
    output:
      types:
      - isPrimitive: true
        uid: Unit
    functors:
    - Adjoint
    - Controlled
output:
  content: ((Qubit[], 'T) => Unit is Adj + Ctl)
  types:
  - summary: En enhetlig åtgärd som gäller `oracle` för mål registret om status för kontroll registret motsvarar bitmask `bits` .
    isOperation: true
    input:
      types:
      - isArray: true
        isPrimitive: true
        uid: Qubit
      - uid: "'T"
        isLocal: true
    output:
      types:
      - isPrimitive: true
        uid: Unit
    functors:
    - Adjoint
    - Controlled
metadata:
  ms.openlocfilehash: a77aae7bcb7f7596398b4b9873ec33beb80a8098
  ms.sourcegitcommit: 685a8ab16d7e6a25e63a168d6e7c385fa6e876cc
  ms.translationtype: MT
  ms.contentlocale: sv-SE
  ms.lasthandoff: 09/29/2020
  ms.locfileid: "91471957"
