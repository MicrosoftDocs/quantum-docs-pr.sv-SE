---
uid: Microsoft.Quantum.AmplitudeAmplification
title: Namn område för Microsoft. Quantum. AmplitudeAmplification
ms.date: 11/25/2020 12:00:00 AM
ms.topic: article
qsharp.kind: namespace
qsharp.name: Microsoft.Quantum.AmplitudeAmplification
qsharp.summary: This namespace contains functions and operations for performing amplitude amplification.
ms.openlocfilehash: f265f1f8b41513f9201a758f85451e768b7564e2
ms.sourcegitcommit: a87c1aa8e7453360025e47ba614f25b02ea84ec3
ms.translationtype: MT
ms.contentlocale: sv-SE
ms.lasthandoff: 11/26/2020
ms.locfileid: "96191422"
---
# <a name="microsoftquantumamplitudeamplification-namespace"></a><span data-ttu-id="69108-102">Namn område för Microsoft. Quantum. AmplitudeAmplification</span><span class="sxs-lookup"><span data-stu-id="69108-102">Microsoft.Quantum.AmplitudeAmplification namespace</span></span>

<span data-ttu-id="69108-103">Det här namn området innehåller funktioner och åtgärder för att utföra amplitud-förstärkning.</span><span class="sxs-lookup"><span data-stu-id="69108-103">This namespace contains functions and operations for performing amplitude amplification.</span></span>



## <a name="description"></a><span data-ttu-id="69108-104">Beskrivning</span><span class="sxs-lookup"><span data-stu-id="69108-104">Description</span></span>

<span data-ttu-id="69108-105">Oblivious amplitud-förstärkning med partiella reflektioner är den mest generella formen av amplitud-förstärkning som implementeras här.</span><span class="sxs-lookup"><span data-stu-id="69108-105">Oblivious amplitude amplification with partial reflections is the most general form of amplitude amplification implemented here.</span></span>

<span data-ttu-id="69108-106">Detta anropas via åtgärden AmpAmpObliviousByReflectionPhases.</span><span class="sxs-lookup"><span data-stu-id="69108-106">This is called through the operation AmpAmpObliviousByReflectionPhases.</span></span>

<span data-ttu-id="69108-107">Detta har två register: `ancillaRegister` och `systemRegister` .</span><span class="sxs-lookup"><span data-stu-id="69108-107">This has two registers: `ancillaRegister` and `systemRegister`.</span></span>

<span data-ttu-id="69108-108">Detta godkänner två Oracle för dessa reflektioner av typen `ReflectionOracle` som bara agerar i `ancillaRegister` registret.</span><span class="sxs-lookup"><span data-stu-id="69108-108">This accepts two oracles for these reflections of type `ReflectionOracle` which act only on the `ancillaRegister` register.</span></span>

<span data-ttu-id="69108-109">Detta godkänner en Oracle-specifik till Oblivious amplitud-förstärkning av typ `ObliviousOracle` som fungerar tillsammans i båda registren.</span><span class="sxs-lookup"><span data-stu-id="69108-109">This accepts an oracle special to oblivious amplitude amplification of type `ObliviousOracle` which acts jointly on both register.</span></span>

<span data-ttu-id="69108-110">Indatamängden `ancillaRegister` antas vara den unika $-$1-eigenstate för den första reflektions operatorn $I-2 \ ket {s} \ bra {s} $.</span><span class="sxs-lookup"><span data-stu-id="69108-110">The input state to `ancillaRegister` is assumed to be the unique $-1$ eigenstate of the first reflection operator $I - 2\ket{s}\bra{s}$.</span></span>

<span data-ttu-id="69108-111">Reflektioner om ett mål Quantum-tillstånd implementeras ofta genom att man antar åtkomst till en Oracle som förbereder detta tillstånd från beräknings basen $ \ket{0\cdots 0} $.</span><span class="sxs-lookup"><span data-stu-id="69108-111">Reflections about a target quantum state are often implemented by assuming access to an oracle that prepare that state from the computational basis $\ket{0\cdots 0}$.</span></span>

<span data-ttu-id="69108-112">Vår konvention för dessa Oracle kräver två register: en enda-qubit- `flagQubit` registrering och ett register för allt annat i ancillaRegister-registret.</span><span class="sxs-lookup"><span data-stu-id="69108-112">Our convention for these oracles requires two registers: a single-qubit `flagQubit` register, and a register for everything else on the ancillaRegister register.</span></span>

<span data-ttu-id="69108-113">Oracle-typen `StateOracle` agerar gemensamt på båda registren för att skapa mål tillstånd som flaggats av $ \ket {1} $ i `flagQubit` registret med en riktig amplitud.</span><span class="sxs-lookup"><span data-stu-id="69108-113">The oracle of type `StateOracle` acts jointly on both registers to create the target state flagged by $\ket{1}$ in the `flagQubit` register with some real amplitude.</span></span>

<span data-ttu-id="69108-114">Reflektionen `ReflectionOracle` om det här flagg läget genereras av åtgärden `TargetStateReflectionOracle` .</span><span class="sxs-lookup"><span data-stu-id="69108-114">The reflection `ReflectionOracle` about the this flag state is generated by the operation `TargetStateReflectionOracle`.</span></span>

<span data-ttu-id="69108-115">Reflektionen `ReflectionOracle` om ingångs läget som `ancillaRegister` genereras av StateOracle inverteras och sedan återspeglar ungefär $ \ket{0\cdots 0} $ med ReflectionStart ().</span><span class="sxs-lookup"><span data-stu-id="69108-115">The reflection `ReflectionOracle` about the input state to `ancillaRegister` is generated by the inverting StateOracle and then reflecting about $\ket{0\cdots 0}$ with ReflectionStart().</span></span>

<span data-ttu-id="69108-116">Oracle-typen `DeterministicStateOracle` agerar i `qubitState` registren för att skapa mål tillstånd exakt utan flagga.</span><span class="sxs-lookup"><span data-stu-id="69108-116">The oracle of type `DeterministicStateOracle` acts on the `qubitState` registers to create the target state exactly with no flag.</span></span>

<span data-ttu-id="69108-117">`AmpAmpObliviousByOraclePhases` är en version av Oblivious amplitud-förstärkning som accepterar Oracle `StateOracle` och `ObliviousOracle` i stället för reflexer.</span><span class="sxs-lookup"><span data-stu-id="69108-117">`AmpAmpObliviousByOraclePhases` is a version of oblivious amplitude amplification that accepts oracles `StateOracle` and `ObliviousOracle` instead of reflections.</span></span>

<span data-ttu-id="69108-118">Observera att amplitud förstärkning är ett specialfall av Oblivious amplitud-förstärkning där `ObliviousOracle` är identitets operatorn, och det finns inga system-qubits, d.v.s. `systemRegister` tomt.</span><span class="sxs-lookup"><span data-stu-id="69108-118">Note that amplitude amplification is a special case of oblivious amplitude amplification where `ObliviousOracle` is the identity operator, and there are no system qubits i.e. `systemRegister` is empty.</span></span>

<span data-ttu-id="69108-119">Detta anropas genom åtgärden `AmpAmByReflectionPhases` och `AmpAmpByOraclePhases` .</span><span class="sxs-lookup"><span data-stu-id="69108-119">This is called through the operation `AmpAmByReflectionPhases` and `AmpAmpByOraclePhases`.</span></span>

<span data-ttu-id="69108-120">Faserna för partiella reflektioner i standard fallet för Grover-sökning tillhandahålls av funktionen AmpAmpPhasesStandard.</span><span class="sxs-lookup"><span data-stu-id="69108-120">The phases for partial reflections in the standard case of Grover search is provided by the function AmpAmpPhasesStandard.</span></span>

<span data-ttu-id="69108-121">Vi har till exempel följande beroenden: AmpAmpByOracle-> AmpAmpByOraclePhases-> AmpAmpObliviousByOraclePhases-> AmpAmpObliviousByReflectionPhases.</span><span class="sxs-lookup"><span data-stu-id="69108-121">For instance, we have the following dependencies: AmpAmpByOracle -> AmpAmpByOraclePhases -> AmpAmpObliviousByOraclePhases -> AmpAmpObliviousByReflectionPhases.</span></span>