---
title: 'Q # standard bibliotek – program | Microsoft Docs'
description: Q#-standardbibliotek
author: QuantumWriter
uid: microsoft.quantum.libraries.applications
ms.author: martinro@microsoft.com
ms.date: 12/11/2017
ms.topic: article
ms.openlocfilehash: 3e629e095bd2ee492496066710ef6fd4e578a543
ms.sourcegitcommit: ca5015fed409eaf0395a89c2e4bc6a890c360aa2
ms.translationtype: MT
ms.contentlocale: sv-SE
ms.lasthandoff: 01/29/2020
ms.locfileid: "76868976"
---
# <a name="applications"></a><span data-ttu-id="c399b-103">Appar</span><span class="sxs-lookup"><span data-stu-id="c399b-103">Applications</span></span> #

## <a name="hamiltonian-simulation"></a><span data-ttu-id="c399b-104">Hamiltonsk simulering</span><span class="sxs-lookup"><span data-stu-id="c399b-104">Hamiltonian Simulation</span></span> ##

<span data-ttu-id="c399b-105">Simuleringen av Quantum Systems är ett av de mest spännande programmen i Quantum-beräkningen.</span><span class="sxs-lookup"><span data-stu-id="c399b-105">The simulation of quantum systems is one of the most exciting applications of quantum computation.</span></span>
<span data-ttu-id="c399b-106">På en klassisk dator skalas svårigheten att simulera Quantum Mechanics i allmänhet med dimensions $N $ för sin tillstånds vektor representation.</span><span class="sxs-lookup"><span data-stu-id="c399b-106">On a classical computer, the difficulty of simulating quantum mechanics, in general, scales with the dimension $N$ of its state-vector representation.</span></span>
<span data-ttu-id="c399b-107">I takt med att den här representationen ökar exponentiellt med antalet $n $ qubits $N = 2 ^ n $, en benämning som är känd även känd som [Curse](xref:microsoft.quantum.concepts.multiple-qubits), är Quantum-simuleringen i klassisk maskin vara indragbar.</span><span class="sxs-lookup"><span data-stu-id="c399b-107">As this representation grows exponentially with the number of $n$ qubits $N=2^n$, a trait known also known as the [curse of dimensionality](xref:microsoft.quantum.concepts.multiple-qubits), quantum simulation on classical hardware is intractable.</span></span>

<span data-ttu-id="c399b-108">Situationen kan dock vara mycket annorlunda på Quantum-maskinvara.</span><span class="sxs-lookup"><span data-stu-id="c399b-108">However, the situation can be very different on quantum hardware.</span></span> <span data-ttu-id="c399b-109">Den vanligaste variationen av Quantum-simulering kallas för tids oberoende Hamiltonian simulerings problem.</span><span class="sxs-lookup"><span data-stu-id="c399b-109">The most common variation of quantum simulation is called the time-independent Hamiltonian simulation problem.</span></span> <span data-ttu-id="c399b-110">Det finns en beskrivning av systemets Hamiltonian $H $, som är en Hermitian-matris och vissa inledande Quantum-tillstånd $ \ket{\psi (0)} $ som är kodade i vissa fall på $n $ qubits på en Quantum-dator.</span><span class="sxs-lookup"><span data-stu-id="c399b-110">There, one is provided with a description of the system Hamiltonian $H$, which is a Hermitian matrix, and some initial quantum state $\ket{\psi(0)}$ that is encoded in some basis on $n$ qubits on a quantum computer.</span></span> <span data-ttu-id="c399b-111">I takt med att de stängda systemen utvecklas under Schrödinger ekvation $ $ \begin{align} i\frac {d \ket{\psi (t)}} {d t} & = H \ket{\psi (t)}, \end{align} $ $ målet är att implementera den enhetliga tids utvecklings operatören $U (t) = e ^ {-iHt} $ vid vissa bestämda tidpunkter $t $ , där $ \ket{\psi (t)} = U (t) \ket{\psi (0)} $ matchar Schrödinger-ekvationen.</span><span class="sxs-lookup"><span data-stu-id="c399b-111">As quantum states in closed systems evolve under the Schrödinger equation $$ \begin{align} i\frac{d \ket{\psi(t)}}{d t} & = H \ket{\psi(t)}, \end{align} $$ the goal is to implement the unitary time-evolution operator $U(t)=e^{-iHt}$ at some fixed time $t$, where $\ket{\psi(t)}=U(t)\ket{\psi(0)}$ solves the Schrödinger equation.</span></span>
<span data-ttu-id="c399b-112">Analogously, den tids beroende Hamiltonian simulerings problemet matchar samma formel, men med $H (t) $ nu en funktion av tiden.</span><span class="sxs-lookup"><span data-stu-id="c399b-112">Analogously, the time-dependent Hamiltonian simulation problem solves the same equation, but with $H(t)$ now a function of time.</span></span>

<span data-ttu-id="c399b-113">Hamiltonian-simulering är en viktig komponent i många andra problem med Quantum-simulering och lösningar på Hamiltonian simulerings problem är algoritmer som beskriver en sekvens med primitiva Quantum-grindar för att syntetisera en ungefärlig \tilde{U} $ med fel $\\| \tilde{U}-U (t)\\| \le \epsilon $ i [Spectral-normen](xref:microsoft.quantum.concepts.matrix-advanced).</span><span class="sxs-lookup"><span data-stu-id="c399b-113">Hamiltonian simulation is a major component of many other quantum simulation problems, and solutions to Hamiltonian simulation problem are algorithms that describes a sequence of primitive quantum gates for synthesizing an approximating unitary $\tilde{U}$ with error $\\|\tilde{U} - U(t)\\| \le \epsilon$ in the [spectral norm](xref:microsoft.quantum.concepts.matrix-advanced).</span></span> <span data-ttu-id="c399b-114">De här algoritmernas komplexitet är mycket starkt beroende av hur en beskrivning av Hamiltonian av intresse görs tillgänglig för en Quantum-dator.</span><span class="sxs-lookup"><span data-stu-id="c399b-114">The complexity of these algorithms depend very strongly on how a description of the Hamiltonian of interest is made accessible by a quantum computer.</span></span> <span data-ttu-id="c399b-115">I värsta fall, om $H $ som agerar på $n $ qubits skulle tillhandahållas som en lista över $2 ^ n \times 2 ^ n $ Numbers, ett för varje mat ris element skulle det redan kräva exponentiell tid att läsa data.</span><span class="sxs-lookup"><span data-stu-id="c399b-115">For instance, in the worst-case, if $H$ acting on $n$ qubits were to be provided as a list of $2^n \times 2^n$ numbers, one for each matrix element, simply reading the data would already require exponential time.</span></span> <span data-ttu-id="c399b-116">I det bästa fallet kan det vara bra att ha till gång till en svart box som $O \ket{t}\ket{\psi (0)} = \ket{t}U (t) \ket{\psi (0)} $ löser problemet enkelt.</span><span class="sxs-lookup"><span data-stu-id="c399b-116">In the best case, one could assume access to a black-box unitary that $O\ket{t}\ket{\psi(0)}=\ket{t}U(t)\ket{\psi(0)}$ trivially solves the problem.</span></span> <span data-ttu-id="c399b-117">Ingen av dessa ingångs modeller är särskilt intressanta – den tidigare versionen är inte bättre än klassiska metoder och den senare som den svarta rutan döljer den primitiva gaten för dess implementering, vilket kan vara exponentiellt i antalet qubits.</span><span class="sxs-lookup"><span data-stu-id="c399b-117">Neither of these input models are particularly interesting -- the former as it is no better than classical approaches, and the latter as the black-box hides the primitive gate complexity of its implementation, which could be exponential in the number of qubits.</span></span>

### <a name="descriptions-of-hamiltonians"></a><span data-ttu-id="c399b-118">Beskrivningar av Hamiltonians</span><span class="sxs-lookup"><span data-stu-id="c399b-118">Descriptions of Hamiltonians</span></span> ###

<span data-ttu-id="c399b-119">Det krävs ytterligare antaganden om formatet på indatamängden.</span><span class="sxs-lookup"><span data-stu-id="c399b-119">Additional assumptions of the format of the input are therefore required.</span></span> <span data-ttu-id="c399b-120">En fin balans måste ligga mellan ingångs modeller som är tillräckligt beskrivande för att omfatta intressanta Hamiltonians, t. ex. för realistiska fysiska system eller intressanta beräknings problem och ingående modeller som är tillräckligt begränsade för att effektivt kunna implementeras på en Quantum-dator.</span><span class="sxs-lookup"><span data-stu-id="c399b-120">A fine balance must be struck between input models that are sufficiently descriptive to encompass interesting Hamiltonians, such as those for realistic physical systems or interesting computational problems, and input models that are sufficiently restrictive to be efficiently implementable on a quantum computer.</span></span> <span data-ttu-id="c399b-121">En mängd olika icke-triviala ingångs modeller finns i dokumentationen, och de sträcker sig från Quantum till klassisk.</span><span class="sxs-lookup"><span data-stu-id="c399b-121">A variety of non-trivial input model may be found in the literature, and they range from quantum to classical.</span></span> 

<span data-ttu-id="c399b-122">Som exempel på Quantum-ingångs modeller antar den [exempelbaserade Hamiltonian-simuleringen](http://www.nature.com/articles/s41534-017-0013-7) svart-Box till Quantum-åtgärder som producerar kopior av en densitets mat ris $ \rho $, som är Hamiltonian $H $.</span><span class="sxs-lookup"><span data-stu-id="c399b-122">As examples of quantum input models, [sample-based Hamiltonian simulation](http://www.nature.com/articles/s41534-017-0013-7) assumes black-box access to quantum operations that produce copies of a density matrix $\rho$, which are taken to be the Hamiltonian $H$.</span></span> <span data-ttu-id="c399b-123">I den [enhetliga åtkomst modellen](https://arxiv.org/abs/1202.5822) förutsätter att Hamiltonian i stället dedelas i summan av unitaries $ $ \begin{align} H & = \sum ^ {d-1}\_{j = 0} a\_j \hat{U}\_j, \end{align} $ $ där $a\_j > 0 $ är koefficienter, och $ \hat{U}\_j $ är unitaries.</span><span class="sxs-lookup"><span data-stu-id="c399b-123">In the [unitary access model](https://arxiv.org/abs/1202.5822) one supposes that the Hamiltonian instead decomposes into a sum of unitaries $$ \begin{align} H & = \sum^{d-1}\_{j=0} a\_j \hat{U}\_j, \end{align} $$ where $a\_j>0$ are coefficients, and $\hat{U}\_j$ are unitaries.</span></span> <span data-ttu-id="c399b-124">Det förutsätts att en har svart-Box till gång till den enhetliga Oracle-$V = \sum ^ {d-1}\_{j = 0} \ket{j}\bra{j}\otimes \hat{U}\_j $ som väljer önskad $ \hat{U}\_j $, och Oracle-$A \ket{0}= \sum ^ {d-1}\_{j = 0} \sqrt{a\_j/\ sum ^ {d-1}\_{k = 0} \alpha\_j} \ket{j} $ som skapar en kodning av Quantum-tillstånd.</span><span class="sxs-lookup"><span data-stu-id="c399b-124">It is then assumed that one has black-box access to the unitary oracle $V=\sum^{d-1}\_{j=0}\ket{j}\bra{j}\otimes \hat{U}\_j$ that selects the desired $\hat{U}\_j$, and the oracle $A\ket{0}=\sum^{d-1}\_{j=0}\sqrt{a\_j/\sum^{d-1}\_{k=0}\alpha\_j}\ket{j}$ that create a quantum state encoding these coefficients.</span></span> <span data-ttu-id="c399b-125">I händelse av en [optimerad Hamiltonian-simulering](https://arxiv.org/abs/quant-ph/0301023)förutsätter det att Hamiltonian är en sparse-matris med endast $d = \mathcal{O} (\Text{polylog} (N)) $ element som inte är noll i varje rad.</span><span class="sxs-lookup"><span data-stu-id="c399b-125">In the case of [sparse Hamiltonian simulation](https://arxiv.org/abs/quant-ph/0301023), one assumes that the Hamiltonian is a sparse matrix with only $d=\mathcal{O}(\text{polylog}(N))$ non-zero element in every row.</span></span> <span data-ttu-id="c399b-126">Dessutom förutsätter en förekomst av effektiva Quantum-kretsar som utvärderar platsen för dessa icke-noll-element, samt deras värden.</span><span class="sxs-lookup"><span data-stu-id="c399b-126">Moreover, one assumes the existence of efficient quantum circuits that output the location of these non-zero elements, as well as the their values.</span></span> <span data-ttu-id="c399b-127">Komplexiteten för [algoritmerna för Hamiltonian simulering](xref:microsoft.quantum.more-information) utvärderas som antalet frågor till dessa svarta rutor, och den primitiva grinden av porten är sedan mycket stor på svårigheten att implementera dessa svarta rutor.</span><span class="sxs-lookup"><span data-stu-id="c399b-127">The complexity of [Hamiltonian simulation algorithms](xref:microsoft.quantum.more-information) is evaluated in terms of number of queries to these black-boxes, and the primitive gate complexity then depends very much on the difficulty of implementing these black-boxes.</span></span>

> [!NOTE]
> <span data-ttu-id="c399b-128">Big-O-notationen används ofta för att beskriva komplexitets skalningen för algoritmer.</span><span class="sxs-lookup"><span data-stu-id="c399b-128">The big-O notation is commonly used to describe the complexity scaling of algorithms.</span></span> <span data-ttu-id="c399b-129">Med två verkliga Functions $f, g $, uttrycket $g (x) = \mathcal{O} (f (x)) $ betyder det att det finns en absolut positiv konstant $x\_0, c > 0 $ så $g (x) \le c f (x) $ för alla $x \ge x\_$0.</span><span class="sxs-lookup"><span data-stu-id="c399b-129">Given two real functions $f,g$, the expression $g(x)=\mathcal{O}(f(x))$ means that there exists an absolute positive constant $x\_0, c>0$ such that $g(x) \le c f(x)$ for all $x\ge x\_0$.</span></span> 

<span data-ttu-id="c399b-130">I de flesta praktiska program som ska implementeras på en Quantum-dator måste dessa svarta rutor vara effektiva att implementera, det vill säga med $ \mathcal{O} (\text{polylog} (N)) $ primitiva Quantum-grindar.</span><span class="sxs-lookup"><span data-stu-id="c399b-130">In most practical applications to be implemented on a quantum computer, these black-boxes must be efficiently implementable, that is with $\mathcal{O}(\text{polylog}(N))$ primitive quantum gates.</span></span> <span data-ttu-id="c399b-131">Mer starkt simulable Hamiltonians måste ha en viss tillräckligt optimerad klassisk beskrivning.</span><span class="sxs-lookup"><span data-stu-id="c399b-131">More strongly, efficiently simulable Hamiltonians must have some sufficiently sparse classical description.</span></span> <span data-ttu-id="c399b-132">I en sådan formulering förutsätts det att Hamiltonian i en summa av Hermitian-delarna $ $ \begin{align} H & = \sum ^ {d-1} _ {j = 0} H_j.</span><span class="sxs-lookup"><span data-stu-id="c399b-132">In one such formulation, it is assumed that the Hamiltonian decomposes into a sum of Hermitian parts $$ \begin{align} H & = \sum^{d-1}_{j=0} H_j.</span></span>
<span data-ttu-id="c399b-133">\end{align} $ $, det förutsätts dessutom att varje del, en Hamiltonian $H\_j $, är lätt att simulera.</span><span class="sxs-lookup"><span data-stu-id="c399b-133">\end{align} $$ Moreover, it is assumed that each part, a Hamiltonian $H\_j$, is easy to simulate.</span></span> <span data-ttu-id="c399b-134">Det innebär att den enhetliga $e ^ {-iH\_j t} $ när som helst $t $ kan implementeras exakt med $ \mathcal{O} (1) $ primitiva Quantum-grindar.</span><span class="sxs-lookup"><span data-stu-id="c399b-134">This means that the unitary $e^{-iH\_j t}$ for any time $t$ may be implemented exactly using $\mathcal{O}(1)$ primitive quantum gates.</span></span> <span data-ttu-id="c399b-135">Detta är till exempel sant i det särskilda fallet där varje $H\_j $ är lokala Pauli-operatörer, vilket innebär att de är av \mathcal{O} produkter av $ (1) $ Pauli-operatörer som agerar på rums qubits.</span><span class="sxs-lookup"><span data-stu-id="c399b-135">For instance, this is true in the special case where each $H\_j$ are local Pauli operators, meaning that they are of tensor products of $\mathcal{O}(1)$ non-identity Pauli operators that act on spatially close qubits.</span></span> <span data-ttu-id="c399b-136">Den här modellen är särskilt tillämplig på fysiska system med gräns och lokal interaktion, eftersom antalet villkor är $d = \mathcal{O} (\text{polylog} (N)) $, och det kan tydligt skrivas ned, vilket beskrivs i polynom tid.</span><span class="sxs-lookup"><span data-stu-id="c399b-136">This model is particularly applicable to physical systems with bounded and local interaction, as the number of terms is $d=\mathcal{O}(\text{polylog}(N))$, and may clearly be written down, i.e. classically described, in polynomial time.</span></span>

> [!TIP]
> <span data-ttu-id="c399b-137">Hamiltonians som ingår i en summa av delar kan beskrivas med hjälp av det dynamiska Generator representations biblioteket.</span><span class="sxs-lookup"><span data-stu-id="c399b-137">Hamiltonians that decompose into a sum of parts may be described using the Dynamical Generator Representation library.</span></span> <span data-ttu-id="c399b-138">Mer information finns i avsnittet representation av dynamiskt Generator i [data strukturer](xref:microsoft.quantum.libraries.data-structures).</span><span class="sxs-lookup"><span data-stu-id="c399b-138">For more information, see the Dynamical Generator Representation section in [data structures](xref:microsoft.quantum.libraries.data-structures).</span></span>

### <a name="simulation-algorithms"></a><span data-ttu-id="c399b-139">Simulerings algoritmer</span><span class="sxs-lookup"><span data-stu-id="c399b-139">Simulation Algorithms</span></span> ###

<span data-ttu-id="c399b-140">En algoritm för Quantum simulering konverterar en specifik Beskrivning av en Hamiltonian till en sekvens med primitiva Quantum-grindar som, som helhet, närmar sig tids utvecklingen av Hamiltonian.</span><span class="sxs-lookup"><span data-stu-id="c399b-140">A quantum simulation algorithm converts a given description of a Hamiltonian into a sequence of primitive quantum gates that, as a whole, approximate time-evolution by said Hamiltonian.</span></span>

<span data-ttu-id="c399b-141">I det särskilda fallet där Hamiltonian delas upp i en summa av Hermitian delar, är Trotter-Suzuki-dekompositionen en särskilt enkel och intuitiv algoritm för att simulera Hamiltonians som sammanställer till en summa av Hermitian-komponenter.</span><span class="sxs-lookup"><span data-stu-id="c399b-141">In the special case where the Hamiltonian decomposes into a sum of Hermitian parts, the Trotter-Suzuki decomposition is a particularly simple and intuitive algorithm for simulating Hamiltonians that decompose into a sum of Hermitian components.</span></span> <span data-ttu-id="c399b-142">Till exempel är en första ordning integrerare i den här familjen ungefär $ $ \begin{align} U (t) & = \left (e ^ {-iH\_0 t/r} e ^ {-iH\_1 t/r} \cdots e ^ {-iH\_{d-1} t/r} \right) ^ {r} + \mathcal{O} (d ^ 2 \ max_j\\| H\_j\\| ^ 2 t ^ 2/r), \end{align} $ $ med en produkt av $r d $-villkor.</span><span class="sxs-lookup"><span data-stu-id="c399b-142">For instance, a first-order integrator of this family approximates $$ \begin{align} U(t) & = \left( e^{-iH\_0 t / r} e^{-iH\_1 t / r} \cdots e^{-iH\_{d-1} t / r} \right)^{r} + \mathcal{O}(d^2 \max_j\\|H\_j\\|^2 t^2/r), \end{align} $$ using a product of $r d$ terms.</span></span> 

> [!TIP]
> <span data-ttu-id="c399b-143">Program av algoritmen Trotter-Suzuki simulering beskrivs i exemplen.</span><span class="sxs-lookup"><span data-stu-id="c399b-143">Applications of the Trotter-Suzuki simulation algorithm are covered in the samples.</span></span>
> <span data-ttu-id="c399b-144">För Ising-modellen som bara använder de inbyggda åtgärder som tillhandahålls av varje måldator, se [ **SimpleIsing** -exemplet](https://github.com/microsoft/Quantum/blob/master/samples/simulation/ising/simple).</span><span class="sxs-lookup"><span data-stu-id="c399b-144">For the Ising model using only the intrinsic operations provided by each target machine, please see the [**SimpleIsing** sample](https://github.com/microsoft/Quantum/blob/master/samples/simulation/ising/simple).</span></span>
> <span data-ttu-id="c399b-145">Ising-modellen med hjälp av Trotter-Suzuki biblioteks kontroll struktur finns i [ **IsingTrotter** -exemplet](https://github.com/microsoft/Quantum/tree/master/samples/simulation/ising/trotter-evolution).</span><span class="sxs-lookup"><span data-stu-id="c399b-145">For the Ising model using the Trotter-Suzuki library control structure, please see the [**IsingTrotter** sample](https://github.com/microsoft/Quantum/tree/master/samples/simulation/ising/trotter-evolution).</span></span>
> <span data-ttu-id="c399b-146">För molekyliga väte med Trotter-Suzuki biblioteks kontroll struktur kan du se [exempel på **H2-simulering** ](https://github.com/microsoft/Quantum/tree/master/samples/simulation/h2/command-line).</span><span class="sxs-lookup"><span data-stu-id="c399b-146">For molecular Hydrogen using the Trotter-Suzuki library control structure, please see the [**H2 simulation** sample](https://github.com/microsoft/Quantum/tree/master/samples/simulation/h2/command-line).</span></span>

<span data-ttu-id="c399b-147">I många fall vill vi implementera simulerings algoritmen, men den är inte intresse rad av implementeringens information.</span><span class="sxs-lookup"><span data-stu-id="c399b-147">In many cases, we would like to implement the simulation algorithm, but are not interested in the details of its implementation.</span></span> <span data-ttu-id="c399b-148">Till exempel, den andra ordnings integreraren uppskattar $ $ \begin{align} U (t) & = \left (e ^ {-iH\_0 t/2R} e ^ {-iH\_1 t/2R} \cdots e ^ {-iH\_{d-1} t/2R} e ^ {-iH\_{d-1} t/2R} \cdots e ^ {-iH\_1 t/2R} e ^ {-iH\_0 t/2R} \right) ^ {r} + \mathcal{O} (d ^ 3 \ max_j\\| H\_j\\| ^ 3 t ^ 3/r ^ 2), \end{align} $ $ med en produkt av $2rd $-villkor.</span><span class="sxs-lookup"><span data-stu-id="c399b-148">For instance, the second-order integrator approximates $$ \begin{align} U(t) & = \left( e^{-iH\_0 t / 2r} e^{-iH\_1 t / 2r} \cdots e^{-iH\_{d-1} t / 2r} e^{-iH\_{d-1} t / 2r}  \cdots e^{-iH\_1 t / 2r} e^{-iH\_0 t / 2r} \right)^{r} + \mathcal{O}(d^3 \max_j\\|H\_j\\|^3 t^3/r^2), \end{align} $$ using a product of $2rd$ terms.</span></span> <span data-ttu-id="c399b-149">Större beställningar innebär ännu fler villkor och optimerade varianter kan kräva hög icke-trivial ordningsföljd på exponenterna.</span><span class="sxs-lookup"><span data-stu-id="c399b-149">Larger orders will involve even more terms and optimized variants may require highly non-trivial orderings on the exponentials.</span></span> <span data-ttu-id="c399b-150">Andra avancerade algoritmer kan också innebära användning av Ancilla-qubits i mellanliggande steg.</span><span class="sxs-lookup"><span data-stu-id="c399b-150">Other advanced algorithms may also involve the use of ancilla qubits in intermediate steps.</span></span> <span data-ttu-id="c399b-151">Därför har vi paket simulerings algoritmer i filen Canon som användardefinierad typ</span><span class="sxs-lookup"><span data-stu-id="c399b-151">Thus we package simulation algorithms in the canon as the user-defined type</span></span>

```qsharp
newtype SimulationAlgorithm = ((Double, EvolutionGenerator, Qubit[]) => Unit is Adj + Ctl);
```

<span data-ttu-id="c399b-152">Den första parametern `Double` är tidpunkten för simulering, den andra parametern `EvolutionGenerator`, som omfattas av representations avsnittet för dynamisk Generator i [data strukturer](xref:microsoft.quantum.libraries.data-structures), är en klassisk Beskrivning av en tidsoberoende Hamiltonian paketerad med anvisningar om hur varje term i Hamiltonian kan simuleras av en Quantum-krets.</span><span class="sxs-lookup"><span data-stu-id="c399b-152">The first parameter `Double` is the time of simulation, the second parameter `EvolutionGenerator`, covered in the Dynamical Generator Representation section of [data-structures](xref:microsoft.quantum.libraries.data-structures), is a classical description of a time-independent Hamiltonian packaged with instructions on how each term in the Hamiltonian may be simulated by a quantum circuit.</span></span> <span data-ttu-id="c399b-153">Typerna av detta formulär uppskattar den enhetliga åtgärden $e ^ {-iHt} $ på den tredje parametern `Qubit[]`, vilket är det register som lagrar det simulerade systemets Quantum-tillstånd.</span><span class="sxs-lookup"><span data-stu-id="c399b-153">Types of this form approximate the unitary operation $e^{-iHt}$ on the third parameter `Qubit[]`, which is the register storing the quantum state of the simulated system.</span></span> <span data-ttu-id="c399b-154">På samma sätt för tids beroende fallet definierar vi en användardefinierad typ med en `EvolutionSchedule` typ i stället, som är en klassisk Beskrivning av en tids beroende Hamiltonian.</span><span class="sxs-lookup"><span data-stu-id="c399b-154">Similarly for the time-dependent case, we define a user-defined type with an `EvolutionSchedule` type instead, which is a classical description of a time-dependent Hamiltonian.</span></span>

```qsharp
newtype TimeDependentSimulationAlgorithm = ((Double, EvolutionSchedule, Qubit[]) => Unit : Adjoint, Controlled);
```

<span data-ttu-id="c399b-155">Som exempel kan Trotter-Suzuki diskompositionen anropas med hjälp av följande Canon functions, med parametrar `trotterStepSize` ändra varaktigheten för simuleringen i varje exponentiell och `trotterOrder` för den önskade integratorns ordning.</span><span class="sxs-lookup"><span data-stu-id="c399b-155">As an example, the Trotter-Suzuki decomposition may be called using the following canon functions, with parameters `trotterStepSize` modifying the duration of simulation in each exponential, and `trotterOrder` for the order of the desired integrator.</span></span>

```qsharp
function TrotterSimulationAlgorithm(
    trotterStepSize : Double, 
    trotterOrder : Int) 
: SimulationAlgorithm {
    ...
}

function TimeDependentTrotterSimulationAlgorithm(
    trotterStepSize : Double, 
    trotterOrder : Int) 
: TimeDependentSimulationAlgorithm {
    ...
}
```

> [!TIP]
> <span data-ttu-id="c399b-156">Program för simulerings biblioteket beskrivs i exemplen.</span><span class="sxs-lookup"><span data-stu-id="c399b-156">Applications of the simulation library are covered in the samples.</span></span> <span data-ttu-id="c399b-157">För fas uppskattning i Ising-modellen med hjälp av `SimulationAlgorithm`, se [ **IsingPhaseEstimation** -exemplet](https://github.com/microsoft/Quantum/tree/master/samples/simulation/ising/phase-estimation).</span><span class="sxs-lookup"><span data-stu-id="c399b-157">For phase estimation in the Ising model using `SimulationAlgorithm`, please see the [**IsingPhaseEstimation** sample](https://github.com/microsoft/Quantum/tree/master/samples/simulation/ising/phase-estimation).</span></span>
> <span data-ttu-id="c399b-158">För förberedelse av adiabatic-tillstånd i Ising-modellen med hjälp av `TimeDependentSimulationAlgorithm`, se exemplet på [ **AdiabaticIsing** ](https://github.com/microsoft/Quantum/tree/master/samples/simulation/ising/adiabatic).</span><span class="sxs-lookup"><span data-stu-id="c399b-158">For adiabatic state preparation in the Ising model using `TimeDependentSimulationAlgorithm`, please see the [**AdiabaticIsing** sample](https://github.com/microsoft/Quantum/tree/master/samples/simulation/ising/adiabatic).</span></span>


### <a name="adiabatic-state-preparation--phase-estimation"></a><span data-ttu-id="c399b-159">Adiabatic för att förbereda & fas uppskattning</span><span class="sxs-lookup"><span data-stu-id="c399b-159">Adiabatic State Preparation & Phase Estimation</span></span> ###

<span data-ttu-id="c399b-160">Ett vanligt program för Hamiltonian-simulering är adiabatic-tillstånds förberedelse.</span><span class="sxs-lookup"><span data-stu-id="c399b-160">One common application of Hamiltonian simulation is adiabatic state preparation.</span></span> <span data-ttu-id="c399b-161">Här följer två Hamiltonians-$H\_{\text{start}} $ och $H\_{\text{End}} $ och ett Quantum-tillstånd $ \ket{\psi (0)} $ som är ett mark läge för start Hamiltonian $H\_{\text{start}} $.</span><span class="sxs-lookup"><span data-stu-id="c399b-161">Here, one is provided with two Hamiltonians $H\_{\text{start}}$ and $H\_{\text{end}}$, and a quantum state $\ket{\psi(0)}$ that is a ground state of the start Hamiltonian $H\_{\text{start}}$.</span></span> <span data-ttu-id="c399b-162">Vanligt vis väljs $H\_{\text{start}} $ så att $ \ket{\psi (0)} $ är enkelt att förbereda från beräknings bas tillstånd $ \ket{0\cdots 0} $.</span><span class="sxs-lookup"><span data-stu-id="c399b-162">Typically, $H\_{\text{start}}$ is chosen such that $\ket{\psi(0)}$ is easy to prepare from a computational basis state $\ket{0\cdots 0}$.</span></span> <span data-ttu-id="c399b-163">Genom interpolating mellan dessa Hamiltonians i tids beroende simulerings problem tillräckligt långsamt, är det möjligt att uppnå hög sannolikhet i det slutliga Hamiltonian $H\_{\text{End}} $.</span><span class="sxs-lookup"><span data-stu-id="c399b-163">By interpolating between these Hamiltonians in the time-dependent simulation problem sufficiently slowly, it is possible to end up, with high probability, in a ground state of the final Hamiltonian $H\_{\text{end}}$.</span></span> <span data-ttu-id="c399b-164">Även om det går att förbereda en utmärkt uppskattning av Hamiltonian-länder kan du gå vidare på det här sättet genom att anropa på tids beroende Hamiltonian simulerings algoritmer som en subrutin, andra konceptuella metoder, till exempel variationen Quantum eigensolver är möjliga.</span><span class="sxs-lookup"><span data-stu-id="c399b-164">Though preparing good approximations to Hamiltonian ground states could proceed in this manner by calling upon on time-dependent Hamiltonian simulation algorithms as a subroutine, other conceptually different approaches such as the variational quantum eigensolver are possible.</span></span>

<span data-ttu-id="c399b-165">Ännu en annan program allmänt förekommande i Quantum kemi uppskattar den markbaserade energin för Hamiltonians som representerar de mellanliggande stegen för kemisk reaktion.</span><span class="sxs-lookup"><span data-stu-id="c399b-165">Yet another application ubiquitous in quantum chemistry is estimating the ground state energy of Hamiltonians representing the intermediate steps of chemical reaction.</span></span> <span data-ttu-id="c399b-166">Ett sådant schema kan t. ex. förlita sig på adiabatic State-förberedelse för att skapa ett jord-tillstånd och sedan införliva den tidsbegränsade Hamiltonian-simuleringen som en del rutin i beräknings beräknings karakteriseringen för att extrahera denna energi med ett begränsat fel och sannolikheten lyckades.</span><span class="sxs-lookup"><span data-stu-id="c399b-166">Such a scheme could, for instance, rely on adiabatic state preparation to create the ground state, and then incorporate time-independent Hamiltonian simulation as a subroutine in phase estimation characterization to extract this energy with some finite error and probability of success.</span></span> 

<span data-ttu-id="c399b-167">Algoritmer för att beräkna simuleringar som användardefinierade typer `SimulationAlgorithm` och `TimeDependentSimulationAlgorithm` göra det möjligt för oss att enkelt införliva sina funktioner i mer avancerade Quantum-algoritmer.</span><span class="sxs-lookup"><span data-stu-id="c399b-167">Abstracting simulation algorithms as the user-defined types `SimulationAlgorithm` and `TimeDependentSimulationAlgorithm` allow us to conveniently incorporate their functionality into more sophisticated quantum algorithms.</span></span> <span data-ttu-id="c399b-168">Detta motiverar oss att göra samma sak för de här ofta använda underrutinerna.</span><span class="sxs-lookup"><span data-stu-id="c399b-168">This motivates us to do the same for these commonly used subroutines.</span></span>

<span data-ttu-id="c399b-169">Vi definierar därför den praktiska funktionen</span><span class="sxs-lookup"><span data-stu-id="c399b-169">Thus we define the convenient function</span></span>

```qsharp
function InterpolatedEvolution(
        interpolationTime : Double, 
        evolutionGeneratorStart : EvolutionGenerator,
        evolutionGeneratorEnd : EvolutionGenerator,
        timeDependentSimulationAlgorithm : TimeDependentSimulationAlgorithm)
: (Qubit[] => Unit is Adj + Ctl) {
        ...
}
 
```

<span data-ttu-id="c399b-170">Detta returnerar en enhetlig åtgärd som implementerar alla steg i adiabatic-tillstånds förberedelse.</span><span class="sxs-lookup"><span data-stu-id="c399b-170">This returns a unitary operation that implements all steps of adiabatic state preparation.</span></span> <span data-ttu-id="c399b-171">Den första parametern `interpolatedTime` definierar den tid över vilken vi linjärt interpolerar mellan start-Hamiltonian som beskrivs av den andra parametern `evolutionGeneratorStart` och slut Hamiltonian som beskrivs av den tredje parametern `evolutionGeneratorEnd`.</span><span class="sxs-lookup"><span data-stu-id="c399b-171">The first parameter `interpolatedTime` defines the time over which we linearly interpolate between the start Hamiltonian described by the second parameter `evolutionGeneratorStart` and the end Hamiltonian described by the third parameter `evolutionGeneratorEnd`.</span></span> <span data-ttu-id="c399b-172">Den fjärde parametern `timeDependentSimulationAlgorithm` är där du kan välja simulerings algoritm.</span><span class="sxs-lookup"><span data-stu-id="c399b-172">The fourth parameter `timeDependentSimulationAlgorithm` is where one makes the choice of simulation algorithm.</span></span> <span data-ttu-id="c399b-173">Observera att om `interpolatedTime` är tillräckligt lång, är ett initialt jord tillstånd kvar i Hamiltonian under hela tiden för tids beroende simulering och därmed avslutas i slutet av slut Hamiltonian.</span><span class="sxs-lookup"><span data-stu-id="c399b-173">Note that if `interpolatedTime` is long enough, an initial ground state remains an instantaneous ground state of the Hamiltonian over the entire duration of time-dependent simulation, and thus ends in the ground state of the end Hamiltonian.</span></span>

<span data-ttu-id="c399b-174">Vi definierar också en användbar åtgärd som automatiskt utför alla steg i ett typiskt Quantum kemi-experiment.</span><span class="sxs-lookup"><span data-stu-id="c399b-174">We also define a helpful operation that automatically performs all steps of a typical quantum chemistry experiment.</span></span> <span data-ttu-id="c399b-175">Till exempel har vi följande, som returnerar en energi uppskattning av den status som produceras av adiabatic-tillstånds förberedelse:</span><span class="sxs-lookup"><span data-stu-id="c399b-175">For instance we have the following, which returns an energy estimate of the state produced by adiabatic state preparation:</span></span>

```qsharp
operation EstimateAdiabaticStateEnergy(
    nQubits : Int,
    statePrepUnitary : (Qubit[] => Unit),
    adiabaticUnitary : (Qubit[] => Unit),
    qpeUnitary: (Qubit[] => Unit is Adj + Ctl),
    phaseEstAlgorithm : ((DiscreteOracle, Qubit[]) => Double))
: Double {
...
}
```

<span data-ttu-id="c399b-176">`nQubits` är antalet qubits som används för att koda det inledande Quantum-läget.</span><span class="sxs-lookup"><span data-stu-id="c399b-176">`nQubits` is the number of qubits used to encode the initial quantum state.</span></span> <span data-ttu-id="c399b-177">`statePrepUnitary` förbereder start tillstånd från beräknings basen $ \ket{0\cdots 0} $.</span><span class="sxs-lookup"><span data-stu-id="c399b-177">`statePrepUnitary` prepares the start state from the computational basis $\ket{0\cdots 0}$.</span></span> <span data-ttu-id="c399b-178">`adiabaticUnitary` är en enhetlig åtgärd som implementerar adiabatic-tillstånds förberedelse, till exempel producerad av funktionen `InterpolatedEvolution`.</span><span class="sxs-lookup"><span data-stu-id="c399b-178">`adiabaticUnitary` is the unitary operation that implements adiabatic state preparation, such as produced by the  `InterpolatedEvolution` function.</span></span> <span data-ttu-id="c399b-179">`qpeUnitary` är den enhetliga åtgärd som används för att utföra fas uppskattningar i det resulterande steget.</span><span class="sxs-lookup"><span data-stu-id="c399b-179">`qpeUnitary` is the unitary operation that is used to perform phase estimation on the resulting quantum state.</span></span> <span data-ttu-id="c399b-180">`phaseEstAlgorithm` är vårt val av algoritm för fas uppskattning.</span><span class="sxs-lookup"><span data-stu-id="c399b-180">`phaseEstAlgorithm` is our choice of phase estimation algorithm.</span></span>

> [!TIP]
> <span data-ttu-id="c399b-181">Program för förberedelse av adiabatic-tillstånd beskrivs i exemplen.</span><span class="sxs-lookup"><span data-stu-id="c399b-181">Applications of adiabatic state preparation are covered in the samples.</span></span> <span data-ttu-id="c399b-182">För Ising-modellen med en manuell implementering av adiabatic-tillstånds förberedelse jämfört med `AdiabaticEvolution` funktionen, se exemplet på [ **AdiabaticIsing** ](https://github.com/microsoft/Quantum/tree/master/samples/simulation/ising/adiabatic).</span><span class="sxs-lookup"><span data-stu-id="c399b-182">For the Ising model using a manual implementation of adiabatic state preparation versus using the `AdiabaticEvolution` function, please see the [**AdiabaticIsing** sample](https://github.com/microsoft/Quantum/tree/master/samples/simulation/ising/adiabatic).</span></span>
> <span data-ttu-id="c399b-183">För fas uppskattning och förberedelse av adiabatic-tillstånd i Ising-modellen, se [exemplet på **IsingPhaseEstimation** ](https://github.com/microsoft/Quantum/tree/master/samples/simulation/ising/phase-estimation).</span><span class="sxs-lookup"><span data-stu-id="c399b-183">For phase estimation and adiabatic state preparation in the Ising model, please see the [**IsingPhaseEstimation** sample](https://github.com/microsoft/Quantum/tree/master/samples/simulation/ising/phase-estimation).</span></span>

> [!TIP]
> <span data-ttu-id="c399b-184">[Simuleringen av molekylen väte](https://github.com/microsoft/Quantum/tree/master/samples/simulation/h2/command-line) är ett intressant och kort exempel.</span><span class="sxs-lookup"><span data-stu-id="c399b-184">The [simulation of molecular Hydrogen](https://github.com/microsoft/Quantum/tree/master/samples/simulation/h2/command-line) is an interesting and brief sample.</span></span> <span data-ttu-id="c399b-185">Modell-och experiment resultaten som rapporteras i [O'Malley et. Al.](https://arxiv.org/abs/1512.06860)</span><span class="sxs-lookup"><span data-stu-id="c399b-185">The model and experimental results reported in [O'Malley et. al.](https://arxiv.org/abs/1512.06860)</span></span> <span data-ttu-id="c399b-186">kräver bara Pauli-matriser och använder formatet $ \hat H = g\_{0}\_0I\_1 + g\_1 {Z\_0} + g\_2 {Z\_1} + g\_3 {Z\_0} {Z\_1} + g\_4 {Y\_0} {Y\_1} + g\_5 {X\_0} {X\_1} $.</span><span class="sxs-lookup"><span data-stu-id="c399b-186">only requires Pauli matrices and takes the form $\hat H = g\_{0}I\_0I\_1+g\_1{Z\_0}+g\_2{Z\_1}+g\_3{Z\_0}{Z\_1}+g\_4{Y\_0}{Y\_1}+g\_5{X\_0}{X\_1}$.</span></span> <span data-ttu-id="c399b-187">Detta är en effektiv Hamiltonian som bara behöver bara två qubits, där konstanterna $g $ beräknas från avståndet $R $ mellan de två väte-atomerna.</span><span class="sxs-lookup"><span data-stu-id="c399b-187">This is an effective Hamiltonian only requiring only 2 qubits, where the constants $g$ are computed from the distance $R$ between the two Hydrogen atoms.</span></span> <span data-ttu-id="c399b-188">Med hjälp av Canon functions, konverteras Johan till unitaries och sedan utvecklats över korta tids perioder med hjälp av Trotter-Suzuki-dekompositionen.</span><span class="sxs-lookup"><span data-stu-id="c399b-188">Using canon functions, the Paulis are converted to unitaries and then evolved over short periods of time using the Trotter-Suzuki decomposition.</span></span> <span data-ttu-id="c399b-189">Det går att skapa en utmärkt uppskattning av $H _2 $ mark State utan att använda adiabatic och så att energi tillståndets energi kan hittas direkt genom att använda fas uppskattning från Canon.</span><span class="sxs-lookup"><span data-stu-id="c399b-189">A good approximation to the $H_2$ ground state can be created without using adiabatic state preparation, and so the ground state energy may be found directly by utilizing phase estimation from the canon.</span></span>

## <a name="shors-algorithm"></a><span data-ttu-id="c399b-190">Shors algoritm</span><span class="sxs-lookup"><span data-stu-id="c399b-190">Shor's Algorithm</span></span> ##
<span data-ttu-id="c399b-191">Shor-algoritmen är inte en av de viktigaste fördelarna med Quantum Computing eftersom den visade att Quantum Computers kan användas för att lösa viktiga, för närvarande inaktiverade problem.</span><span class="sxs-lookup"><span data-stu-id="c399b-191">Shor's algorithm remains one of the most significant developments in quantum computing because it showed that quantum computers could be used to solve important, currently classically intractable problems.</span></span>
<span data-ttu-id="c399b-192">Shor-algoritmen är ett snabbt sätt att väga stora tal med en Quantum-dator, ett problem som kallas för *factoring*.</span><span class="sxs-lookup"><span data-stu-id="c399b-192">Shor's algorithm provides a fast way to factor large numbers using a quantum computer, a problem called *factoring*.</span></span>
<span data-ttu-id="c399b-193">Säkerheten för många befintliga cryptosystems baseras på antagandet att det inte finns någon snabb algoritm för factoring.</span><span class="sxs-lookup"><span data-stu-id="c399b-193">The security of many present-day cryptosystems is based on the assumption that no fast algorithm exists for factoring.</span></span>
<span data-ttu-id="c399b-194">Därför har Shor-algoritmen haft en Profound inverkan på hur vi tycker om säkerhet i en post-Quantum World.</span><span class="sxs-lookup"><span data-stu-id="c399b-194">Thus Shor's algorithm has had a profound impact on how we think about security in a post-quantum world.</span></span>

<span data-ttu-id="c399b-195">Shor-algoritmen kan betraktas som en hybrid algoritm.</span><span class="sxs-lookup"><span data-stu-id="c399b-195">Shor's algorithm can be thought of as a hybrid algorithm.</span></span>
<span data-ttu-id="c399b-196">Quantum-datorn används för att utföra en beräknings hårt aktivitet som kallas för att söka efter perioder.</span><span class="sxs-lookup"><span data-stu-id="c399b-196">The quantum computer is used to perform a computationally hard task known as period finding.</span></span>
<span data-ttu-id="c399b-197">Resultaten från periods ökningen bearbetas sedan som en uppskattning av faktorerna.</span><span class="sxs-lookup"><span data-stu-id="c399b-197">The results from period finding are then classically processed to estimate the factors.</span></span>
<span data-ttu-id="c399b-198">Vi går igenom de här två stegen nedan.</span><span class="sxs-lookup"><span data-stu-id="c399b-198">We review these two steps below.</span></span>

### <a name="period-finding"></a><span data-ttu-id="c399b-199">Period sökning</span><span class="sxs-lookup"><span data-stu-id="c399b-199">Period Finding</span></span> ###

<span data-ttu-id="c399b-200">Vi har sett hur Quantum Fourier-transformeringen och fas uppskattningen fungerar (se [Quantum-algoritmer](xref:microsoft.quantum.libraries.standard.algorithms)). vi kan använda dessa verktyg för att lösa ett klassiskt hårt beräknings problem som kallas för *period sökning*.</span><span class="sxs-lookup"><span data-stu-id="c399b-200">Having seen how the quantum Fourier transform and phase estimation work (see [Quantum algorithms](xref:microsoft.quantum.libraries.standard.algorithms)), we can use these tools to solve a classically hard computational problem called *period finding*.</span></span>  <span data-ttu-id="c399b-201">I nästa avsnitt kommer vi att se hur perioden kan användas för att debiteras.</span><span class="sxs-lookup"><span data-stu-id="c399b-201">In the next section, we will see how to apply period finding to factoring.</span></span>

<span data-ttu-id="c399b-202">Med två heltal $a $ och $N $, där $a < N $, målet för perioden som söker, även kallat order sökning, är att hitta _order_ $r $ $a $ modulo $N $, där $r $ har definierats som minst positivt heltal som $a ^ r \equiv 1 \text{mod} N $.</span><span class="sxs-lookup"><span data-stu-id="c399b-202">Given two integers $a$ and $N$, where $a<N$, the goal of period finding, also called order finding, is to find the _order_ $r$ of $a$ modulo $N$, where $r$ is defined to be the least positive integer such that $a^r \equiv 1 \text{ mod } N$.</span></span>  

<span data-ttu-id="c399b-203">För att hitta beställningen med en Quantum-dator kan vi använda fasen för fas uppskattning som tillämpas på följande enhetliga operatör $U _a $: $ $ U_a \ket{x} \equiv \ket{(AX) \text{mod} N}. $ $ eigenvectors för $U _a $ är för heltal $s $ och $0 \ LEQ s \leq r-$1, $ $ \ket{x_s} \equiv 1/\sqrt{r} \sum\_{k = 0} ^ {r-1} e ^ {\frac{-2\pi i sk} {r}} \ket{a ^ k\text {rest} N}, $ $ är _eigenstates_ av $U _A $.</span><span class="sxs-lookup"><span data-stu-id="c399b-203">To find the order using a quantum computer, we can use the phase estimation algorithm applied to the following unitary operator $U_a$: $$ U_a\ket{x} \equiv \ket{(ax)\text{ mod }N} .$$ The eigenvectors of $U_a$ are for integer $s$ and $0\leq s \leq r - 1$, $$\ket{x_s} \equiv 1 / \sqrt{r} \sum\_{k=0}^{r-1} e^{\frac{-2\pi i sk}{r}} \ket{a^k\text{ mod }N},$$ are _eigenstates_ of $U_a$.</span></span>
<span data-ttu-id="c399b-204">Eigenvalues för $U _a $ är $ $ U\_en \ket{x\_s} = e ^ {2 \ Pi i s/r} \ket{x\_s}.</span><span class="sxs-lookup"><span data-stu-id="c399b-204">The eigenvalues of $U_a$ are $$ U\_a \ket{x\_s} = e^{2\pi i s / r} \ket{x\_s} .</span></span> $$

<span data-ttu-id="c399b-205">Fas uppskattningen utökar därmed Eigenvalues $e ^ {2 \ Pi i s/r} $ från vilken $r $ kan läsas effektivt med hjälp av [fortsatt bråk](https://en.wikipedia.org/wiki/Continued_fraction) från $s/r $.</span><span class="sxs-lookup"><span data-stu-id="c399b-205">Phase estimation thus outputs the eigenvalues $e^{2\pi i s / r}$ from which $r$ can be learned efficiently using [continued fractions](https://en.wikipedia.org/wiki/Continued_fraction) from $s / r$.</span></span>

<span data-ttu-id="c399b-206">Krets diagrammet för Quantum period är:</span><span class="sxs-lookup"><span data-stu-id="c399b-206">The circuit diagram for quantum period finding is:</span></span>

![](./../../media/QPE.svg)

<span data-ttu-id="c399b-207">Här $2n $ qubits initieras till $ \ket{0}$ och $n $ qubits initieras till $ \ket{1}$.</span><span class="sxs-lookup"><span data-stu-id="c399b-207">Here $2n$ qubits are initialized to $\ket{0}$ and $n$ qubits are initialized to $\ket{1}$.</span></span>
<span data-ttu-id="c399b-208">Det kan hända att läsaren återigen undrar varför den Quantum-registreraren för att hålla eigenstates initieras till $ \ket{1}$.</span><span class="sxs-lookup"><span data-stu-id="c399b-208">The reader again may wonder why the quantum register to hold the eigenstates is initialized to $\ket{1}$.</span></span>
<span data-ttu-id="c399b-209">Eftersom en inte känner till order $r $ i förväg, kan vi faktiskt inte förbereda $ \ket{x_s} $-tillstånd direkt.</span><span class="sxs-lookup"><span data-stu-id="c399b-209">As one does not know the order $r$ in advance, we cannot actually prepare $\ket{x_s}$ states directly.</span></span>
<span data-ttu-id="c399b-210">Som tur är, det visar sig att $1/\ sqrt {r} \sum\_{s = 0} ^ {r-1} \ket{x\_s} = \ket{1}$.</span><span class="sxs-lookup"><span data-stu-id="c399b-210">Luckily, it turns out that $1/\sqrt{r} \sum\_{s=0}^{r-1} \ket{x\_s} = \ket{1}$.</span></span>
<span data-ttu-id="c399b-211">Vi behöver faktiskt inte förbereda $ \ket{x} $!</span><span class="sxs-lookup"><span data-stu-id="c399b-211">We don't need to actually prepare $\ket{x}$!</span></span>
<span data-ttu-id="c399b-212">Vi kan bara förbereda ett Quantum-register över $n $ qubits i stat $ \ket{1}$.</span><span class="sxs-lookup"><span data-stu-id="c399b-212">We can just prepare a quantum register of $n$ qubits in state $\ket{1}$.</span></span> 

<span data-ttu-id="c399b-213">Kretsen innehåller QFT och flera kontrollerade portar.</span><span class="sxs-lookup"><span data-stu-id="c399b-213">The circuit contains the QFT and several controlled gates.</span></span>
<span data-ttu-id="c399b-214">QFT-porten har beskrivits [tidigare](xref:microsoft.quantum.libraries.standard.algorithms).</span><span class="sxs-lookup"><span data-stu-id="c399b-214">The QFT gate has been described [previously](xref:microsoft.quantum.libraries.standard.algorithms).</span></span>
<span data-ttu-id="c399b-215">Det styrda-$U _a $ Gate Maps $ \ket{x} $ till $ \ket{(AX) \text{mod} N} $ om kontrollen qubit är $ \ket{1}$ och mappar $ \ket{x} $ till $ \ket{x} $ annars.</span><span class="sxs-lookup"><span data-stu-id="c399b-215">The controlled-$U_a$ gate maps $\ket{x}$ to $\ket{(ax)\text{ mod } N}$ if the control qubit is $\ket{1}$, and maps $\ket{x}$ to $\ket{x}$ otherwise.</span></span>

<span data-ttu-id="c399b-216">För att uppnå $ (a ^ NX) \text{mod} N $ kan vi helt enkelt tillämpa styrd-$U _ {a ^ N} $, där vi beräknar $a ^ N \text{mod} N $ som är klassiska för att ansluta till Quantum-kretsen.</span><span class="sxs-lookup"><span data-stu-id="c399b-216">To achieve $(a^nx)\text{ mod } N$,  we can simply apply controlled-$U_{a^n}$, where we calculate $a^n \text{ mod } N$ classically to plug into the quantum circuit.</span></span>  
<span data-ttu-id="c399b-217">Kretsarna för att uppnå sådana modulära beräkningar har beskrivits i den [Quantum-aritmetiska dokumentationen](./algorithms.md#arithmetic), i synnerhet vi kräver en modulär exponent krets för att implementera de kontrollerade $U\_{a ^ i} $-åtgärder.</span><span class="sxs-lookup"><span data-stu-id="c399b-217">The circuits to achieve such modular arithmetic have been described in the [quantum arithmetic documentation](./algorithms.md#arithmetic), specifically we require a modular exponentiation circuit to implement the controlled-$U\_{a^i}$ operations.</span></span>

<span data-ttu-id="c399b-218">Även om kretsen ovan motsvarar Quantum- [fas-uppskattningen](xref:microsoft.quantum.characterization.quantumphaseestimation) och explicit aktiverar order upptäckt, kan vi minska antalet qubits som krävs.</span><span class="sxs-lookup"><span data-stu-id="c399b-218">While the circuit above corresponds to [Quantum Phase Estimation](xref:microsoft.quantum.characterization.quantumphaseestimation) and explicitly enables order finding, we can reduce the number of qubits required.</span></span> <span data-ttu-id="c399b-219">Vi kan antingen följa Beauregard-metoden för order sökning enligt beskrivningen [på sidan 8 i arXiv: Quant-pH/0205095v3](https://arxiv.org/pdf/quant-ph/0205095v3.pdf#page=8)eller använda en av de fas uppskattnings rutiner som finns i Microsoft. Quantum. karakterisering.</span><span class="sxs-lookup"><span data-stu-id="c399b-219">We can either follow Beauregard's method for order finding as described [on Page 8 of arXiv:quant-ph/0205095v3](https://arxiv.org/pdf/quant-ph/0205095v3.pdf#page=8), or use one of the phase estimation routines available in Microsoft.Quantum.Characterization.</span></span> <span data-ttu-id="c399b-220">Till exempel använder [robust fas uppskattning](xref:microsoft.quantum.characterization.robustphaseestimation) också en extra qubit.</span><span class="sxs-lookup"><span data-stu-id="c399b-220">For example, [Robust Phase Estimation](xref:microsoft.quantum.characterization.robustphaseestimation) also uses one extra qubit.</span></span>
 
### <a name="factoring"></a><span data-ttu-id="c399b-221">Hänsyn</span><span class="sxs-lookup"><span data-stu-id="c399b-221">Factoring</span></span> ###
<span data-ttu-id="c399b-222">Syftet med att använda factoring är att fastställa de två viktigaste faktorerna i heltal $N $, där $N $ är ett $n $-bitars nummer.</span><span class="sxs-lookup"><span data-stu-id="c399b-222">The goal of factoring is to determine the two prime factors of integer $N$, where $N$ is an $n$-bit number.</span></span>  
<span data-ttu-id="c399b-223">Factoring består av stegen som beskrivs nedan.</span><span class="sxs-lookup"><span data-stu-id="c399b-223">Factoring consists of the steps described below.</span></span> <span data-ttu-id="c399b-224">Stegen delas upp i tre delar: en klassisk för bearbetnings rutin (1-4). en Quantum Computing-rutin för att hitta ordningen på $a \text{mod} N $ (5); och en klassisk postprocessing-rutin för att härleda de viktigaste faktorerna från ordern (6-9).</span><span class="sxs-lookup"><span data-stu-id="c399b-224">The steps are split into three parts: a classical preprocessing routine (1-4); a quantum computing routine to find the order of $a \text{ mod } N$ (5); and a classical postprocessing routine to derive the prime factors from the order (6-9).</span></span>

<span data-ttu-id="c399b-225">Den klassiska för bearbetnings rutinen består av följande steg:</span><span class="sxs-lookup"><span data-stu-id="c399b-225">The classical preprocessing routine consists of the following steps:</span></span>
1. <span data-ttu-id="c399b-226">Om $N $ är ens returnerar du den primära faktorn $2 $.</span><span class="sxs-lookup"><span data-stu-id="c399b-226">If $N$ is even, return the prime factor $2$.</span></span>
2. <span data-ttu-id="c399b-227">Om $N = p ^ q $ för $p \geq1 $, $q \geq2 $, returnerar du den primära faktorn $p $.</span><span class="sxs-lookup"><span data-stu-id="c399b-227">If $N=p^q$ for $p\geq1$, $q\geq2$, return the prime factor $p$.</span></span>  <span data-ttu-id="c399b-228">Det här steget utförs i klassiskt läge.</span><span class="sxs-lookup"><span data-stu-id="c399b-228">This step is performed classically.</span></span>
3. <span data-ttu-id="c399b-229">Välj ett slumptal $a $ så att $1 < en < N-$1.</span><span class="sxs-lookup"><span data-stu-id="c399b-229">Choose a random number $a$ such that $1 < a < N-1$.</span></span>
4. <span data-ttu-id="c399b-230">Om $ \text{GCD} (a, N) > 1 $ returnerar du den primära faktorn $ \text{GCD} (a, N) $.</span><span class="sxs-lookup"><span data-stu-id="c399b-230">If $\text{gcd}(a,N)>1$, return the prime factor $\text{gcd}(a,N)$.</span></span> <span data-ttu-id="c399b-231">Det här steget beräknas med Euclid-algoritmen.</span><span class="sxs-lookup"><span data-stu-id="c399b-231">This step is computed using Euclid's algorithm.</span></span>
<span data-ttu-id="c399b-232">Om ingen primär faktor har returnerats går vi vidare till Quantum-rutinen:</span><span class="sxs-lookup"><span data-stu-id="c399b-232">If no prime factor has been returned, we proceed to the quantum routine:</span></span>
5. <span data-ttu-id="c399b-233">Anropa den Quantum perioden hitta algoritmen för att beräkna ordningen $r $ för $a \text{mod} N $.</span><span class="sxs-lookup"><span data-stu-id="c399b-233">Call the quantum period finding algorithm to calculate the order $r$ of $a \text{ mod } N$.</span></span> <span data-ttu-id="c399b-234">Använd $r $ i den klassiska postprocessing-rutinen för att fastställa de viktigaste faktorerna:</span><span class="sxs-lookup"><span data-stu-id="c399b-234">Use $r$ in the classical postprocessing routine to determine the prime factors:</span></span>
6. <span data-ttu-id="c399b-235">Om $r $ är ojämn går du tillbaka till förbearbetnings steget (3).</span><span class="sxs-lookup"><span data-stu-id="c399b-235">If $r$ is odd, go back to preprocessing step (3).</span></span>
7. <span data-ttu-id="c399b-236">Om $r $ är jämnt och $a ^ {r/2} =-1 \ text {mod} N $ går du tillbaka till för bearbetnings steg (3).</span><span class="sxs-lookup"><span data-stu-id="c399b-236">If $r$ is even and $a^{r/2} = -1\text{ mod }N$, go back to preprocessing step (3).</span></span>
8. <span data-ttu-id="c399b-237">Om $ \text{GCD} (a ^ {r/2} + 1, N) $ är en icke-trivial faktor för $N $ Returnerar du $ \text{GCD} (a ^ {r/2} + 1, N) $.</span><span class="sxs-lookup"><span data-stu-id="c399b-237">If $\text{gcd}(a^{r/2}+1, N)$ is a non-trivial factor of $N$, return $\text{gcd}(a^{r/2}+1, N)$.</span></span>
9. <span data-ttu-id="c399b-238">Om $ \text{GCD} (a ^ {r/2}-1, N) $ är en icke-trivial faktor på $N $ Returnerar du $ \text{GCD} (a ^ {r/2}-1, N) $.</span><span class="sxs-lookup"><span data-stu-id="c399b-238">If $\text{gcd}(a^{r/2}-1, N)$ is a non-trivial factor of $N$, return $\text{gcd}(a^{r/2}-1, N)$.</span></span>


<span data-ttu-id="c399b-239">Factoring-algoritmen är Probabilistic: den kan visas med sannolikheten minst en halv som $r $ kommer att vara jämn och $a ^ {r/2} \neq-1 \text{mod} N $, vilket skapar en primär faktor.</span><span class="sxs-lookup"><span data-stu-id="c399b-239">The factoring algorithm is probabilistic: it can been shown that with probability at least one half that $r$ will be even and $a^{r/2} \neq -1 \text{ mod }N$, thus producing a prime factor.</span></span>  <span data-ttu-id="c399b-240">(Mer information finns i [Shor original Paper](https://doi.org/10.1109/SFCS.1994.365700) eller något av de *grundläggande Quantum Computing* -texterna i [för mer information](xref:microsoft.quantum.more-information)).</span><span class="sxs-lookup"><span data-stu-id="c399b-240">(See [Shor's original paper](https://doi.org/10.1109/SFCS.1994.365700) for details, or one of the *Basic quantum computing* texts in [For more information](xref:microsoft.quantum.more-information)).</span></span>
<span data-ttu-id="c399b-241">Om en primär faktor inte returneras upprepar vi bara algoritmen från steg (1).</span><span class="sxs-lookup"><span data-stu-id="c399b-241">If a prime factor is not returned, then we simply repeat the algorithm from step (1).</span></span>  <span data-ttu-id="c399b-242">När $n $ försöker är sannolikheten att varje försök har misslyckats högst $2 ^ {-n} $.</span><span class="sxs-lookup"><span data-stu-id="c399b-242">After $n$ tries, the probability that every attempt has failed is at most $2^{-n}$.</span></span>
<span data-ttu-id="c399b-243">Därför är det ett litet antal gånger som lyckats när algoritmen har upprepats.</span><span class="sxs-lookup"><span data-stu-id="c399b-243">Thus after repeating the algorithm a small number of times success is virtually assured.</span></span>
