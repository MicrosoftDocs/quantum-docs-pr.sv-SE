---
title: 'Diagnostik i standard biblioteken för Q #'
description: 'Lär dig mer om diagnostiska funktioner och åtgärder i de Q # standard-bibliotek som används för att fånga misstag eller fel i Quantum-program.'
author: cgranade
uid: microsoft.quantum.libraries.diagnostics
ms.author: chgranad@microsoft.com
ms.topic: article
ms.openlocfilehash: ba2f248327bb3db4ee895f8e65ea31c17e42b5f4
ms.sourcegitcommit: 6ccea4a2006a47569c4e2c2cb37001e132f17476
ms.translationtype: MT
ms.contentlocale: sv-SE
ms.lasthandoff: 02/28/2020
ms.locfileid: "77906244"
---
# <a name="diagnostics"></a><span data-ttu-id="93a7c-103">Diagnostik</span><span class="sxs-lookup"><span data-stu-id="93a7c-103">Diagnostics</span></span> #

<span data-ttu-id="93a7c-104">Precis som med klassisk utveckling är det viktigt att kunna diagnostisera misstag och fel i Quantum-program.</span><span class="sxs-lookup"><span data-stu-id="93a7c-104">As with classical development, it is important to be able to diagnose mistakes and errors in quantum programs.</span></span>
<span data-ttu-id="93a7c-105">Standard biblioteken för Q # är en mängd olika sätt att säkerställa att Quantum program är korrekt, enligt beskrivningen i <xref:microsoft.quantum.techniques.testing-and-debugging>.</span><span class="sxs-lookup"><span data-stu-id="93a7c-105">The Q# standard libraries provide a variety of different ways to ensure the correctness of quantum programs, as detailed in <xref:microsoft.quantum.techniques.testing-and-debugging>.</span></span>
<span data-ttu-id="93a7c-106">Den här supporten är i stort sett i form av funktioner och åtgärder som antingen instruerar mål datorn att tillhandahålla ytterligare diagnostikinformation till värd programmet eller utvecklaren, eller tillämpa rätt villkor och invarianter som uttrycks av funktions-eller åtgärds anropet.</span><span class="sxs-lookup"><span data-stu-id="93a7c-106">Largely speaking, this support comes in the form of functions and operations that either instruct the target machine to provide additional diagnostic information to the host program or developer, or enforce the correctness of conditions and invariants expressed by the function or operation call.</span></span>

## <a name="machine-diagnostics"></a><span data-ttu-id="93a7c-107">Machine Diagnostics</span><span class="sxs-lookup"><span data-stu-id="93a7c-107">Machine Diagnostics</span></span> ##

<span data-ttu-id="93a7c-108">Diagnostik med klassiska värden kan erhållas med hjälp av funktionen <xref:microsoft.quantum.intrinsic.message> för att logga ett meddelande på ett dator beroende sätt.</span><span class="sxs-lookup"><span data-stu-id="93a7c-108">Diagnostics about classical values can be obtained by using the <xref:microsoft.quantum.intrinsic.message> function to log a message in a machine-dependent way.</span></span>
<span data-ttu-id="93a7c-109">Som standard skriver detta strängen till-konsolen.</span><span class="sxs-lookup"><span data-stu-id="93a7c-109">By default, this writes the string to the console.</span></span>
<span data-ttu-id="93a7c-110"><xref:microsoft.quantum.intrinsic.message> är tillsammans med interpolerade strängar och gör det enkelt att rapportera diagnostikinformation om klassiska värden:</span><span class="sxs-lookup"><span data-stu-id="93a7c-110">Used together with interpolated strings, <xref:microsoft.quantum.intrinsic.message> makes it easy to report diagnostic information about classical values:</span></span>

```Q#
let angle = Microsoft.Quantum.Math.PI() * 2.0 / 3.0;
Message($"About to rotate by an angle of {angle}...");
```

> [!NOTE]
> <span data-ttu-id="93a7c-111">`Message` har signatur `(String -> Unit)`, som visar att ett fel söknings logg meddelande inte kan observeras inifrån Q #.</span><span class="sxs-lookup"><span data-stu-id="93a7c-111">`Message` has signature `(String -> Unit)`, again representing that emitting a debug log message cannot be observed from within Q#.</span></span>

<span data-ttu-id="93a7c-112"><xref:microsoft.quantum.diagnostics.dumpmachine>-och <xref:microsoft.quantum.diagnostics.dumpregister>-callables instruerar mål datorerna att tillhandahålla diagnostikinformation om alla aktuella allokerade qubits eller om ett särskilt register över qubits.</span><span class="sxs-lookup"><span data-stu-id="93a7c-112">The <xref:microsoft.quantum.diagnostics.dumpmachine> and <xref:microsoft.quantum.diagnostics.dumpregister> callables instruct target machines to provide diagnostic information about all currently allocated qubits or about a specific register of qubits, respectively.</span></span>
<span data-ttu-id="93a7c-113">Varje måldator varierar i vilken diagnostikinformation som anges som svar på en dump-instruktion.</span><span class="sxs-lookup"><span data-stu-id="93a7c-113">Each target machine varies in what diagnostic information is provided in response to a dump instruction.</span></span>
<span data-ttu-id="93a7c-114">Den fullständiga mål datorn för [tillstånds simulatorn](xref:microsoft.quantum.machines.full-state-simulator) tillhandahåller till exempel värd programmet med den tillstånds vektor som används internt för att representera ett register över qubits.</span><span class="sxs-lookup"><span data-stu-id="93a7c-114">The [full state simulator](xref:microsoft.quantum.machines.full-state-simulator) target machine, for instance, provides the host program with the state vector that it uses internally to represent a register of qubits.</span></span>
<span data-ttu-id="93a7c-115">Som jämförelse ger [Toffoli Simulator](xref:microsoft.quantum.machines.toffoli-simulator) -mål datorn en enkel klassiskt bit för varje qubit.</span><span class="sxs-lookup"><span data-stu-id="93a7c-115">By comparison, the [Toffoli simulator](xref:microsoft.quantum.machines.toffoli-simulator) target machine provides a single classical bit for each qubit.</span></span>

 <span data-ttu-id="93a7c-116">Om du vill veta mer om [full State simulators](xref:microsoft.quantum.machines.full-state-simulator) `DumpMachine` utdata tar du en titt på avsnittet dumpa funktioner i [artikeln test och fel sökning](xref:microsoft.quantum.techniques.testing-and-debugging#dump-functions).</span><span class="sxs-lookup"><span data-stu-id="93a7c-116">To learn more about the [full state simulator's](xref:microsoft.quantum.machines.full-state-simulator) `DumpMachine` output, take a look at the dump functions section of our [testing and debugging article](xref:microsoft.quantum.techniques.testing-and-debugging#dump-functions).</span></span>


## <a name="facts-and-assertions"></a><span data-ttu-id="93a7c-117">Fakta och intyg</span><span class="sxs-lookup"><span data-stu-id="93a7c-117">Facts and Assertions</span></span> ##

<span data-ttu-id="93a7c-118">Som du ser i [testa och felsöka](xref:microsoft.quantum.techniques.testing-and-debugging), kan en funktion eller åtgärd med signaturen `Unit -> Unit` respektive `Unit => Unit`markeras som ett *enhets test*.</span><span class="sxs-lookup"><span data-stu-id="93a7c-118">As discussed in [Testing and Debugging](xref:microsoft.quantum.techniques.testing-and-debugging), a function or operation with signature `Unit -> Unit` or `Unit => Unit`, respectively, can be marked as a *unit test*.</span></span>
<span data-ttu-id="93a7c-119">Varje enhets test består vanligt vis av ett litet Quantum-program, tillsammans med ett eller flera villkor som kontrollerar att programmet är korrekt.</span><span class="sxs-lookup"><span data-stu-id="93a7c-119">Each unit test generally consists of a small quantum program, along with one or more conditions that check the correctness of that program.</span></span>
<span data-ttu-id="93a7c-120">Dessa villkor kan komma i form av antingen _fakta_, som kontrollerar värdena för deras indata, eller _intyg_, som kontrollerar tillstånden för en eller flera qubits som skickas som indata.</span><span class="sxs-lookup"><span data-stu-id="93a7c-120">These conditions can come in the form of either _facts_, which check the values of their inputs, or _assertions_, which check the states of one or more qubits passed as input.</span></span>

<span data-ttu-id="93a7c-121">`EqualityFactI(1 + 1, 2, "1 + 1 != 2")` representerar till exempel det matematiska faktum att $1 + 1 = $2, medan `AssertQubit(One, qubit)` representerar villkoret som mäter `qubit` returnerar en `One` med säkerhet.</span><span class="sxs-lookup"><span data-stu-id="93a7c-121">For example, `EqualityFactI(1 + 1, 2, "1 + 1 != 2")` represents the mathematical fact that $1 + 1 = 2$, while `AssertQubit(One, qubit)` represents the condition that measuring `qubit` will return a `One` with certainty.</span></span>
<span data-ttu-id="93a7c-122">I det förra fallet kan vi kontrol lera att villkoret är korrekt, men i det senare måste vi känna till något om status för qubit för att utvärdera försäkran.</span><span class="sxs-lookup"><span data-stu-id="93a7c-122">In the former case, we can check the correctness of the condition given only its values, while in the latter, we must know something about the state of the qubit in order to evaluate the assertion.</span></span>

<span data-ttu-id="93a7c-123">Standard biblioteken för Q # innehåller flera olika funktioner för att representera fakta, inklusive:</span><span class="sxs-lookup"><span data-stu-id="93a7c-123">The Q# standard libraries provide several different functions for representing facts, including:</span></span>

- <xref:microsoft.quantum.diagnostics.fact>
- <xref:microsoft.quantum.diagnostics.equalitywithintolerancefact>
- <xref:microsoft.quantum.diagnostics.nearequalityfactc>
- <xref:microsoft.quantum.diagnostics.equalityfacti>


### <a name="testing-qubit-states"></a><span data-ttu-id="93a7c-124">Testa qubit-tillstånd</span><span class="sxs-lookup"><span data-stu-id="93a7c-124">Testing Qubit States</span></span> ###

<span data-ttu-id="93a7c-125">I praktiken förlitar sig på att de klassiska simuleringarna av Quantum Mechanics inte behöver följa [no-klonings-satsen](https://arxiv.org/abs/quant-ph/9607018), så att vi kan göra icke-fysiska mätningar och intyg när de använder en simulator för vår mål dator.</span><span class="sxs-lookup"><span data-stu-id="93a7c-125">In practice, assertions rely on the fact that classical simulations of quantum mechanics need not obey the [no-cloning theorem](https://arxiv.org/abs/quant-ph/9607018), such that we can make unphysical measurements and assertions when using a simulator for our target machine.</span></span>
<span data-ttu-id="93a7c-126">Därför kan vi testa enskilda åtgärder på en klassisk Simulator innan du distribuerar på maskin vara.</span><span class="sxs-lookup"><span data-stu-id="93a7c-126">Thus, we can test individual operations on a classical simulator before deploying on hardware.</span></span>
<span data-ttu-id="93a7c-127">På mål datorer som inte tillåter utvärdering av intyg kan anrop till <xref:microsoft.quantum.intrinsic.assert> ignoreras på ett säkert sätt.</span><span class="sxs-lookup"><span data-stu-id="93a7c-127">On target machines which do not allow evaluation of assertions, calls to <xref:microsoft.quantum.intrinsic.assert> can be safely ignored.</span></span>

<span data-ttu-id="93a7c-128">Mer allmänt sett är <xref:microsoft.quantum.intrinsic.assert> åtgärden som mäter att de tilldelade qubits i den aktuella Pauli-basen alltid har det aktuella resultatet.</span><span class="sxs-lookup"><span data-stu-id="93a7c-128">More generally, the <xref:microsoft.quantum.intrinsic.assert> operation asserts that measuring the given qubits in the given Pauli basis will always have the given result.</span></span>
<span data-ttu-id="93a7c-129">Om kontrollen Miss lyckas avslutas körningen genom att anropa `fail` med det aktuella meddelandet.</span><span class="sxs-lookup"><span data-stu-id="93a7c-129">If the assertion fails, the execution ends by calling `fail` with the given message.</span></span>
<span data-ttu-id="93a7c-130">Den här åtgärden är inte implementerad som standard. simulatorer som har stöd för den bör tillhandahålla en implementering som utför körnings kontroll.</span><span class="sxs-lookup"><span data-stu-id="93a7c-130">By default, this operation is not implemented; simulators that can support it should provide an implementation that performs runtime checking.</span></span>
<span data-ttu-id="93a7c-131">`Assert` har signatur `((Pauli[], Qubit[], Result, String) -> ())`.</span><span class="sxs-lookup"><span data-stu-id="93a7c-131">`Assert` has signature `((Pauli[], Qubit[], Result, String) -> ())`.</span></span>
<span data-ttu-id="93a7c-132">Eftersom `Assert` är en funktion med en tom tupel som Utdatatyp, kan inga effekter från att ha anropade `Assert` vara synliga i ett Q #-program.</span><span class="sxs-lookup"><span data-stu-id="93a7c-132">Since `Assert` is a function with an empty tuple as its output type, no effects from having called `Assert` are observable within a Q# program.</span></span>

<span data-ttu-id="93a7c-133">Funktionen <xref:microsoft.quantum.intrinsic.assertprob> funktion förutsätter att mätning av de tilldelade qubits i den aktuella Pauli-grunden har det resultat som har givit den sannolikheten, inom viss tolerans.</span><span class="sxs-lookup"><span data-stu-id="93a7c-133">The <xref:microsoft.quantum.intrinsic.assertprob> operation function asserts that measuring the given qubits in the given Pauli basis will have the given result with the given probability, within some tolerance.</span></span>
<span data-ttu-id="93a7c-134">Toleransen är additiv (t. ex. `abs(expected-actual) < tol`).</span><span class="sxs-lookup"><span data-stu-id="93a7c-134">Tolerance is additive (e.g. `abs(expected-actual) < tol`).</span></span>
<span data-ttu-id="93a7c-135">Om kontrollen Miss lyckas avslutas körningen genom att anropa `fail` med det aktuella meddelandet.</span><span class="sxs-lookup"><span data-stu-id="93a7c-135">If the assertion fails, the execution ends by calling `fail` with the given message.</span></span>
<span data-ttu-id="93a7c-136">Den här åtgärden är inte implementerad som standard. simulatorer som har stöd för den bör tillhandahålla en implementering som utför körnings kontroll.</span><span class="sxs-lookup"><span data-stu-id="93a7c-136">By default, this operation is not implemented; simulators that can support it should provide an implementation that performs runtime checking.</span></span>
<span data-ttu-id="93a7c-137">`AssertProb` har signatur `((Pauli[], Qubit[], Result, Double, String, Double) -> Unit)`.</span><span class="sxs-lookup"><span data-stu-id="93a7c-137">`AssertProb` has signature `((Pauli[], Qubit[], Result, Double, String, Double) -> Unit)`.</span></span> <span data-ttu-id="93a7c-138">Den första av `Double` parametrar ger den önskade sannolikheten för resultatet och den andra som toleransen.</span><span class="sxs-lookup"><span data-stu-id="93a7c-138">The first of `Double` parameters gives the desired probability of the result, and the second one the tolerance.</span></span>

<span data-ttu-id="93a7c-139">Vi kan göra mer än att kontrol lera en enda mätning, med hjälp av att den klassiska information som används av en simulator för att representera det interna läget för en qubit är lämpar att kopiera, så att vi inte behöver utföra någon mätning för att testa vår kontroll.</span><span class="sxs-lookup"><span data-stu-id="93a7c-139">We can do more than assert a single measurement, using that the classical information used by a simulator to represent the internal state of a qubit is amenable to copying, such that we do not need to actually perform a measurement to test our assertion.</span></span>
<span data-ttu-id="93a7c-140">I synnerhet gör detta att vi kan ta del av *inkompatibla* mått som skulle vara omöjliga vid den faktiska maskin varan.</span><span class="sxs-lookup"><span data-stu-id="93a7c-140">In particular, this allows us to reason about *incompatible* measurements that would be impossible on actual hardware.</span></span>

<span data-ttu-id="93a7c-141">Anta att `P : Qubit => Unit` är en åtgärd som är avsedd att förbereda status $ \ket{\psi} $ när indatamängden är i läget $ \ket{0}$.</span><span class="sxs-lookup"><span data-stu-id="93a7c-141">Suppose that `P : Qubit => Unit` is an operation intended to prepare the state $\ket{\psi}$ when its input is in the state $\ket{0}$.</span></span>
<span data-ttu-id="93a7c-142">Låt $ \ket{\psi '} $ vara det faktiska tillstånd som förberetts av `P`.</span><span class="sxs-lookup"><span data-stu-id="93a7c-142">Let $\ket{\psi'}$ be the actual state prepared by `P`.</span></span>
<span data-ttu-id="93a7c-143">Sedan returnerar $ \ket{\psi} = \ket{\psi '} $ om och endast om mätningen $ \ket{\psi '} $ i axeln som beskrivs av $ \ket{\psi} $ alltid returnerar `Zero`.</span><span class="sxs-lookup"><span data-stu-id="93a7c-143">Then, $\ket{\psi} = \ket{\psi'}$ if and only if measuring $\ket{\psi'}$ in the axis described by $\ket{\psi}$ always returns `Zero`.</span></span>
<span data-ttu-id="93a7c-144">Det vill säga \begin{align} \ket{\psi} = \ket{\psi '} \text{om och bara om} \braket{\psi | \psi '} = 1.</span><span class="sxs-lookup"><span data-stu-id="93a7c-144">That is, \begin{align} \ket{\psi} = \ket{\psi'} \text{ if and only if } \braket{\psi | \psi'} = 1.</span></span>
<span data-ttu-id="93a7c-145">\end{align} med de primitiva åtgärder som definierats i inledning kan vi direkt utföra en mätning som returnerar `Zero` om $ \ket{\psi} $ är en eigenstate av en av Pauli-operatörerna.</span><span class="sxs-lookup"><span data-stu-id="93a7c-145">\end{align} Using the primitive operations defined in the prelude, we can directly perform a measurement that returns `Zero` if $\ket{\psi}$ is an eigenstate of one of the Pauli operators.</span></span>


<span data-ttu-id="93a7c-146">Åtgärden <xref:microsoft.quantum.diagnostics.assertqubit> ger en särskilt praktisk stenografisk funktion i det fall då vi vill testa undersökningen $ \ket{\psi} = \ket{0}$.</span><span class="sxs-lookup"><span data-stu-id="93a7c-146">The operation <xref:microsoft.quantum.diagnostics.assertqubit> provides a particularly useful shorthand to do so in the case that we wish to test the assertion $\ket{\psi} = \ket{0}$.</span></span>
<span data-ttu-id="93a7c-147">Detta är vanligt, till exempel när vi har gjort en uncompute för att returnera Ancilla qubits till $ \ket{0}$ innan de släpps.</span><span class="sxs-lookup"><span data-stu-id="93a7c-147">This is common, for instance, when we have uncomputed to return ancilla qubits to $\ket{0}$ before releasing them.</span></span>
<span data-ttu-id="93a7c-148">Att kontrollera mot $ \ket{0}$ är också användbart när vi vill att två tillstånds förberedelser `P` och `Q` åtgärder ska kunna förbereda samma tillstånd, och när `Q` stöder `Adjoint`.</span><span class="sxs-lookup"><span data-stu-id="93a7c-148">Asserting against $\ket{0}$ is also useful when we wish to assert that two state preparation `P` and `Q` operations both prepare the same state, and when `Q` supports `Adjoint`.</span></span>
<span data-ttu-id="93a7c-149">Särskilt,</span><span class="sxs-lookup"><span data-stu-id="93a7c-149">In particular,</span></span>

```qsharp
using (register = Qubit()) {
    P(register);
    Adjoint Q(register);

    AssertQubit(Zero, register);
}
```

<span data-ttu-id="93a7c-150">I allmänhet är det dock inte säkert att vi har åtkomst till intyg om tillstånd som inte sammanfaller med eigenstates av Pauli-operatörer.</span><span class="sxs-lookup"><span data-stu-id="93a7c-150">More generally, however, we may not have access to assertions about states that do not coincide with eigenstates of Pauli operators.</span></span>
<span data-ttu-id="93a7c-151">Till exempel, $ \ket{\psi} = (\ket{0} + e ^ {i \pi/8} \ket{1})/\sqrt{2}$ är inte en eigenstate av någon Pauli-Operator, så att vi inte kan använda <xref:microsoft.quantum.intrinsic.assertprob> för att unikt fastställa att ett tillstånd $ \ket{\psi '} $ är lika med $ \ket{\psi} $.</span><span class="sxs-lookup"><span data-stu-id="93a7c-151">For example, $\ket{\psi} = (\ket{0} + e^{i \pi / 8} \ket{1}) / \sqrt{2}$ is not an eigenstate of any Pauli operator, such that we cannot use <xref:microsoft.quantum.intrinsic.assertprob> to uniquely determine that a state $\ket{\psi'}$ is equal to $\ket{\psi}$.</span></span>
<span data-ttu-id="93a7c-152">I stället måste du dela upp intyget $ \ket{\psi '} = \ket{\psi} $ i antaganden som kan testas direkt med hjälp av de primitiver som stöds av vår Simulator.</span><span class="sxs-lookup"><span data-stu-id="93a7c-152">Instead, we must decompose the assertion $\ket{\psi'} = \ket{\psi}$ into assumptions that can be directly tested using  the primitives supported by our simulator.</span></span>
<span data-ttu-id="93a7c-153">Det gör du genom att låta $ \ket{\psi} = \alpha \ket{0} + \beta \ket{1}$ för komplexa tal $ \alpha = a\_r + a\_i $ och $ \beta $.</span><span class="sxs-lookup"><span data-stu-id="93a7c-153">To do so, let $\ket{\psi} = \alpha \ket{0} + \beta \ket{1}$ for complex numbers $\alpha = a\_r + a\_i i$ and $\beta$.</span></span>
<span data-ttu-id="93a7c-154">Observera att det här uttrycket kräver fyra reella tal $\{ett\_r, en\_i, b\_r, b\_i\}$ för att ange, eftersom varje komplext tal kan uttryckas som summan av en verklig och en imaginär del.</span><span class="sxs-lookup"><span data-stu-id="93a7c-154">Note that this expression requires four real numbers $\{a\_r, a\_i, b\_r, b\_i\}$ to specify, as each complex number can be expressed as the sum of a real and imaginary part.</span></span>
<span data-ttu-id="93a7c-155">På grund av den globala fasen kan vi dock välja $a\_i = $0, så att vi bara behöver tre reella siffror för att unikt ange ett qubit tillstånd.</span><span class="sxs-lookup"><span data-stu-id="93a7c-155">Due to the global phase, however, we can choose $a\_i = 0$, such that we only need three real numbers to uniquely specify a single-qubit state.</span></span>

<span data-ttu-id="93a7c-156">Därför måste vi ange tre intyg som är oberoende av varandra för att fastställa det tillstånd som vi förväntar sig.</span><span class="sxs-lookup"><span data-stu-id="93a7c-156">Thus, we need to specify three assertions which are independent of each other in order to assert the state that we expect.</span></span>
<span data-ttu-id="93a7c-157">Vi gör detta genom att ta reda på sannolikheten för att observera `Zero` för varje Pauli-mätning, som har getts $ \alpha $ och $ \beta $, och som garanterar var och en oberoende.</span><span class="sxs-lookup"><span data-stu-id="93a7c-157">We do so by finding the probability of observing `Zero` for each Pauli measurement given $\alpha$ and $\beta$, and asserting each independently.</span></span>
<span data-ttu-id="93a7c-158">Låt $x $, $y $ och $z $ vara `Result` värden för Pauli $X $, $Y $ och $Z $.</span><span class="sxs-lookup"><span data-stu-id="93a7c-158">Let $x$, $y$, and $z$ be `Result` values for Pauli $X$, $Y$, and $Z$ measurements respectively.</span></span>
<span data-ttu-id="93a7c-159">Sedan använder du funktionen sannolikhet för Quantum-mätningar, \begin{align} \Pr (x = \texttt{Zero} | \alpha, \beta) & = \frac12 + a\_r b\_r + a\_i b\_\\\\ \Pr (y = \texttt{Zero} | \alpha, \beta) & = \frac12 + a\_r b\_i-a\_i b\_r \\\\ \Pr (z = \texttt{Zero} | \alpha, \beta) & = \frac12\left (1 + a\_r ^ 2 + a\_i ^ 2 + b\_r ^ 2 + b\_i ^ 2 \right).</span><span class="sxs-lookup"><span data-stu-id="93a7c-159">Then, using the likelihood function for quantum measurements, \begin{align} \Pr(x = \texttt{Zero} | \alpha, \beta) & = \frac12 + a\_r b\_r + a\_i b\_i \\\\ \Pr(y = \texttt{Zero} | \alpha, \beta) & = \frac12 + a\_r b\_i - a\_i b\_r \\\\ \Pr(z = \texttt{Zero} | \alpha, \beta) & = \frac12\left( 1 + a\_r^2 + a\_i^2 + b\_r^2 + b\_i^2 \right).</span></span>
<span data-ttu-id="93a7c-160">\end{align}</span><span class="sxs-lookup"><span data-stu-id="93a7c-160">\end{align}</span></span>

<span data-ttu-id="93a7c-161">Åtgärden <xref:microsoft.quantum.diagnostics.assertqubitisinstatewithintolerance> implementerar de här försäkrarna om $ \alpha $ och $ \beta $ som värden av typen <xref:microsoft.quantum.math.complex>.</span><span class="sxs-lookup"><span data-stu-id="93a7c-161">The <xref:microsoft.quantum.diagnostics.assertqubitisinstatewithintolerance> operation implements these assertions given representations of $\alpha$ and $\beta$ as values of type <xref:microsoft.quantum.math.complex>.</span></span>
<span data-ttu-id="93a7c-162">Detta är användbart när det förväntade läget kan beräknas matematiskt.</span><span class="sxs-lookup"><span data-stu-id="93a7c-162">This is helpful when the expected state can be computed mathematically.</span></span>

### <a name="asserting-equality-of-quantum-operations"></a><span data-ttu-id="93a7c-163">Kontroll av jämställdhet mellan Quantum-åtgärder</span><span class="sxs-lookup"><span data-stu-id="93a7c-163">Asserting Equality of Quantum Operations</span></span> ###

<span data-ttu-id="93a7c-164">Hittills har vi varit intresserade av test åtgärder som är avsedda att förbereda särskilda tillstånd.</span><span class="sxs-lookup"><span data-stu-id="93a7c-164">Thus far, we have been concerned with testing operations which are intended to prepare particular states.</span></span>
<span data-ttu-id="93a7c-165">Vi är ofta intresserade av hur en åtgärd fungerar för godtyckliga indata i stället för en enda fast inmatning.</span><span class="sxs-lookup"><span data-stu-id="93a7c-165">Often, however, we are interested in how an operation acts for arbitrary inputs rather than for a single fixed input.</span></span>
<span data-ttu-id="93a7c-166">Anta till exempel att vi har implementerat en åtgärd `U : ((Double, Qubit[]) => () : Adjoint)` som motsvarar en familj med enhetliga operatörer $U (t) $, och har angett ett explicit `adjoint` block i stället för att använda `adjoint auto`.</span><span class="sxs-lookup"><span data-stu-id="93a7c-166">For example, suppose we have implemented an operation `U : ((Double, Qubit[]) => () : Adjoint)` corresponding to a family of unitary operators $U(t)$, and have provided an explicit `adjoint` block instead of using `adjoint auto`.</span></span>
<span data-ttu-id="93a7c-167">Vi kan vara intresserade av att förutsätta att $U ^ \dagger (t) = U (-t) $, som förväntat om $t $ representerar en utvecklings tid.</span><span class="sxs-lookup"><span data-stu-id="93a7c-167">We may be interested in asserting that $U^\dagger(t) = U(-t)$, as expected if $t$ represents an evolution time.</span></span>

<span data-ttu-id="93a7c-168">Det finns i stort sett två olika strategier som vi kan följa för att göra den försäkran att två åtgärder `U` och `V` fungerar identiskt.</span><span class="sxs-lookup"><span data-stu-id="93a7c-168">Broadly speaking, there are two different strategies that we can follow in making the assertion that two operations `U` and `V` act identically.</span></span>
<span data-ttu-id="93a7c-169">Först kan vi kontrol lera att `U(target); (Adjoint V)(target);` bevarar varje tillstånd med en specifik grund.</span><span class="sxs-lookup"><span data-stu-id="93a7c-169">First, we can check that `U(target); (Adjoint V)(target);` preserves each state in a given basis.</span></span>
<span data-ttu-id="93a7c-170">För det andra kan vi kontrol lera att `U(target); (Adjoint V)(target);` som agerar på hälften av ett Entangled-tillstånd bevarar entanglement.</span><span class="sxs-lookup"><span data-stu-id="93a7c-170">Second, we can check that `U(target); (Adjoint V)(target);` acting on half of an entangled state preserves that entanglement.</span></span>
<span data-ttu-id="93a7c-171">Dessa strategier implementeras av Canon-åtgärderna <xref:microsoft.quantum.diagnostics.assertoperationsequalinplace> respektive <xref:microsoft.quantum.diagnostics.assertoperationsequalreferenced>.</span><span class="sxs-lookup"><span data-stu-id="93a7c-171">These strategies are implemented by the canon operations <xref:microsoft.quantum.diagnostics.assertoperationsequalinplace> and <xref:microsoft.quantum.diagnostics.assertoperationsequalreferenced>, respectively.</span></span>

> [!NOTE]
> <span data-ttu-id="93a7c-172">Den refererade kontrollen som diskuteras ovan fungerar baserat på [Choi – Jamiłkowski isomorphism](https://en.wikipedia.org/wiki/Channel-state_duality), ett matematiskt ramverk som relaterar åtgärder på $n $ qubits till Entangled-tillstånd på $2n $ qubits.</span><span class="sxs-lookup"><span data-stu-id="93a7c-172">The referenced assertion discussed above works based on the [Choi–Jamiłkowski isomorphism](https://en.wikipedia.org/wiki/Channel-state_duality), a mathematical framework which relates operations on $n$ qubits to entangled states on $2n$ qubits.</span></span>
> <span data-ttu-id="93a7c-173">I synnerhet representeras identitets åtgärden på $n $ qubits av $n $-kopior av Entangled-tillstånd $ \ket{\ beta_{00}} \mathrel{: =} (\ket{00} + \ket{11})/\sqrt{2}$.</span><span class="sxs-lookup"><span data-stu-id="93a7c-173">In particular, the identity operation on $n$ qubits is represented by $n$ copies of the entangled state $\ket{\beta_{00}} \mathrel{:=} (\ket{00} + \ket{11}) / \sqrt{2}$.</span></span>
> <span data-ttu-id="93a7c-174">Åtgärden <xref:microsoft.quantum.preparation.preparechoistate> implementerar den här isomorphism och förbereder ett tillstånd som representerar en specifik åtgärd.</span><span class="sxs-lookup"><span data-stu-id="93a7c-174">The operation <xref:microsoft.quantum.preparation.preparechoistate> implements this isomorphism, preparing a state that represents a given operation.</span></span>

<span data-ttu-id="93a7c-175">Den här typen av strategier särskiljs ungefär i en tid – utrymmes kompromisser.</span><span class="sxs-lookup"><span data-stu-id="93a7c-175">Roughly, these strategies are distinguished by a time–space tradeoff.</span></span>
<span data-ttu-id="93a7c-176">Att gå igenom varje ingångs tillstånd tar ytterligare tid, medan du använder entanglement som referens kräver att du lagrar ytterligare qubits.</span><span class="sxs-lookup"><span data-stu-id="93a7c-176">Iterating through each input state takes additional time, while using entanglement as a reference requires storing additional qubits.</span></span>
<span data-ttu-id="93a7c-177">I de fall där en åtgärd implementerar en klassisk klassisk åtgärd, så att vi bara är intresse rad av dess beteende i beräknings bas staterna, <xref:microsoft.quantum.diagnostics.assertoperationsequalinplacecompbasis> testerna är likvärdiga med denna begränsade uppsättning indata.</span><span class="sxs-lookup"><span data-stu-id="93a7c-177">In cases where an operation implements a reversible classical operation, such that we are only interested in its behavior on computational basis states, <xref:microsoft.quantum.diagnostics.assertoperationsequalinplacecompbasis> tests equality on this restricted set of inputs.</span></span>

> [!TIP]
> <span data-ttu-id="93a7c-178">Iterationen över indatamängds tillstånd hanteras av uppräknings åtgärder <xref:microsoft.quantum.canon.iteratethroughcartesianproduct> och <xref:microsoft.quantum.canon.iteratethroughcartesianpower>.</span><span class="sxs-lookup"><span data-stu-id="93a7c-178">The iteration over input states is handled by the enumeration operations <xref:microsoft.quantum.canon.iteratethroughcartesianproduct> and <xref:microsoft.quantum.canon.iteratethroughcartesianpower>.</span></span>
> <span data-ttu-id="93a7c-179">Dessa åtgärder är användbara för att tillämpa en åtgärd för varje element i kartesiska-produkten mellan två eller flera uppsättningar.</span><span class="sxs-lookup"><span data-stu-id="93a7c-179">These operations are useful more generally for applying an operation to each element of the Cartesian product between two or more sets.</span></span>

<span data-ttu-id="93a7c-180">Det är dock viktigt att de två metoderna testar olika egenskaper för de åtgärder som utförs under undersökning.</span><span class="sxs-lookup"><span data-stu-id="93a7c-180">More critically, however, the two approaches test different properties of the operations under examination.</span></span>
<span data-ttu-id="93a7c-181">Eftersom den på plats-kontrollen anropar varje åtgärd flera gånger, en gång för varje ingångs tillstånd, kan eventuella slumpmässiga val och mått resultat ändras mellan anrop.</span><span class="sxs-lookup"><span data-stu-id="93a7c-181">Since the in-place assertion calls each operation multiple times, once for each input state, any random choices and measurement results might change between calls.</span></span>
<span data-ttu-id="93a7c-182">Den refererade kontrollen anropar däremot varje åtgärd exakt en gång, så att den kontrollerar att åtgärderna är lika *i en enda bild*.</span><span class="sxs-lookup"><span data-stu-id="93a7c-182">By contrast, the referenced assertion calls each operation exactly once, such that it checks that the operations are equal *in a single shot*.</span></span>
<span data-ttu-id="93a7c-183">Båda dessa tester är användbara för att säkerställa att Quantum program är korrekta.</span><span class="sxs-lookup"><span data-stu-id="93a7c-183">Both of these tests are useful in ensuring the correctness of quantum programs.</span></span>


## <a name="further-reading"></a><span data-ttu-id="93a7c-184">Mer läsning</span><span class="sxs-lookup"><span data-stu-id="93a7c-184">Further Reading</span></span> ##

- <xref:microsoft.quantum.techniques.testing-and-debugging>
- <xref:microsoft.quantum.diagnostics>
