---
title: Quantum-karakterisering och statistik
description: Lär dig hur mätnings statistik från fas uppskattningar används för att beräkna resultat värden i Quantum-programmering.
author: QuantumWriter
uid: microsoft.quantum.libraries.characterization
ms.author: martinro@microsoft.com
ms.date: 12/11/2017
ms.topic: article
ms.openlocfilehash: 7ed92c29020ccf389faa099f5bd80516af525578
ms.sourcegitcommit: 6ccea4a2006a47569c4e2c2cb37001e132f17476
ms.translationtype: MT
ms.contentlocale: sv-SE
ms.lasthandoff: 02/28/2020
ms.locfileid: "77907196"
---
# <a name="quantum-characterization-and-statistics"></a><span data-ttu-id="ca47e-103">Quantum-karakterisering och statistik</span><span class="sxs-lookup"><span data-stu-id="ca47e-103">Quantum Characterization and Statistics</span></span> #

<span data-ttu-id="ca47e-104">Det är viktigt att kunna karakterisera effekterna av åtgärder för att utveckla användbara Quantum-algoritmer.</span><span class="sxs-lookup"><span data-stu-id="ca47e-104">It is critical to be able to characterize the effects of operations in order to develop useful quantum algorithms.</span></span>
<span data-ttu-id="ca47e-105">Detta är en utmaning eftersom varje mätning av ett Quantum-system ger högst en information.</span><span class="sxs-lookup"><span data-stu-id="ca47e-105">This is challenging because every measurement of a quantum system yields at most one bit of information.</span></span>
<span data-ttu-id="ca47e-106">För att kunna lära sig en eigenvalue, så att det blir ett Quantum-tillstånd, måste resultatet av många mätningar sammanföras tillsammans så att användaren kan få de många bitar av information som krävs för att representera dessa begrepp.</span><span class="sxs-lookup"><span data-stu-id="ca47e-106">In order to learn an eigenvalue, let alone a quantum state, the results of many measurements must be stitched together so that the user can glean the many bits of information needed to represent these concepts.</span></span>
<span data-ttu-id="ca47e-107">Quantum State är särskilt vexing eftersom [no-kloningsing satsen](xref:microsoft.quantum.concepts.pauli#the-no-cloning-theorem) säger att det inte finns något sätt att lära sig ett godtyckligt Quantum-tillstånd från en enda kopia av tillståndet, eftersom det gör att du kan göra kopior av tillståndet.</span><span class="sxs-lookup"><span data-stu-id="ca47e-107">Quantum states are especially vexing because the [no-cloning theorem](xref:microsoft.quantum.concepts.pauli#the-no-cloning-theorem) states that there is no way to learn an arbitrary quantum state from a single copy of the state, because doing so would let you make copies of the state.</span></span>
<span data-ttu-id="ca47e-108">Den här döljande av Quantum-tillstånd från användaren återspeglas i det faktum att Q # inte visar eller ens definierar vad ett tillstånd *är* till Quantum-program.</span><span class="sxs-lookup"><span data-stu-id="ca47e-108">This obfuscation of the quantum state from the user is reflected in the fact that Q# does not expose or even define what a state *is* to quantum programs.</span></span>
<span data-ttu-id="ca47e-109">Vi närmar sig en Quantum-karakterisering genom att behandla drift och tillstånd som svart ruta. den här metoden delar mycket gemensamt med experiment metoden för Quantum-karakterisering, verifiering och validering (QCVV).</span><span class="sxs-lookup"><span data-stu-id="ca47e-109">We thus approach quantum characterization by treating operations and states as black-box; this approach shares much in common with the experimental practice of quantum characterization, verification and validation (QCVV).</span></span>

<span data-ttu-id="ca47e-110">Karakteriseringen skiljer sig från många av de andra bibliotek som beskrivits tidigare.</span><span class="sxs-lookup"><span data-stu-id="ca47e-110">Characterization is distinct from many of the other libraries discussed previously.</span></span>
<span data-ttu-id="ca47e-111">Målet här är mindre för att lära sig att lära sig klassisk information om systemet, i stället för att utföra en enhetlig omvandling i en tillstånds vektor.</span><span class="sxs-lookup"><span data-stu-id="ca47e-111">The aim here is less to learn classical information about the system, rather than to perform a unitary transformation on a state vector.</span></span>
<span data-ttu-id="ca47e-112">Dessa bibliotek måste därför blanda både klassisk och Quantum informations bearbetning.</span><span class="sxs-lookup"><span data-stu-id="ca47e-112">These libraries must therefore blend both classical and quantum information processing.</span></span>


## <a name="iterative-phase-estimation"></a><span data-ttu-id="ca47e-113">Uppskattning av iterativ fas</span><span class="sxs-lookup"><span data-stu-id="ca47e-113">Iterative Phase Estimation</span></span> ##

<span data-ttu-id="ca47e-114">Om du visar Quantum-programmering i termer av Quantum-karakterisering föreslås ett användbart alternativ för uppskattning av Quantum-fasen.</span><span class="sxs-lookup"><span data-stu-id="ca47e-114">Viewing quantum programming in terms of quantum characterization suggests a useful alternative to quantum phase estimation.</span></span>
<span data-ttu-id="ca47e-115">I stället för att förbereda en $n $-qubit-register för att innehålla en binär representation av fasen som i en uppskattning av Quantum-fasen, kan vi Visa fas uppskattning som den process genom vilken en *klassisk* agent lär sig egenskaper för ett Quantum-system genom mätningar.</span><span class="sxs-lookup"><span data-stu-id="ca47e-115">That is, instead of preparing an $n$-qubit register to contain a binary representation of the phase as in quantum phase estimation, we can view phase estimation as the process by which a *classical* agent learns properties of a quantum system through measurements.</span></span>
<span data-ttu-id="ca47e-116">Vi fortsätter som i Quantum-fallet genom att använda fas Kickback för att aktivera program med en svart Box-åtgärd till rotationer med en okänd vinkel, men kommer att mäta Ancilla-qubit som vi roterar i varje steg direkt efter rotationen.</span><span class="sxs-lookup"><span data-stu-id="ca47e-116">We proceed as in the quantum case by using phase kickback to turn applications of a black-box operation into rotations by an unknown angle, but will measure the ancilla qubit that we rotate at each step immediately following the rotation.</span></span>
<span data-ttu-id="ca47e-117">Detta har fördelen att vi bara behöver en enda ytterligare qubit för att utföra fasen Kickback som beskrivs i Quantum-fallet, eftersom vi sedan lär dig fasen från Mät resultaten vid varje steg på ett iterativt sätt.</span><span class="sxs-lookup"><span data-stu-id="ca47e-117">This has the advantage that we only require a single additional qubit to perform the phase kickback described in the quantum case, as we then learn the phase from the measurement results at each step in an iterative fashion.</span></span>  
<span data-ttu-id="ca47e-118">Var och en av de metoder som föreslås nedan använder en annan strategi för att utforma experiment och olika data bearbetnings metoder för att lära dig fasen.</span><span class="sxs-lookup"><span data-stu-id="ca47e-118">Each of the methods proposed below uses a different strategy for designing experiments and different data processing methods to learn the phase.</span></span>  <span data-ttu-id="ca47e-119">De har en unik fördel som sträcker sig från att ha rigorösa fel gränser, till förmåga att ta med tidigare information, tolerera fel eller köra på minnes limitted klassiska datorer.</span><span class="sxs-lookup"><span data-stu-id="ca47e-119">They each have unique advantage ranging from having rigorous error bounds, to the abilities to incorporate prior information, tolerate errors or run on memory limitted classical computers.</span></span>

<span data-ttu-id="ca47e-120">I att diskutera iterativa fas uppskattningar kommer vi att betrakta en enhetlig $U $ som en svart Box-åtgärd.</span><span class="sxs-lookup"><span data-stu-id="ca47e-120">In discussing iterative phase estimation, we will consider a unitary $U$ given as a black-box operation.</span></span>
<span data-ttu-id="ca47e-121">Som det beskrivs i avsnittet om Oracle i [data strukturer](xref:microsoft.quantum.libraries.data-structures), kommer Q # Canon att modellera sådana åtgärder med <xref:microsoft.quantum.oracles.discreteoracle> användardefinierad typ, som definieras av tuple-typen `((Int, Qubit[]) => Unit : Adjoint, Controlled)`.</span><span class="sxs-lookup"><span data-stu-id="ca47e-121">As described in the section on oracles in [data structures](xref:microsoft.quantum.libraries.data-structures), the Q# canon models such operations by the <xref:microsoft.quantum.oracles.discreteoracle> user-defined type, defined by the tuple type `((Int, Qubit[]) => Unit : Adjoint, Controlled)`.</span></span>
<span data-ttu-id="ca47e-122">Konkret, om `U : DiscreteOracle`, `U(m)` implementerar $U ^ m $ för `m : Int`.</span><span class="sxs-lookup"><span data-stu-id="ca47e-122">Concretely, if `U : DiscreteOracle`, then `U(m)` implements $U^m$ for `m : Int`.</span></span>

<span data-ttu-id="ca47e-123">Med den här definitionen på plats fortsätter varje steg i upprepnings fas uppskattningen genom att förbereda en tilläggs qubit i $ \ket{+} $ State tillsammans med det inledande tillstånd $ \ket{\phi} $ som vi antar är en [eigenvector](xref:microsoft.quantum.concepts.matrix-advanced) av $U (m) $, d.v.s. $U (m) \ket{\phi} = e ^ {im\phi} \ ket {\ Phi} $.</span><span class="sxs-lookup"><span data-stu-id="ca47e-123">With this definition in place, each step of iterative phase estimation proceeds by preparing an auxiliary qubit in the $\ket{+}$ state along with the initial state $\ket{\phi}$ that we assume is an [eigenvector](xref:microsoft.quantum.concepts.matrix-advanced) of $U(m)$, i.e. $U(m)\ket{\phi}= e^{im\phi}\ket{\phi}$.</span></span>  
<span data-ttu-id="ca47e-124">En kontrollerad tillämpning av `U(m)` används sedan som förbereder status $ \left (R\_1 (m \phi) \ket{+} \right) \ket{\phi} $.</span><span class="sxs-lookup"><span data-stu-id="ca47e-124">A controlled application of `U(m)` is then used which prepares the state $\left(R\_1(m \phi) \ket{+}\right)\ket{\phi}$.</span></span>
<span data-ttu-id="ca47e-125">Som i Quantum-fallet är effekten av en kontrollerad tillämpning av Oracle-`U(m)` exakt samma som effekten av att tillämpa $R _1 $ för den okända fasen på $ \ket{+} $, så att vi kan beskriva effekterna av $U $ på det här enklare sättet.</span><span class="sxs-lookup"><span data-stu-id="ca47e-125">As in the quantum case, the effect of a controlled application of the oracle `U(m)` is precisely the same as the effect of applying $R_1$ for the unknown phase on $\ket{+}$, such that we can describe the effects of $U$ in this simpler fashion.</span></span>
<span data-ttu-id="ca47e-126">Algoritmen roterar sedan kontrollen qubit genom att använda $R _1 (-m\theta) $ för att hämta ett tillstånd $ \ket{\psi} = \left (R\_1 (m [\phi-\theta]) \ket{+} \right) \ket{\phi} $ $.</span><span class="sxs-lookup"><span data-stu-id="ca47e-126">Optionally, the algorithm then rotates the control qubit by applying $R_1(-m\theta)$ to obtain a state $\ket{\psi}=\left(R\_1(m [\phi-\theta]) \ket{+}\right)\ket{\phi}$$.</span></span>
<span data-ttu-id="ca47e-127">Hjälp qubit som används som kontroll för `U(m)` mäts sedan i $X $-basen för att få en enda klassisk `Result`.</span><span class="sxs-lookup"><span data-stu-id="ca47e-127">The auxiliary qubit used as a control for `U(m)` is then measured in the $X$ basis to obtain a single classical `Result`.</span></span>

<span data-ttu-id="ca47e-128">I det här läget är det ett klassiskt statistiskt problem med att konstruera om fasen från `Result` värden som erhålls genom iterativa fas uppskattning.</span><span class="sxs-lookup"><span data-stu-id="ca47e-128">At this point, reconstructing the phase from the `Result` values obtained through iterative phase estimation is a classical statistical inference problem.</span></span>
<span data-ttu-id="ca47e-129">Att hitta värdet för $m $ som maximerar den information som erhålls, med en fast härlednings metod, är bara ett problem i statistiken.</span><span class="sxs-lookup"><span data-stu-id="ca47e-129">Finding the value of $m$ that maximizes the information gained, given a fixed inference method, is simply a problem in statistics.</span></span>
<span data-ttu-id="ca47e-130">Vi betonar detta genom en kort beskrivning av den iterativa fasens uppskattning på en teoretisk nivå i Bayesian parameter bedömning innan du fortsätter med att beskriva de statistiska algoritmer som finns i Q # Canon för att lösa detta problem med den här klassiska lösningen.</span><span class="sxs-lookup"><span data-stu-id="ca47e-130">We emphasize this by briefly describing iterative phase estimation at a theoretical level in the Bayesian parameter estimation formalism before proceeding to describe the statistical algorithms provided in the Q# canon for solving this classical inference problem.</span></span>

### <a name="iterative-phase-estimation-without-eigenstates"></a><span data-ttu-id="ca47e-131">Uppskattning av iterativa faser utan Eigenstates</span><span class="sxs-lookup"><span data-stu-id="ca47e-131">Iterative Phase Estimation Without Eigenstates</span></span> ###

<span data-ttu-id="ca47e-132">Om det finns ett indata-tillstånd som inte är en eigenstate, vilket är att anta att om $U (m) \ket{\phi\_j} = e ^ {im\phi\_j} $, så guidar processen för fas uppskattning som icke-deterministiskt den Quantum statusen mot en enda energi eigenstate.</span><span class="sxs-lookup"><span data-stu-id="ca47e-132">If an input state is provided that is not an eigenstate, which is to say that if $U(m)\ket{\phi\_j} = e^{im\phi\_j}$ then the process of phase estimation non-deterministically guides the quantum state towards a single energy eigenstate.</span></span>  <span data-ttu-id="ca47e-133">Den eigenstate som den slutligen konvergerar till är den eigenstate som är mest sannolik för att producera observerade `Result`.</span><span class="sxs-lookup"><span data-stu-id="ca47e-133">The eigenstate it ultimately converges to is the eigenstate that is most likely to produce the observed `Result`.</span></span>

<span data-ttu-id="ca47e-134">Mer specifikt utför ett enda steg i PE följande icke-enhetliga omvandling för tillstånds \begin{align} \ sum_j \sqrt{\Pr (\phi\_j)} \ket{\phi\_j} \mapsto \sum\_j\frac {\ sqrt {\ PR (\phi\_j)} \sqrt{\Pr (\text{Result} | \phi\_j)} \ket{\phi\_j}} {\sqrt{\Pr (\phi\_j) \sum\_j \Pr (\text{Result} | \phi\_j)}}.</span><span class="sxs-lookup"><span data-stu-id="ca47e-134">Specifically, a single step of PE performs the following non-unitary transformation on a state \begin{align} \sum_j \sqrt{\Pr(\phi\_j)} \ket{\phi\_j} \mapsto \sum\_j\frac{\sqrt{\Pr(\phi\_j)}\sqrt{\Pr(\text{Result}|\phi\_j)}\ket{\phi\_j}}{\sqrt{\Pr(\phi\_j)\sum\_j \Pr(\text{Result}|\phi\_j)}}.</span></span>
<span data-ttu-id="ca47e-135">\end{align} eftersom den här processen upprepas över flera `Result` värden, eigenstates som inte har de maximala värdena $ \ prod_k \Pr (\text{Result}\_k | \phi\_j) $ kommer att döljas exponentiellt.</span><span class="sxs-lookup"><span data-stu-id="ca47e-135">\end{align} As this process is iterated over multiple `Result` values, eigenstates that do not have maximal values of $\prod_k\Pr(\text{Result}\_k|\phi\_j)$ will be exponentially suppressed.</span></span>
<span data-ttu-id="ca47e-136">Som ett resultat kommer processen att konvergera till tillstånd med en enda eigenvalue om experimenten väljs korrekt.</span><span class="sxs-lookup"><span data-stu-id="ca47e-136">As a result, the inference process will tend to converge to states with a single eigenvalue if the experiments are chosen properly.</span></span>

<span data-ttu-id="ca47e-137">Bayes ' satsen rekommenderar ytterligare att det tillstånd som resulterar från fas uppskattningen skrivs i formatet \begin{align} \frac{\sqrt{\Pr (\phi\_j)} \sqrt{\Pr (\text{Result} | \phi\_j)} \ket{\phi\_j}} {\sqrt{\Pr (\phi\_j) \sum\_j \Pr (\text{Result} | \phi\_j)}} = \ sum_j \sqrt{\Pr (\phi\_j | \text{Result})} \ket{\phi\_j}.</span><span class="sxs-lookup"><span data-stu-id="ca47e-137">Bayes' theorem further suggests that the state that results from phase estimation be written in the form \begin{align} \frac{\sqrt{\Pr(\phi\_j)}\sqrt{\Pr(\text{Result}|\phi\_j)}\ket{\phi\_j}}{\sqrt{\Pr(\phi\_j)\sum\_j \Pr(\text{Result}|\phi\_j)}}=\sum_j \sqrt{\Pr(\phi\_j|\text{Result})} \ket{\phi\_j}.</span></span>
<span data-ttu-id="ca47e-138">\end{align} här $ \Pr (\phi\_j | \text{Result}) $ kan tolkas som sannolikheten att en skulle anskriva till varje hypotes om den eigenstates som ges:</span><span class="sxs-lookup"><span data-stu-id="ca47e-138">\end{align} Here $\Pr(\phi\_j|\text{Result})$ can be interpretted as the probability that one would ascribe to each hypothesis about the eigenstates given:</span></span>

1. <span data-ttu-id="ca47e-139">kunskap om Quantum State före mätning,</span><span class="sxs-lookup"><span data-stu-id="ca47e-139">knowledge of the quantum state prior to measurement,</span></span>
2. <span data-ttu-id="ca47e-140">kunskaper om eigenstates i $U $ och,</span><span class="sxs-lookup"><span data-stu-id="ca47e-140">knowledge of the eigenstates of $U$ and,</span></span>
3. <span data-ttu-id="ca47e-141">kunskaper om Eigenvalues för $U $.</span><span class="sxs-lookup"><span data-stu-id="ca47e-141">knowledge of the eigenvalues of $U$.</span></span>

<span data-ttu-id="ca47e-142">Inlärning dessa tre saker är ofta exponentiellt hårda på en klassisk dator.</span><span class="sxs-lookup"><span data-stu-id="ca47e-142">Learning these three things is often exponentially hard on a classical computer.</span></span>
<span data-ttu-id="ca47e-143">Verktyget för fas uppskattning uppstår i ingen liten utsträckning från det faktum att det kan utföra en sådan Quantum inlärning-uppgift utan att veta något av dem.</span><span class="sxs-lookup"><span data-stu-id="ca47e-143">The utility of phase estimation arises, to no small extent, from the fact that it can perform such a quantum learning task without knowing any of them.</span></span>
<span data-ttu-id="ca47e-144">Fas uppskattning av den här orsaken visas i ett antal Quantum-algoritmer som ger exponentiell speedups.</span><span class="sxs-lookup"><span data-stu-id="ca47e-144">Phase estimation for this reason appears within a number of quantum algorithms that provide exponential speedups.</span></span>

### <a name="bayesian-phase-estimation"></a><span data-ttu-id="ca47e-145">Bayesian fas uppskattning</span><span class="sxs-lookup"><span data-stu-id="ca47e-145">Bayesian Phase Estimation</span></span> ###

> [!TIP]
> <span data-ttu-id="ca47e-146">Mer information om Bayesian fas uppskattning i praxis finns i [**PhaseEstimation**](https://github.com/microsoft/Quantum/tree/master/samples/characterization/phase-estimation) -exemplet.</span><span class="sxs-lookup"><span data-stu-id="ca47e-146">For more details on Bayesian phase estimation in practice, please see the [**PhaseEstimation**](https://github.com/microsoft/Quantum/tree/master/samples/characterization/phase-estimation) sample.</span></span>

<span data-ttu-id="ca47e-147">Idén med uppskattning av Bayesian-fasen är enkel.</span><span class="sxs-lookup"><span data-stu-id="ca47e-147">The idea of Bayesian phase estimation is simple.</span></span>
<span data-ttu-id="ca47e-148">Du samlar in mått statistik från fas beräknings protokollet och bearbetar sedan resultaten med Bayesian-härledning och ger en uppskattning av parametern.</span><span class="sxs-lookup"><span data-stu-id="ca47e-148">You collect measurement statistics from the phase estimation protocol and then you process the results using Bayesian inference and provide an estimate of the parameter.</span></span>
<span data-ttu-id="ca47e-149">Den här bearbetningen ger dig en uppskattning av eigenvalue samt osäkerheten i beräkningen.</span><span class="sxs-lookup"><span data-stu-id="ca47e-149">This processing gives you an estimate of the eigenvalue as well as the uncertainty in that estimate.</span></span>
<span data-ttu-id="ca47e-150">Du kan också utföra anpassningsbara experiment och använda tidigare information.</span><span class="sxs-lookup"><span data-stu-id="ca47e-150">It also allows you to perform adaptive experiments and utilize prior information.</span></span>
<span data-ttu-id="ca47e-151">Metoden restitutionssystem är att den är i beräknings krävande.</span><span class="sxs-lookup"><span data-stu-id="ca47e-151">The methods' principle drawback is that it is computationally demanding.</span></span>

<span data-ttu-id="ca47e-152">För att förstå hur den här Bayesian-processen fungerar, bör du tänka på att bearbeta ett enda `Zero` resultat.</span><span class="sxs-lookup"><span data-stu-id="ca47e-152">To understand how this Bayesian inference process works, consider the case of processing a single `Zero` result.</span></span>
<span data-ttu-id="ca47e-153">Observera att $X = \ket{+} \bra{+}-\ket{-}\bra{-}$, så att $ \ket{+} $ är den enda positiva eigenstate för $X $ som motsvarar `Zero`.</span><span class="sxs-lookup"><span data-stu-id="ca47e-153">Note that $X = \ket{+}\bra{+} - \ket{-}\bra{-}$, such that $\ket{+}$ is the only positive eigenstate of $X$ corresponding to `Zero`.</span></span>
<span data-ttu-id="ca47e-154">Sannolikheten för att `Zero` för ett [`PauliX` mått](xref:microsoft.quantum.concepts.pauli) på den första qubit har fått ett ingångs tillstånd $ \ket{\psi}\ket{\phi} $ \begin{Equation} \Pr (\texttt{Zero} | \psi) = \left | \braket{+ | \psi} \right | ^ 2.</span><span class="sxs-lookup"><span data-stu-id="ca47e-154">The probability of observing `Zero` for a [`PauliX` measurement](xref:microsoft.quantum.concepts.pauli) on the first qubit given an input state $\ket{\psi}\ket{\phi}$ is thus \begin{equation} \Pr(\texttt{Zero} | \psi) = \left| \braket{+ | \psi} \right|^2.</span></span>
<span data-ttu-id="ca47e-155">\end{Equation} i händelse av iterativ fas uppskattning, vi har den $ \ket{\psi} = R_1 (m [\phi-\theta]) \ket{+} $, till exempel \begin{align} \Pr (\texttt{Zero} | \phi; m, \theta) & = \left | \braket{+ | R_1 (m [\phi-\theta]) | +} \right | ^ 2 \\\\ & = \left | \frac12 \left (\bra{0} + \bra{1} \right) \left (\ket{0} + e ^ {i m [\phi-\theta]} \ket{1} \right) \right | ^ 2 \\\\ & = \left | \frac{1 + e ^ {i m [\phi-\theta]}}{2} \right | ^ 2 \\\\ & = \cos ^ 2 (m [\phi-\theta]/2) \tag{★} \label{EQ: fas-Est-sannolikhet}.</span><span class="sxs-lookup"><span data-stu-id="ca47e-155">\end{equation} In the case of iterative phase estimation, we have that $\ket{\psi} = R_1(m [\phi-\theta]) \ket{+}$, such that \begin{align} \Pr(\texttt{Zero} | \phi; m,\theta) & = \left| \braket{+ | R_1(m [\phi-\theta]) | +} \right|^2 \\\\ & = \left| \frac12 \left( \bra{0} + \bra{1} \right) \left( \ket{0} + e^{i m [\phi-\theta]} \ket{1} \right) \right|^2 \\\\ & = \left| \frac{1 + e^{i m [\phi-\theta]}}{2} \right|^2 \\\\ & = \cos^2(m [\phi-\theta] / 2) \tag{★} \label{eq:phase-est-likelihood}.</span></span>
<span data-ttu-id="ca47e-156">\end{align}, det vill säga en iterativ fas uppskattning av hur svängnings frekvensen för en Sinusoidal-funktion fungerar, med möjlighet att vända en följd med en förskjutning som anges av den sinusoid.</span><span class="sxs-lookup"><span data-stu-id="ca47e-156">\end{align} That is, iterative phase estimation consists of learning the oscillation frequency of a sinusoidal function, given the ability to flip a coin with a bias given by that sinusoid.</span></span>
<span data-ttu-id="ca47e-157">Efter traditionell klassisk terminologi kallar vi $ \eqref{EQ: Phase Est-sannolikhet} $ *funktionen sannolikhet* för iterativa fas uppskattningar.</span><span class="sxs-lookup"><span data-stu-id="ca47e-157">Following traditional classical terminology, we call $\eqref{eq:phase-est-likelihood}$ the *likelihood function* for iterative phase estimation.</span></span>

<span data-ttu-id="ca47e-158">Efter att ha observerat en `Result` från sannolikhets funktionen för iterativa fas beräkningar kan vi sedan använda Bayes ' Rule för att föreskriva vad vi bör tro för att följa den observationen.</span><span class="sxs-lookup"><span data-stu-id="ca47e-158">Having observed a `Result` from the iterative phase estimation likelihood function, we can then use Bayes' rule to prescribe what we should believe the phase to be following that observation.</span></span>
<span data-ttu-id="ca47e-159">Betong, \begin{Equation} \Pr (\phi | d) = \frac{\Pr (d | \phi) \Pr (\phi)} {\int \Pr (d | \phi) \Pr (\phi) {\mathrm d} \phi} \Pr (\phi), \end{Equation} där $d \in \\{\texttt{Zero}, \texttt{One}\\} $ är en `Result`, och där $ \Pr (\phi) $ beskriver vår tidigare övertygelse om $ \phi $.</span><span class="sxs-lookup"><span data-stu-id="ca47e-159">Concretely, \begin{equation} \Pr(\phi | d) = \frac{\Pr(d | \phi) \Pr(\phi)}{\int \Pr(d | \phi) \Pr(\phi){\mathrm d}\phi} \Pr(\phi), \end{equation} where $d \in \\{\texttt{Zero}, \texttt{One}\\}$ is a `Result`, and where $\Pr(\phi)$ describes our prior beliefs about $\phi$.</span></span>
<span data-ttu-id="ca47e-160">Detta gör att den iterativa arten av iterativa fas uppskattningen är explicit, eftersom den bakre fördelningen $ \Pr (\phi | d) $ beskriver vår övertygelse omedelbart före vårt observation av nästa `Result`.</span><span class="sxs-lookup"><span data-stu-id="ca47e-160">This then makes the iterative nature of iterative phase estimation explicit, as the posterior distribution $\Pr(\phi | d)$ describes our beliefs immediately preceding our observation of the next `Result`.</span></span>

<span data-ttu-id="ca47e-161">Vi kan när som helst under den här proceduren rapportera den fas $ \hat{\phi} $ som är härledd av klassisk kontrollant som \begin{Equation} \hat{\phi} \mathrel{: =} \expect [\phi | \text{data}] = \int \phi \Pr (\phi | \text{data}) {\mathrm d} \phi, \end{Equation} där $ \text{data} $ står för hela registreringen av alla `Result` värden som hämtats.</span><span class="sxs-lookup"><span data-stu-id="ca47e-161">At any point during this procedure, we can report the phase $\hat{\phi}$ inferred by the classical controller as \begin{equation} \hat{\phi} \mathrel{:=} \expect[\phi | \text{data}] = \int \phi \Pr(\phi | \text{data}) {\mathrm d}\phi, \end{equation} where $\text{data}$ stands for the entire record of all `Result` values obtained.</span></span>

<span data-ttu-id="ca47e-162">Exakt Bayesian-härledning är i praktiken indragbar.</span><span class="sxs-lookup"><span data-stu-id="ca47e-162">Exact Bayesian inference is in practice intractable.</span></span>
<span data-ttu-id="ca47e-163">För att se det här vill vi veta en $n $-bitars variabel $x $.</span><span class="sxs-lookup"><span data-stu-id="ca47e-163">To see this imagine we wish to learn an $n$-bit variable $x$.</span></span>
<span data-ttu-id="ca47e-164">Den tidigare distributionen $ \Pr (x) $ har stöd för över $2 ^ n $ hypotetiska värden för $x $.</span><span class="sxs-lookup"><span data-stu-id="ca47e-164">The prior distribution $\Pr(x)$ has support over $2^n$ hypothetical values of $x$.</span></span>
<span data-ttu-id="ca47e-165">Det innebär att om vi behöver en mycket exakt uppskattning av $x $ kan Bayesian-fasen uppskattning kräva minnes-och bearbetnings tid.</span><span class="sxs-lookup"><span data-stu-id="ca47e-165">This means that if we need a highly accurate estimate of $x$ then Bayesian phase estimation may need prohibitive memory and processing time.</span></span>
<span data-ttu-id="ca47e-166">När det gäller vissa program, till exempel Quantum-simulering, utesluter limitted-noggrannheten inte sådana metoder som andra program, till exempel Shor, kan inte använda en exakt Bayesian-härledning inom sitt fas beräknings steg.</span><span class="sxs-lookup"><span data-stu-id="ca47e-166">While for some applications, such as quantum simulation, the limitted accuracy required does not preclude such methods other applications, such as Shor's algorithm, cannot use exact Bayesian inference within its phase estimation step.</span></span>  <span data-ttu-id="ca47e-167">Därför ger vi även implementeringar för ungefärliga Bayesian-metoder, till exempel [slumpmässig stegvis uppskattning (RWPE)](xref:microsoft.quantum.research.randomwalkphaseestimation.randomwalkphaseestimation) och även icke-Bayesian metoder som [robust fas uppskattning](xref:microsoft.quantum.characterization.robustphaseestimation).</span><span class="sxs-lookup"><span data-stu-id="ca47e-167">For this reason, we also provide implementations for approximate Bayesian methods such as [random walk phase estimation (RWPE)](xref:microsoft.quantum.research.randomwalkphaseestimation.randomwalkphaseestimation) and also non-Bayesian approaches such as [robust phase estimation](xref:microsoft.quantum.characterization.robustphaseestimation).</span></span>

### <a name="robust-phase-estimation"></a><span data-ttu-id="ca47e-168">Robust fas uppskattning</span><span class="sxs-lookup"><span data-stu-id="ca47e-168">Robust Phase Estimation</span></span> ###

<span data-ttu-id="ca47e-169">En maximal återställnings period i *efterhand* Bayesian av en fas uppskattning från Mät resultaten är exponentiellt hårt i värsta fall.</span><span class="sxs-lookup"><span data-stu-id="ca47e-169">A maximum *a posteriori* Bayesian reconstruction of a phase estimate from measurement results is exponentially hard in the worst-case.</span></span> <span data-ttu-id="ca47e-170">Därför kan de flesta praktiska fas uppskattnings algoritmer offra viss kvalitet i återuppbyggnaden, i utbyte mot en mängd av den klassiska efter bearbetningen som i stället skalas polynom med antalet mätningar som görs.</span><span class="sxs-lookup"><span data-stu-id="ca47e-170">Thus most practical phase estimation algorithms sacrifice some quality in the reconstruction, in exchange for an amount of classical post-processing that instead scales polynomially with the number of measurements made.</span></span>

<span data-ttu-id="ca47e-171">Ett exempel med ett effektivt klassiskt steg efter bearbetning är [algoritmen för den robusta fasen för fas uppskattning](https://arxiv.org/abs/1502.02677), med signaturen och de inmatningar som anges ovan.</span><span class="sxs-lookup"><span data-stu-id="ca47e-171">One such example with an efficient classical post-processing step is the [robust phase estimation algorithm](https://arxiv.org/abs/1502.02677), with its signature and inputs mentioned above.</span></span> <span data-ttu-id="ca47e-172">Det förutsätter att inmatade svarta rutor $U $ paketeras som `DiscreteOracle` typ, och därför endast frågor med heltals behörighet för kontrollerade $U $.</span><span class="sxs-lookup"><span data-stu-id="ca47e-172">It assumes that input unitary black-boxes $U$ are packaged as `DiscreteOracle` type, and therefore only queries integer powers of controlled-$U$.</span></span> <span data-ttu-id="ca47e-173">Om ingångs läget i `Qubit[]` registrera är en eigenstate $U \ket{\psi} = e ^ {i\phi} \ ket {\ PSI} $, returnerar algoritmen robust fas uppskattning en uppskattning $ \hat{\phi}\in [-\pi, \pi) $ av $ \phi $ som en `Double`.</span><span class="sxs-lookup"><span data-stu-id="ca47e-173">If the input state in the `Qubit[]` register is an eigenstate $U\ket{\psi}=e^{i\phi}\ket{\psi}$, the robust phase estimation algorithm returns an estimate $\hat{\phi}\in[-\pi,\pi)$ of $\phi$ as a `Double`.</span></span>

<span data-ttu-id="ca47e-174">Den viktigaste funktionen i robust fas uppskattning, som delas med de flesta andra användbara varianter, är att rekonstruktions kvaliteten för $ \hat{\phi} $ är i en viss Heisenberg-begränsad.</span><span class="sxs-lookup"><span data-stu-id="ca47e-174">The most important feature of robust phase estimation, which is shared with most other useful variants, is that the reconstruction quality of $\hat{\phi}$ is in some sense Heisenberg-limited.</span></span> <span data-ttu-id="ca47e-175">Det innebär att om avvikelsen för $ \hat{\phi} $ från det sanna värdet är $ \sigma $ skalas $ \sigma $ i proportion till det totala antalet frågor som $Q $ gjorde till styrd-$U $, t. ex. $ \sigma = \mathcal{O} (1/Q) $.</span><span class="sxs-lookup"><span data-stu-id="ca47e-175">This means that if the deviation of $\hat{\phi}$ from the true value is $\sigma$, then $\sigma$ scales inversely-proportional to the total number of queries $Q$ made to controlled-$U$, i.e. $\sigma=\mathcal{O}(1/Q)$.</span></span> <span data-ttu-id="ca47e-176">Nu varierar definitionen av avvikelse mellan olika algoritmer för bedömning.</span><span class="sxs-lookup"><span data-stu-id="ca47e-176">Now, the definition of deviation varies between different estimation algorithms.</span></span> <span data-ttu-id="ca47e-177">I vissa fall kan det innebära att minst $ \mathcal{O} (1) $ sannolikhet, uppskattnings felet $ | \hat{\phi}-\phi |\_\circ\le \sigma $ på ett cirkulärt mått $ \circ $.</span><span class="sxs-lookup"><span data-stu-id="ca47e-177">In some cases, it may mean that with at least $\mathcal{O}(1)$ probability, the estimation error $|\hat{\phi}-\phi|\_\circ\le \sigma$ on some circular measure $\circ$.</span></span> <span data-ttu-id="ca47e-178">För robust fas uppskattning är avvikelsen exakt variansen $ \sigma ^ 2 = \mathbb{E}\_\hat{\phi} [(\mod\_{2 \ PI} (\hat{\phi}-\phi + \pi)-\pi) ^ 2] $ om vi avbryter periodiska faser till ett enda ändligt intervall $ (-\pi, \pi] $.</span><span class="sxs-lookup"><span data-stu-id="ca47e-178">For robust phase estimation, deviation is precisely the variance $\sigma^2 = \mathbb{E}\_\hat{\phi}[(\mod\_{2\pi}(\hat{\phi}-\phi +\pi)-\pi)^2]$ if we unwrap periodic phases onto a single finite interval $(-\pi,\pi]$.</span></span> <span data-ttu-id="ca47e-179">Mer exakt uppfyller standard avvikelsen i robust fas uppskattningen $ $ \begin{align} 2,0 \pi/Q \le \sigma \le 2 \ Pi/2 ^ {n} \le 10.7 \ PI/Q, \end{align} $ $ där den nedre gränsen uppnås inom gränsen på asymptotically Large $Q $ och den övre gränsen garanteras även för små urvals storlekar.</span><span class="sxs-lookup"><span data-stu-id="ca47e-179">More precisely, the standard deviation in robust phase estimation satisfies the inequalities $$ \begin{align} 2.0 \pi / Q \le \sigma \le 2\pi / 2^{n} \le 10.7\pi / Q, \end{align} $$ where the lower bound is reached in the limit of asymptotically large $Q$, and the upper bound is guaranteed even for small sample sizes.</span></span>  <span data-ttu-id="ca47e-180">Observera att $n $ som har valts av `bitsPrecision` Indatatyp, som implicit definierar $Q $.</span><span class="sxs-lookup"><span data-stu-id="ca47e-180">Note that $n$ selected by the `bitsPrecision` input, which implicitly defines $Q$.</span></span>

<span data-ttu-id="ca47e-181">Andra relevanta uppgifter inkluderar, t. ex. den små utrymmes kostnaden på bara $1 $ Ancilla qubit, eller att proceduren är icke-adaptiv, vilket innebär att den nödvändiga sekvensen av Quantum experiment är oberoende av de mellanliggande Mät resultat.</span><span class="sxs-lookup"><span data-stu-id="ca47e-181">Other relevant details include, say, the small space overhead of just $1$ ancilla qubit, or that the procedure is non-adaptive, meaning the required sequence of quantum experiments is independent of the intermediate measurement outcomes.</span></span> <span data-ttu-id="ca47e-182">I det här och kommande exempel där valet av algoritmen för fas uppskattning är viktigt, bör en bör hänvisa till dokumentationen, till exempel @"microsoft.quantum.characterization.robustphaseestimation" och de refererade publikationerna där, för mer information och för deras implementering.</span><span class="sxs-lookup"><span data-stu-id="ca47e-182">In this and forthcoming examples where the choice of phase estimation algorithm is important, one should one should refer to the documentation such as @"microsoft.quantum.characterization.robustphaseestimation" and the referenced publications therein for more information and for their the implementation.</span></span>

> [!TIP]
> <span data-ttu-id="ca47e-183">Det finns många exempel där robust fas uppskattning används.</span><span class="sxs-lookup"><span data-stu-id="ca47e-183">There are many samples where robust phase estimation is used.</span></span> <span data-ttu-id="ca47e-184">För fas uppskattning när du extraherar mark tillstånds energin för olika fysiska system kan du se exempel på [ **H2-simulering** ](https://github.com/microsoft/Quantum/tree/master/samples/simulation/h2/command-line), [ **SimpleIsing** -exemplet](https://github.com/microsoft/Quantum/tree/master/samples/simulation/ising/simple)och [ **Hubbard Model** -exemplet](https://github.com/microsoft/Quantum/tree/master/samples/simulation/hubbard).</span><span class="sxs-lookup"><span data-stu-id="ca47e-184">For phase estimation in extracting the ground state energy of various physical system, please see the [**H2 simulation** sample](https://github.com/microsoft/Quantum/tree/master/samples/simulation/h2/command-line), the [**SimpleIsing** sample](https://github.com/microsoft/Quantum/tree/master/samples/simulation/ising/simple), and the [**Hubbard model** sample](https://github.com/microsoft/Quantum/tree/master/samples/simulation/hubbard).</span></span>


### <a name="continuous-oracles"></a><span data-ttu-id="ca47e-185">Kontinuerliga Oracle</span><span class="sxs-lookup"><span data-stu-id="ca47e-185">Continuous Oracles</span></span> ###

<span data-ttu-id="ca47e-186">Vi kan också generalisera från den Oracle-modell som används ovan för att tillåta löpande Oracle, som modelleras av Canon-typen <xref:microsoft.quantum.oracles.continuousoracle>.</span><span class="sxs-lookup"><span data-stu-id="ca47e-186">We can also generalize from the oracle model used above to allow for continuous-time oracles, modeled by the canon type <xref:microsoft.quantum.oracles.continuousoracle>.</span></span>
<span data-ttu-id="ca47e-187">Tänk på att i stället för en enda enhetlig operatör $U $, har vi en familj med enhetliga operatörer $U (t) $ för $t \in \mathbb{R} $ så att $U (t) U (s) $ = $U (t + s) $.</span><span class="sxs-lookup"><span data-stu-id="ca47e-187">Consider that instead of a single unitary operator $U$, we have a family of unitary operators $U(t)$ for $t \in \mathbb{R}$ such that $U(t) U(s)$ = $U(t + s)$.</span></span>
<span data-ttu-id="ca47e-188">Detta är en svagare instruktion än i det diskreta fallet eftersom vi kan skapa en <xref:microsoft.quantum.oracles.discreteoracle> genom att begränsa $t = m\,\delta t $ för vissa fasta $ \delta t $.</span><span class="sxs-lookup"><span data-stu-id="ca47e-188">This is a weaker statement than in the discrete case, since we can construct a <xref:microsoft.quantum.oracles.discreteoracle> by restricting $t = m\,\delta t$ for some fixed $\delta t$.</span></span>
<span data-ttu-id="ca47e-189">I [sten satsen](https://en.wikipedia.org/wiki/Stone%27s_theorem_on_one-parameter_unitary_groups), $U (t) = \exp (i H t) $ för en viss operator $H $, där $ \exp $ är matrisen exponent enligt beskrivningen i [avancerade matriser](xref:microsoft.quantum.concepts.matrix-advanced).</span><span class="sxs-lookup"><span data-stu-id="ca47e-189">By [Stone's theorem](https://en.wikipedia.org/wiki/Stone%27s_theorem_on_one-parameter_unitary_groups), $U(t) = \exp(i H t)$ for some operator $H$, where $\exp$ is the matrix exponential as described in [advanced matrices](xref:microsoft.quantum.concepts.matrix-advanced).</span></span>
<span data-ttu-id="ca47e-190">En eigenstate $ \ket{\phi} $ $H $ så att $H \ket{\phi} = \phi \ket{\phi} $ också är en eigenstate av $U (t) $ för alla $t $, \begin{Equation} U (t) \ket{\phi} = e ^ {i \phi t} \ket{\phi}.</span><span class="sxs-lookup"><span data-stu-id="ca47e-190">An eigenstate $\ket{\phi}$ of $H$ such that $H \ket{\phi} = \phi \ket{\phi}$ is then also an eigenstate of $U(t)$ for all $t$, \begin{equation} U(t) \ket{\phi} = e^{i \phi t} \ket{\phi}.</span></span>
<span data-ttu-id="ca47e-191">\end{equation}</span><span class="sxs-lookup"><span data-stu-id="ca47e-191">\end{equation}</span></span>

<span data-ttu-id="ca47e-192">Exakt samma analys som diskuteras vid [uppskattning av Bayesian-fasen](#bayesian-phase-estimation) kan tillämpas och sannolikhets funktionen är exakt densamma för den här mer generella Oracle-modellen: $ $ \Pr (\texttt{Zero} | \phi; t, \theta) = \cos ^ 2 \ Left (\frac{t [\phi-\theta]}{2}\right).</span><span class="sxs-lookup"><span data-stu-id="ca47e-192">The exact same analysis discussed for [Bayesian phase estimation](#bayesian-phase-estimation) can be applied, and the likelihood function is the precisely the same for this more general oracle model: $$ \Pr(\texttt{Zero} | \phi; t,\theta)=\cos^2\left(\frac{t[\phi -\theta]}{2}\right).</span></span>
<span data-ttu-id="ca47e-193">$ $ Om $U $ är en simulering av en dynamisk generator, vilket är fallet för [simulering av Hamiltonian](xref:microsoft.quantum.libraries.applications#hamiltonian-simulation), tolkar vi $ \phi $ som energi.</span><span class="sxs-lookup"><span data-stu-id="ca47e-193">$$ Moreover, if $U$ is a simulation of a dynamical generator, as is the case for [Hamiltonian simulation](xref:microsoft.quantum.libraries.applications#hamiltonian-simulation), we interpret $\phi$ as an energy.</span></span>
<span data-ttu-id="ca47e-194">Med hjälp av fas uppskattning med kontinuerliga frågor kan vi alltså lära sig det simulerade [energi spektrumet av molekyler](https://arxiv.org/abs/quant-ph/0604193), [material](https://arxiv.org/abs/1510.03859) eller [fält basreaktionsteorier](https://arxiv.org/abs/1111.3633v2) utan att behöva kompromissa med valet av experiment genom att kräva att $t $ måste vara ett heltal.</span><span class="sxs-lookup"><span data-stu-id="ca47e-194">Thus, using phase estimation with continuous queries allows us to learn the simulated [energy spectrum of molecules](https://arxiv.org/abs/quant-ph/0604193), [materials](https://arxiv.org/abs/1510.03859) or [field theories](https://arxiv.org/abs/1111.3633v2) without having to compromise our choice of experiments by requiring $t$ to be an integer.</span></span>

### <a name="random-walk-phase-estimation"></a><span data-ttu-id="ca47e-195">Beräkning av slumpmässig stegvis fas</span><span class="sxs-lookup"><span data-stu-id="ca47e-195">Random Walk Phase Estimation</span></span> ###

<span data-ttu-id="ca47e-196">Q # ger en användbar uppskattning av Bayesian-fasens uppskattning som är utformad för användning nära Quantum-enheter som fungerar genom att en slumpmässig genom gång av data posten hämtas från en iterativ fas uppskattning.</span><span class="sxs-lookup"><span data-stu-id="ca47e-196">Q# provides a useful approximation of Bayesian phase estimation designed for use close to quantum devices that operates by conditioning a random walk on the data record obtained from iterative phase estimation.</span></span>
<span data-ttu-id="ca47e-197">Den här metoden är både anpassningsbar och helt deterministisk, vilket ger optimal skalning av fel i den uppskattade fasen $ \hat{\phi} $ med mycket låga minnes omkostnader.</span><span class="sxs-lookup"><span data-stu-id="ca47e-197">This method is both adaptive and entirely deterministic, allowing for near-optimal scaling of errors in the estimated phase $\hat{\phi}$ with very low memory overheads.</span></span>

<span data-ttu-id="ca47e-198">Protokollet använder en ungefärlig Bayesian-härlednings metod som förutsätter att den tidigare distributionen är Gaussisk.</span><span class="sxs-lookup"><span data-stu-id="ca47e-198">The protocol uses an approximate Bayesian inference method that assumes the prior distribution is Gaussian.</span></span>
<span data-ttu-id="ca47e-199">Detta Gaussisk-antagande gör att vi kan använda en analys formel för experimentet som minimerar den bakre avvikelsen.</span><span class="sxs-lookup"><span data-stu-id="ca47e-199">This Gaussian assumption allows us to use an analytical formula for the experiment that minimizes the posterior variance.</span></span>
<span data-ttu-id="ca47e-200">Algoritmen, baserat på resultatet av experimentet, byter uppskattningen av $ \phi $ till vänster eller höger med ett fördefinierat belopp och minskar avvikelsen med ett fördefinierat belopp.</span><span class="sxs-lookup"><span data-stu-id="ca47e-200">The algorithm then, based on the outcome of that experiment, shifts the estimate of $\phi$ left or right by a pre-determined amount and shrinks the variance by a pre-determined amount.</span></span>
<span data-ttu-id="ca47e-201">Det här medelvärdet och avvikelsen ger all information som behövs för att ange en Gaussisk före $ \phi $ för nästa experiment.</span><span class="sxs-lookup"><span data-stu-id="ca47e-201">This mean and variance give all the information that is needed to specify a Gaussian prior on $\phi$ for the next experiment.</span></span>
<span data-ttu-id="ca47e-202">Oväntade Mät fel eller det sanna resultatet är i början av den första föregående, kan orsaka att metoden Miss lyckas.</span><span class="sxs-lookup"><span data-stu-id="ca47e-202">Unexpected measurement failures, or the true result being on the tails of the initial prior, can cause this method to fail.</span></span>
<span data-ttu-id="ca47e-203">Den återställs från problem genom att utföra experiment för att testa om det aktuella medelvärdet och standard avvikelsen är lämpliga för systemet.</span><span class="sxs-lookup"><span data-stu-id="ca47e-203">It recovers from failure by performing experiments to test whether the current mean and standard deviation are appropriate for the system.</span></span>
<span data-ttu-id="ca47e-204">Om de inte är det gör algoritmen ett inverterat steg i processen och processen fortsätter.</span><span class="sxs-lookup"><span data-stu-id="ca47e-204">If they are not, then the algorithm does an inverse step of the walk and the process continues.</span></span>
<span data-ttu-id="ca47e-205">Med möjligheten att gå baklänges kan algoritmen även lära sig även om den inledande föregående standard avvikelsen är inapropriately liten.</span><span class="sxs-lookup"><span data-stu-id="ca47e-205">The ability to step backwards also allows the algorithm to learn even if the initial prior standard deviation is inapropriately small.</span></span>

## <a name="calling-phase-estimation-algorithms"></a><span data-ttu-id="ca47e-206">Algoritmer för att anropa fas uppskattning</span><span class="sxs-lookup"><span data-stu-id="ca47e-206">Calling Phase Estimation Algorithms</span></span> ##

<span data-ttu-id="ca47e-207">Varje fas uppskattnings åtgärd som medföljer Q # Canon tar en annan uppsättning inmatningar som använder den kvalitet som vi efterfrågar för den slutliga uppskattningen $ \hat{\phi} $.</span><span class="sxs-lookup"><span data-stu-id="ca47e-207">Each phase estimation operation provided with the Q# canon takes a different set of inputs parameterizing the quality that we demand out of the final estimate $\hat{\phi}$.</span></span>
<span data-ttu-id="ca47e-208">Dessa olika indata, men alla delar flera indata, så att partiell program över kvalitets parametrarna resulterar i en gemensam signatur.</span><span class="sxs-lookup"><span data-stu-id="ca47e-208">These various inputs, however, all share several inputs in common, such that partial application over the quality parameters results in a common signature.</span></span>
<span data-ttu-id="ca47e-209"><xref:microsoft.quantum.characterization.robustphaseestimation> åtgärden som diskuteras i nästa avsnitt har till exempel följande signatur:</span><span class="sxs-lookup"><span data-stu-id="ca47e-209">For example, the <xref:microsoft.quantum.characterization.robustphaseestimation> operation discussed in the next section has the following signature:</span></span>

```qsharp
operation RobustPhaseEstimation(bitsPrecision : Int, oracle : DiscreteOracle, eigenstate : Qubit[])  : Double
```

<span data-ttu-id="ca47e-210">`bitsPrecision` inmatarna är unika för `RobustPhaseEstimation`, medan `oracle` och `eigenstate` är vanliga.</span><span class="sxs-lookup"><span data-stu-id="ca47e-210">The `bitsPrecision` input is unique to `RobustPhaseEstimation`, while `oracle` and `eigenstate` are in common.</span></span>
<span data-ttu-id="ca47e-211">Som det visas i **H2Sample**kan en åtgärd på detta sätt acceptera en upprepnings uppskattnings algoritm med indata från formuläret `(DiscreteOracle, Qubit[]) => Unit` så att en användare kan ange godtyckliga algoritmer för fas uppskattning:</span><span class="sxs-lookup"><span data-stu-id="ca47e-211">Thus, as seen in **H2Sample**, an operation can accept an iterative phase estimation algorithm with an input of the form `(DiscreteOracle, Qubit[]) => Unit` to allow a user to specify arbitrary phase estimation algorithms:</span></span>

```qsharp
operation H2EstimateEnergy(
    idxBondLength : Int,
    trotterStepSize : Double,
    phaseEstAlgorithm : ((DiscreteOracle, Qubit[]) => Double))
: Double
```

<span data-ttu-id="ca47e-212">Dessa algoritmer för myriaden-bedömning är optimerade för olika egenskaper och indataparametrar, vilket måste förstås för att göra det bästa valet för mål programmet.</span><span class="sxs-lookup"><span data-stu-id="ca47e-212">These myriad phase estimation algorithms are optimized for different properties and input parameters, which must be understood to make the best choice for the target application.</span></span> <span data-ttu-id="ca47e-213">Till exempel är vissa algoritmer för fas uppskattning anpassningsbara, vilket innebär att framtida steg styrs klassiskt av mät resultaten i föregående steg.</span><span class="sxs-lookup"><span data-stu-id="ca47e-213">For instance, some phase estimation algorithms are adaptive, meaning that future steps are classically controlled by the measurement results of previous steps.</span></span> <span data-ttu-id="ca47e-214">Vissa kräver möjligheten att exponentiate den svarta Box-gruppen av andra verkliga befogenheter, och andra kräver bara heltals befogenheter, men det går bara att lösa en fas Beräknad modulo $2 \ PI $.</span><span class="sxs-lookup"><span data-stu-id="ca47e-214">Some require the ability to exponentiate its black-box unitary oracle by arbitrary real powers, and others only require integer powers but are only able to resolve a phase estimate modulo $2\pi$.</span></span> <span data-ttu-id="ca47e-215">Vissa kräver många hjälp qubits och andra kräver bara en.</span><span class="sxs-lookup"><span data-stu-id="ca47e-215">Some require many auxiliary qubits, and others require only one.</span></span>

<span data-ttu-id="ca47e-216">På samma sätt går det bra att använda slumpmässig stegvisa beräknings steg på samma sätt som för andra algoritmer som medföljer Canon:</span><span class="sxs-lookup"><span data-stu-id="ca47e-216">Similarly, using random walk phase estimation proceeds in much the same way as for other algorithms provided with the canon:</span></span>

```qsharp
operation ApplyExampleOracle(
    eigenphase : Double,
    time : Double,
    register : Qubit[])
: Unit is Adj + Ctl {
    Rz(2.0 * eigenphase * time, register[0]);
}

operation EstimateBayesianPhase(eigenphase : Double) : Double {
    let oracle = ContinuousOracle(ApplyExampleOracle(eigenphase, _, _));
    using (eigenstate = Qubit()) {
        X(eigenstate);
        // The additional inputs here specify the mean and variance of the prior, the number of
        // iterations to perform, how many iterations to perform as a maximum, and how many
        // steps to roll back on an approximation failure.
        let est = RandomWalkPhaseEstimation(0.0, 1.0, 61, 100000, 1, oracle, [eigenstate]);
        Reset(eigenstate);
        return est;
    }
}
```
