---
title: Q# Design principer för API
description: Q# Design principer för API
author: cgranade
ms.author: chgranad
ms.date: 3/9/2020
ms.topic: contributor-guide
uid: microsoft.quantum.contributing.api-design
no-loc:
- Q#
- $$v
ms.openlocfilehash: 452b32141dc660acbe8ef28530f1430e5acff9aa
ms.sourcegitcommit: 71605ea9cc630e84e7ef29027e1f0ea06299747e
ms.translationtype: MT
ms.contentlocale: sv-SE
ms.lasthandoff: 01/26/2021
ms.locfileid: "98856691"
---
# <a name="no-locq-api-design-principles"></a><span data-ttu-id="40fed-103">Q# Design principer för API</span><span class="sxs-lookup"><span data-stu-id="40fed-103">Q# API Design Principles</span></span>

## <a name="introduction"></a><span data-ttu-id="40fed-104">Introduktion</span><span class="sxs-lookup"><span data-stu-id="40fed-104">Introduction</span></span>

<span data-ttu-id="40fed-105">Som ett språk och som plattform ger Q# användare möjlighet att skriva, köra, förstå och utforska Quantum-program.</span><span class="sxs-lookup"><span data-stu-id="40fed-105">As a language and as a platform, Q# empowers users to write, run, understand, and explore quantum applications.</span></span>
<span data-ttu-id="40fed-106">För att användarna ska kunna utforma Q# bibliotek följer vi en uppsättning API design-principer som vägleder våra design och hjälper oss att göra användbara bibliotek för den Quantum Development-communityn.</span><span class="sxs-lookup"><span data-stu-id="40fed-106">In order to empower users, when we design Q# libraries, we follow a set of API design principles to guide our designs and to help us make usable libraries for the the quantum development community.</span></span>
<span data-ttu-id="40fed-107">Den här artikeln innehåller de här principerna och ger exempel på hur du kan använda dem när du skapar Q# API: er.</span><span class="sxs-lookup"><span data-stu-id="40fed-107">This article lists these principles, and gives examples to help guide how to apply them when designing Q# APIs.</span></span>

> [!TIP]
> <span data-ttu-id="40fed-108">Det här är ett ganska detaljerat dokument som hjälper dig att hjälpa till med biblioteks utveckling och djupgående biblioteks bidrag.</span><span class="sxs-lookup"><span data-stu-id="40fed-108">This is a fairly detailed document that's intended to help guide library development and in-depth library contributions.</span></span>
> <span data-ttu-id="40fed-109">Du kommer förmodligen att upptäcka det mest användbart om du skriver dina egna bibliotek i Q# , eller om du bidrar med större funktioner till [ Q# biblioteks lagrings platsen](https://github.com/microsoft/QuantumLibraries).</span><span class="sxs-lookup"><span data-stu-id="40fed-109">You'll probably find it most useful if you're writing your own libraries in Q#, or if you're contributing larger features to the [Q# libraries repository](https://github.com/microsoft/QuantumLibraries).</span></span>
>
> <span data-ttu-id="40fed-110">Å andra sidan rekommenderar vi att du börjar med [bidrags hand boken](xref:microsoft.quantum.contributing), om du vill lära dig att bidra till Quantum Development Kit.</span><span class="sxs-lookup"><span data-stu-id="40fed-110">On the other hand, if you're looking to learn how to contribute to the Quantum Development Kit more generally, we suggest starting with the [contribution guide](xref:microsoft.quantum.contributing).</span></span>
> <span data-ttu-id="40fed-111">Om du vill ha mer allmän information om hur vi rekommenderar att du formaterar Q# koden kan du vara intresse rad av att checka ut [stil guiden](xref:microsoft.quantum.contributing.style).</span><span class="sxs-lookup"><span data-stu-id="40fed-111">If you're looking for more general information about how we recommend formatting your Q# code, you may be interested in checking out the [style guide](xref:microsoft.quantum.contributing.style).</span></span>

## <a name="general-principles"></a><span data-ttu-id="40fed-112">Allmänna principer</span><span class="sxs-lookup"><span data-stu-id="40fed-112">General Principles</span></span>

<span data-ttu-id="40fed-113">**Nyckel princip:** Exponera API: er som placerar fokus på Quantum-program.</span><span class="sxs-lookup"><span data-stu-id="40fed-113">**Key principle:** Expose APIs that places the focus on quantum applications.</span></span>

- <span data-ttu-id="40fed-114">✅**Välj** åtgärds-och funktions namn som återspeglar en hög nivå struktur för algoritmer och program.</span><span class="sxs-lookup"><span data-stu-id="40fed-114">✅ **DO** choose operation and function names that reflect the   high-level structure of algorithms and applications.</span></span>
- <span data-ttu-id="40fed-115">⛔️ visar **inte** API: er som främst fokuserar på lågnivå implementerings uppgifter.</span><span class="sxs-lookup"><span data-stu-id="40fed-115">⛔️ **DON'T** expose APIs that focus primarily on low-level   implementation details.</span></span>

<span data-ttu-id="40fed-116">**Nyckel princip:** Starta varje API-design med exempel användnings fall för att säkerställa att API: er är intuitiva att använda.</span><span class="sxs-lookup"><span data-stu-id="40fed-116">**Key principle:** Start each API design with sample use cases to ensure that APIs are intuitive to use.</span></span>

- <span data-ttu-id="40fed-117">✅**Se till att varje** komponent i ett offentligt API har ett motsvarande användnings fall, i stället för att försöka utforma för alla möjliga användnings områden från start.</span><span class="sxs-lookup"><span data-stu-id="40fed-117">✅ **DO** ensure that each component of a public API has a corresponding use case, rather than trying to design for all possible uses from the start.</span></span>
    <span data-ttu-id="40fed-118">Sätt inte på olika offentliga API: er om de är användbara, men se till att varje del av ett API har ett *konkret* exempel där det är användbart.</span><span class="sxs-lookup"><span data-stu-id="40fed-118">Put differently, don't introduce public APIs in case they are useful, but make sure that each part of an API has a *concrete* example in which it will be useful.</span></span>

  <span data-ttu-id="40fed-119">*Exempel:*</span><span class="sxs-lookup"><span data-stu-id="40fed-119">*Examples:*</span></span>
  - <span data-ttu-id="40fed-120">@"microsoft.quantum.canon.applytoeachca" kan användas `ApplyToEachCA(H, _)` för att förbereda register i ett enhetligt befattnings tillstånd, en vanlig uppgift i många Quantum-algoritmer.</span><span class="sxs-lookup"><span data-stu-id="40fed-120">@"microsoft.quantum.canon.applytoeachca" can be used as `ApplyToEachCA(H, _)` to prepare registers in a uniform superposition state, a common task in many quantum algorithms.</span></span> <span data-ttu-id="40fed-121">Samma åtgärd kan också användas för många andra uppgifter i förberedelser, siffror och Oracle-baserade algoritmer.</span><span class="sxs-lookup"><span data-stu-id="40fed-121">The same operation can also be used for many other tasks in preparation, numerics, and oracle-based algorithms.</span></span>

- <span data-ttu-id="40fed-122">✅**Gör** kreativitet och workshop nya API-design för att kontrol lera att de är intuitiva och uppfyller föreslagna användnings fall.</span><span class="sxs-lookup"><span data-stu-id="40fed-122">✅ **DO** brainstorm and workshop new API designs to double-check   that they are intuitive and meet proposed use cases.</span></span>

  <span data-ttu-id="40fed-123">*Exempel:*</span><span class="sxs-lookup"><span data-stu-id="40fed-123">*Examples:*</span></span>
  - <span data-ttu-id="40fed-124">Kontrol lera den aktuella Q- \# koden för att se hur nya API-Designer kan förenkla och klargöra befintliga implementeringar.</span><span class="sxs-lookup"><span data-stu-id="40fed-124">Inspect current Q\# code to see how new API designs could   simplify and clarify existing implementations.</span></span>
  - <span data-ttu-id="40fed-125">Granska föreslagna API-design med representanter för primära mål grupper.</span><span class="sxs-lookup"><span data-stu-id="40fed-125">Review proposed API designs with representatives of primary   audiences.</span></span>

<span data-ttu-id="40fed-126">**Nyckel princip:** Utforma API: er som stöder och uppmuntrar till läsbar kod.</span><span class="sxs-lookup"><span data-stu-id="40fed-126">**Key principle:** Design APIs to support and encourage readable code.</span></span>

- <span data-ttu-id="40fed-127">✅**Se till att koden** kan läsas av domän experter och icke-experter.</span><span class="sxs-lookup"><span data-stu-id="40fed-127">✅ **DO** ensure that code is readable by domain experts and   non-experts alike.</span></span>
- <span data-ttu-id="40fed-128">✅**Fokusera på** effekterna av varje åtgärd och funktion inom algoritmen på hög nivå, med hjälp av dokumentationen för att gå in på implementerings informationen på lämpligt sätt.</span><span class="sxs-lookup"><span data-stu-id="40fed-128">✅ **DO** place the focus on the effects of each operation and   function within the high-level algorithm, using documentation to   delve into implementation details as appropriate.</span></span>
- <span data-ttu-id="40fed-129">✅**Följ den** vanliga [Q \# stil guiden](xref:microsoft.quantum.contributing.style) när det är tillämpligt.</span><span class="sxs-lookup"><span data-stu-id="40fed-129">✅ **DO** follow the common [Q\# style guide](xref:microsoft.quantum.contributing.style) whenever applicable.</span></span>

<span data-ttu-id="40fed-130">**Nyckel princip:** Design-API: er som ska vara stabila och för att vidarebefordra kompatibilitet.</span><span class="sxs-lookup"><span data-stu-id="40fed-130">**Key principle:** Design APIs to be stable and to provide forward compatibility.</span></span>

- <span data-ttu-id="40fed-131">✅**Gör** inaktuella gamla API: er på ett smidigt sätt när du behöver bryta ändringar.</span><span class="sxs-lookup"><span data-stu-id="40fed-131">✅ **DO** deprecate old APIs gracefully when breaking changes are   required.</span></span>

- <span data-ttu-id="40fed-132">✅**Ge "** shim"-åtgärder och-funktioner som tillåter att befintlig användar kod fungerar korrekt under utfasningen.</span><span class="sxs-lookup"><span data-stu-id="40fed-132">✅ **DO** provide "shim" operations and functions that allow   existing user code to operate correctly during deprecation.</span></span>

  <span data-ttu-id="40fed-133">*Exempel:*</span><span class="sxs-lookup"><span data-stu-id="40fed-133">*Examples:*</span></span>
  - <span data-ttu-id="40fed-134">När du byter namn på en `EstimateExpectation` åtgärd   `EstimateAverage` som kallas för, introducerar en ny åtgärd som anropar   `EstimateExpectation` den ursprungliga åtgärden med det nya namnet, så att den befintliga koden kan fortsätta att fungera korrekt.</span><span class="sxs-lookup"><span data-stu-id="40fed-134">When renaming an operation called `EstimateExpectation` to   `EstimateAverage`, introduce a new operation called   `EstimateExpectation` that calls the original operation at   its new name, so that existing code can continue to work   correctly.</span></span>

- <span data-ttu-id="40fed-135">✅**Använd** @"microsoft.quantum.core.deprecated" attributet för att kommunicera utfasningar till användaren.</span><span class="sxs-lookup"><span data-stu-id="40fed-135">✅ **DO** use the @"microsoft.quantum.core.deprecated" attribute to communicate deprecations to the user.</span></span>

- <span data-ttu-id="40fed-136">✅ När du byter namn på en åtgärd eller funktion ska **du ange det** nya namnet som en sträng inskrivning till `@Deprecated` .</span><span class="sxs-lookup"><span data-stu-id="40fed-136">✅ When renaming an operation or function, **DO** provide the new   name as a string input to `@Deprecated`.</span></span>

- <span data-ttu-id="40fed-137">⛔️ **inte** att ta bort befintliga funktioner eller åtgärder utan en föråldrad period på minst sex månader för för hands versioner, eller minst två år för versioner som stöds.</span><span class="sxs-lookup"><span data-stu-id="40fed-137">⛔️ **DON'T** remove existing functions or operations without a   deprecation period of at least six months for preview releases,   or at least two years for supported releases.</span></span>

## <a name="functions-and-operations"></a><span data-ttu-id="40fed-138">Funktioner och åtgärder</span><span class="sxs-lookup"><span data-stu-id="40fed-138">Functions and Operations</span></span>

<span data-ttu-id="40fed-139">**Nyckel princip:** se till att varje funktion och åtgärd har ett enda väldefinierat syfte inom API: et.</span><span class="sxs-lookup"><span data-stu-id="40fed-139">**Key principle:** ensure that every function and operation has a single well-defined purpose within the API.</span></span>

- <span data-ttu-id="40fed-140">⛔️ visar **inte** funktioner och åtgärder som utför flera orelaterade uppgifter.</span><span class="sxs-lookup"><span data-stu-id="40fed-140">⛔️ **DON'T** expose functions and operations that perform multiple   unrelated tasks.</span></span>

<span data-ttu-id="40fed-141">**Nyckel princip:** utforma funktioner och åtgärder för att vara så användbara som möjligt och för att förutse framtida behov.</span><span class="sxs-lookup"><span data-stu-id="40fed-141">**Key principle:** design functions and operations to be as reusable as possible, and to anticipate future needs.</span></span>

- <span data-ttu-id="40fed-142">✅**Utför** design funktioner och åtgärder för att skapa bra med andra funktioner och åtgärder, både i samma API och i tidigare befintliga bibliotek.</span><span class="sxs-lookup"><span data-stu-id="40fed-142">✅ **DO** design functions and operations to compose well with other   functions and operations, both in the same API and in previously   existing libraries.</span></span>

  <span data-ttu-id="40fed-143">*Exempel:*</span><span class="sxs-lookup"><span data-stu-id="40fed-143">*Examples:*</span></span>
  - <span data-ttu-id="40fed-144">@"microsoft.quantum.canon.delay"Åtgärden gör minimala antaganden om inaktuella indatatyper och kan därför användas för att fördröja program för båda driften i Q# standard biblioteket eller som definieras av användarna.</span><span class="sxs-lookup"><span data-stu-id="40fed-144">The @"microsoft.quantum.canon.delay" operation makes minimal assumptions about its input, and thus can be used to delay applications of either operations across the Q# standard library or as defined by users.</span></span>
    <!-- TODO: define bad example. -->

- <span data-ttu-id="40fed-145">✅**Exponerar** rent deterministisk klassisk logik som funktioner i stället för åtgärder.</span><span class="sxs-lookup"><span data-stu-id="40fed-145">✅ **DO** expose purely deterministic classical logic as   as functions rather than operations.</span></span>

  <span data-ttu-id="40fed-146">*Exempel:*</span><span class="sxs-lookup"><span data-stu-id="40fed-146">*Examples:*</span></span>
  - <span data-ttu-id="40fed-147">En subrutin som kvadraterar sin flytt ALS indata kan skrivas deterministiskt och bör därför exponeras för användaren som `Squared : Double -> Double` i stället för en åtgärd `Square : Double => Double` .</span><span class="sxs-lookup"><span data-stu-id="40fed-147">A subroutine which squares its floating-point input can be written deterministically, and so should be exposed to the user as `Squared : Double -> Double` rather than as an operation `Square : Double => Double`.</span></span> <span data-ttu-id="40fed-148">Detta gör att subrutinen kan anropas på fler platser (t. ex. i andra funktioner) och ger användbar optimerings information till kompilatorn som kan påverka prestanda och optimeringar.</span><span class="sxs-lookup"><span data-stu-id="40fed-148">This allows for the subroutine to be called in more places (e.g.: inside of other functions), and provides useful optimization information to the compiler that can affect performance and optimizations.</span></span>
  - <span data-ttu-id="40fed-149">`ForEach<'TInput, 'TOutput>('TInput => 'TOutput, 'TInput[]) => 'TOutput[]` och `Mapped<'TInput, 'TOutput>('TInput -> 'TOutput, 'TInput[]) -> 'TOutput[]` skiljer sig åt i de garantier som gjorts med avseende på determinism. båda är användbara i olika situationer.</span><span class="sxs-lookup"><span data-stu-id="40fed-149">`ForEach<'TInput, 'TOutput>('TInput => 'TOutput, 'TInput[]) => 'TOutput[]` and `Mapped<'TInput, 'TOutput>('TInput -> 'TOutput, 'TInput[]) -> 'TOutput[]` differ in the guarantees made with respect to   determinism; both are useful in different circumstances.</span></span>
  - <span data-ttu-id="40fed-150">API-rutiner som transformerar tillämpningen av Quantum-åtgärder kan ofta utföras på ett deterministiskt sätt och kan därför göras tillgängliga som funktioner som   `CControlled<'T>(op : 'T => Unit) => ((Bool, 'T) => Unit)` .</span><span class="sxs-lookup"><span data-stu-id="40fed-150">API routines that transform the application of quantum   operations can often be carried out in a deterministic     fashion and hence can be made available as functions such as   `CControlled<'T>(op : 'T => Unit) => ((Bool, 'T) => Unit)`.</span></span>

- <span data-ttu-id="40fed-151">✅**Generalisera** indatatypen så mycket som rimligt för varje funktion och åtgärd, med hjälp av typ parametrar efter behov.</span><span class="sxs-lookup"><span data-stu-id="40fed-151">✅ **DO** generalize the input type as much as reasonable for each   function and operation, using type parameters as needed.</span></span>

  <span data-ttu-id="40fed-152">*Exempel:*</span><span class="sxs-lookup"><span data-stu-id="40fed-152">*Examples:*</span></span>
  - <span data-ttu-id="40fed-153">`ApplyToEach` har en typ i `<'T>(('T => Unit), 'T[]) => Unit` stället för den specifika typen för det vanligaste programmet `((Qubit => Unit), Qubit[]) => Unit` .</span><span class="sxs-lookup"><span data-stu-id="40fed-153">`ApplyToEach` has type `<'T>(('T => Unit), 'T[]) => Unit` rather than the specific type of its most common   application, `((Qubit => Unit), Qubit[]) => Unit`.</span></span>

> [!TIP]
> <span data-ttu-id="40fed-154">Det är viktigt att förutse framtida behov, men det är också viktigt att lösa konkreta problem för dina användare.</span><span class="sxs-lookup"><span data-stu-id="40fed-154">It is important to anticipate future needs, but it is also important to solve concrete problems for your users.</span></span>
> <span data-ttu-id="40fed-155">Den här nyckeln kräver sålunda alltid noggranna överväganden och balansering för att undvika att utveckla API: er "i själva fallet".</span><span class="sxs-lookup"><span data-stu-id="40fed-155">Acting on this key principle thus always requires careful consideration and balancing to avoid developing APIs "just in case."</span></span>

<span data-ttu-id="40fed-156">**Nyckel princip:** Välj indata och utdatatyper för funktioner och åtgärder som är förutsägbara och som kommunicerar syftet med ett anrop.</span><span class="sxs-lookup"><span data-stu-id="40fed-156">**Key principle:** choose input and output types for functions and operations that are predictable, and that communicate the purpose of a callable.</span></span>

- <span data-ttu-id="40fed-157">✅**Använd tuple** -typer för att logiskt gruppera indata och utdata som bara är viktiga när de betraktas tillsammans.</span><span class="sxs-lookup"><span data-stu-id="40fed-157">✅ **DO** use tuple types to logically group inputs and outputs that are only significant when considered together.</span></span> <span data-ttu-id="40fed-158">Överväg att använda en användardefinierad typ i dessa fall.</span><span class="sxs-lookup"><span data-stu-id="40fed-158">Consider using a user-defined type in these cases.</span></span>

  <span data-ttu-id="40fed-159">*Exempel:*</span><span class="sxs-lookup"><span data-stu-id="40fed-159">*Examples:*</span></span>
  - <span data-ttu-id="40fed-160">En funktion för att mata ut den lokala minimi för en annan funktion kan behöva ta gränser för ett Sök intervall som indata, som `LocalMinima(fn : (Double -> Double), (left : Double, right : Double)) : Double` kan vara en lämplig signatur.</span><span class="sxs-lookup"><span data-stu-id="40fed-160">A function to output the local minima of another function   may need to take bounds of a search interval as input, such   that `LocalMinima(fn : (Double -> Double), (left : Double, right : Double)) : Double` may be an appropriate signature.</span></span>
  - <span data-ttu-id="40fed-161">En åtgärd för att uppskatta ett derivat av en Machine Learning-klassificerare med parameter Shift-tekniken kan behöva ta både de skiftna och skifta parameter vektorer som indata.</span><span class="sxs-lookup"><span data-stu-id="40fed-161">An operation to estimate a derivative of a machine learning classifier using the parameter shift technique may need to take both the shifted and unshifted parameter vectors as inputs.</span></span> <span data-ttu-id="40fed-162">En indatatyp som liknar `(unshifted : Double[], shifted : Double[])` kan vara lämplig i det här fallet.</span><span class="sxs-lookup"><span data-stu-id="40fed-162">An input similar to `(unshifted : Double[], shifted : Double[])` may be appropriate in this case.</span></span>

- <span data-ttu-id="40fed-163">✅**Ordna objekt** i indata-och utdataström-tupler konsekvent över olika funktioner och åtgärder.</span><span class="sxs-lookup"><span data-stu-id="40fed-163">✅ **DO** order items in input and output tuples consistently   across different functions and operations.</span></span>

  <span data-ttu-id="40fed-164">*Exempel:*</span><span class="sxs-lookup"><span data-stu-id="40fed-164">*Examples:*</span></span>
  - <span data-ttu-id="40fed-165">Om du överväger två eller Functions eller åtgärder som varje tar en rotations vinkel och en mål qubit som indata, kontrollerar du att de är ordnade i varje tupel.</span><span class="sxs-lookup"><span data-stu-id="40fed-165">If considering two or functions or operations that each take a rotation angle and a target qubit as inputs, ensure that they are ordered the same in each input tuple.</span></span> <span data-ttu-id="40fed-166">Det vill säga, hellre `ApplyRotation(angle : Double, target : Qubit) : Unit is Adj + Ctl` och `DelayedRotation(angle : Double, target : Qubit) : (Unit => Unit is Adj + Ctl)` till `ApplyRotation(target : Qubit, angle : Double) : Unit is Adj + Ctl` och `DelayedRotation(angle : Double, target : Qubit) : (Unit => Unit is Adj + Ctl)` .</span><span class="sxs-lookup"><span data-stu-id="40fed-166">That is, prefer `ApplyRotation(angle : Double, target : Qubit) : Unit is Adj + Ctl` and `DelayedRotation(angle : Double, target : Qubit) : (Unit => Unit is Adj + Ctl)` to `ApplyRotation(target : Qubit, angle : Double) : Unit is Adj + Ctl` and `DelayedRotation(angle : Double, target : Qubit) : (Unit => Unit is Adj + Ctl)`.</span></span>

<span data-ttu-id="40fed-167">**Nyckel princip:** design funktioner och åtgärder för att fungera bra med funktioner i Q- \# språk, till exempel delvis program.</span><span class="sxs-lookup"><span data-stu-id="40fed-167">**Key principle:** design functions and operations to work well with Q\# language features such as partial application.</span></span>

- <span data-ttu-id="40fed-168">✅**Sortera objekt** i tupler så att de oftast använda indatana inträffar först (d.v.s.: så att partiella program fungerar på samma sätt som currying).</span><span class="sxs-lookup"><span data-stu-id="40fed-168">✅ **DO** order items in input tuples such that the most commonly   applied inputs occur first (i.e.: so that partial application   acts similarly to currying).</span></span>

  <span data-ttu-id="40fed-169">*Exempel:*</span><span class="sxs-lookup"><span data-stu-id="40fed-169">*Examples:*</span></span>
  - <span data-ttu-id="40fed-170">En åtgärd `ApplyRotation` som tar ett flytt ALS nummer och en qubit som indata kan ofta tillämpas delvis med flytt ALS indata för användning med åtgärder som förväntar sig indata av typen `Qubit => Unit` .</span><span class="sxs-lookup"><span data-stu-id="40fed-170">An operation `ApplyRotation` that takes a floating-point number and a qubit as inputs may often be partially applied with the floating-point input first for use with operations that expect an input of type `Qubit => Unit`.</span></span> <span data-ttu-id="40fed-171">Det innebär att signaturen för `operation ApplyRotation(angle : Double, target : Qubit) : Unit is Adj + Ctl`</span><span class="sxs-lookup"><span data-stu-id="40fed-171">Thus, a signature of `operation ApplyRotation(angle : Double, target : Qubit) : Unit is Adj + Ctl`</span></span>
      <span data-ttu-id="40fed-172">fungerar mest konsekvent med delvis program.</span><span class="sxs-lookup"><span data-stu-id="40fed-172">would work most consistently with partial application.</span></span>
  - <span data-ttu-id="40fed-173">Den här vägledningen innebär vanligt vis att placera alla klassiska data innan alla qubits i indata-tupler, men Använd bra omdöme och kontrol lera hur ditt API anropas i praktiken.</span><span class="sxs-lookup"><span data-stu-id="40fed-173">Typically, this guidance means placing all classical data   before all qubits in input tuples, but use good judgment and   examine how your API is called in practice.</span></span>

## <a name="user-defined-types"></a><span data-ttu-id="40fed-174">User-Defined typer</span><span class="sxs-lookup"><span data-stu-id="40fed-174">User-Defined Types</span></span>

<span data-ttu-id="40fed-175">**Nyckel princip:** Använd användardefinierade typer för att hjälpa till att göra API: er mer lättfattliga programspecifika och bekvämt att använda.</span><span class="sxs-lookup"><span data-stu-id="40fed-175">**Key principle:** use user-defined types to help make APIs more expressive and convenient to use.</span></span>

- <span data-ttu-id="40fed-176">✅**Introducera nya** användardefinierade typer för att ge en bra kort skrift för långa och/eller komplicerade typer.</span><span class="sxs-lookup"><span data-stu-id="40fed-176">✅ **DO** introduce new user-defined types to provide helpful   shorthand for long and/or complicated types.</span></span>

  <span data-ttu-id="40fed-177">*Exempel:*</span><span class="sxs-lookup"><span data-stu-id="40fed-177">*Examples:*</span></span>
  - <span data-ttu-id="40fed-178">I de fall där en åtgärds typ med tre qubit mat ris indata utförs ofta som indata eller returneras som utdata, vilket ger en UDT som `newtype TimeDependentBlockEncoding = ((Qubit[], Qubit[], Qubit[]) => Unit is Adj + Ctl)`</span><span class="sxs-lookup"><span data-stu-id="40fed-178">In cases where an operation type with three qubit array inputs is commonly taken as an input or returned as an output, providing a UDT such as `newtype TimeDependentBlockEncoding = ((Qubit[], Qubit[], Qubit[]) => Unit is Adj + Ctl)`</span></span>
      <span data-ttu-id="40fed-179">kan hjälpa dig att ge en användbar kort skrift.</span><span class="sxs-lookup"><span data-stu-id="40fed-179">can help provide a useful shorthand.</span></span>

- <span data-ttu-id="40fed-180">✅**Introducera nya** användardefinierade typer för att indikera att en viss bastyp endast ska användas i en särskilt idé.</span><span class="sxs-lookup"><span data-stu-id="40fed-180">✅ **DO** introduce new user-defined types to indicate that a given   base type should only be used in a very particular sense.</span></span>

  <span data-ttu-id="40fed-181">*Exempel:*</span><span class="sxs-lookup"><span data-stu-id="40fed-181">*Examples:*</span></span>
  - <span data-ttu-id="40fed-182">En åtgärd som ska tolkas specifikt som en åtgärd som kodar klassiska data till ett Quantum-register kan vara lämplig för etiketter med en användardefinierad typ `newtype InputEncoder = (Apply : (Qubit[] => Unit))` .</span><span class="sxs-lookup"><span data-stu-id="40fed-182">An operation that should be interpreted specifically as an   operation that encodes classical data into a quantum   register may be appropriate to label with a user-defined   type `newtype InputEncoder = (Apply : (Qubit[] => Unit))`.</span></span>

- <span data-ttu-id="40fed-183">✅**Introducera nya** användardefinierade typer med namngivna objekt som möjliggör framtida utökning (t. ex. en resultat struktur som kan innehålla ytterligare namngivna objekt i framtiden).</span><span class="sxs-lookup"><span data-stu-id="40fed-183">✅ **DO** introduce new user-defined types with named items that   allow for future extensibility (e.g.: a results structure that   may contain additional named items in the future).</span></span>

  <span data-ttu-id="40fed-184">*Exempel:*</span><span class="sxs-lookup"><span data-stu-id="40fed-184">*Examples:*</span></span>
  - <span data-ttu-id="40fed-185">När en åtgärd `TrainModel` visar ett stort antal konfigurations alternativ, exponeras dessa alternativ som en ny   `TrainingOptions` UDT och en ny funktion gör det   `DefaultTrainingOptions : Unit -> TrainingOptions` möjligt för användare att åsidosätta vissa namngivna objekt i TrainingOptions UDT-värden samtidigt som biblioteks utvecklare kan lägga till nya UDT-objekt efter behov.</span><span class="sxs-lookup"><span data-stu-id="40fed-185">When an operation `TrainModel` exposes a large number of   configuration options, exposing these options as a new   `TrainingOptions` UDT and providing a new function   `DefaultTrainingOptions : Unit -> TrainingOptions` allows   users to override specific named items in TrainingOptions   UDT values while still allowing library developers to add   new UDT items as appropriate.</span></span>

- <span data-ttu-id="40fed-186">✅**Deklarera namngivna** objekt för nya användardefinierade typer i prioritetsordning för att kräva att användarna känner till rätt tuple-inkonstruktion.</span><span class="sxs-lookup"><span data-stu-id="40fed-186">✅ **DO** declare named items for new user-defined types in   preference to requiring users to know the correct tuple   deconstruction.</span></span>

  <span data-ttu-id="40fed-187">*Exempel:*</span><span class="sxs-lookup"><span data-stu-id="40fed-187">*Examples:*</span></span>
  - <span data-ttu-id="40fed-188">När du representerar ett komplext tal i dess polära dekomposition föredrar   `newtype ComplexPolar = (Magnitude: Double, Argument: Double)` du   `newtype ComplexPolar = (Double, Double)` .</span><span class="sxs-lookup"><span data-stu-id="40fed-188">When representing a complex number in its polar   decomposition, prefer   `newtype ComplexPolar = (Magnitude: Double, Argument: Double)` to   `newtype ComplexPolar = (Double, Double)`.</span></span>

<span data-ttu-id="40fed-189">**Nyckel princip:** Använd användardefinierade typer på olika sätt för att minska kognitiv belastning och som inte kräver att användaren lär sig ytterligare begrepp och nomenklatur.</span><span class="sxs-lookup"><span data-stu-id="40fed-189">**Key principle:** use user-defined types in ways reduce  cognitive load and that don't require the user to learn additional concepts and nomenclature.</span></span>

- <span data-ttu-id="40fed-190">⛔️ introducerar **inte** användardefinierade typer som kräver att användaren ofta använder sig av unwrap-operatorn ( `!` ), eller som ofta kräver flera nivåer av avbrytning.</span><span class="sxs-lookup"><span data-stu-id="40fed-190">⛔️ **DON'T** introduce user-defined types that require the user to make frequent use of the unwrap operator (`!`), or that commonly require multiple levels of unwrapping.</span></span> <span data-ttu-id="40fed-191">Några möjliga lösningar för minskning är:</span><span class="sxs-lookup"><span data-stu-id="40fed-191">Possible mitigation strategies include:</span></span>

  - <span data-ttu-id="40fed-192">När du exponerar en användardefinierad typ med ett enda objekt bör du överväga att definiera ett namn för objektet.</span><span class="sxs-lookup"><span data-stu-id="40fed-192">When exposing a user-defined type with a single item, consider defining a name for that item.</span></span> <span data-ttu-id="40fed-193">Tänk `newtype Encoder = (Apply : (Qubit[] => Unit is Adj + Ctl))` till exempel i preferens till `newtype Encoder = (Qubit[] => Unit is Adj + Ctl)` .</span><span class="sxs-lookup"><span data-stu-id="40fed-193">For instance, consider `newtype Encoder = (Apply : (Qubit[] => Unit is Adj + Ctl))` in preference to `newtype Encoder = (Qubit[] => Unit is Adj + Ctl)`.</span></span>

  - <span data-ttu-id="40fed-194">Att se till att andra funktioner och åtgärder kan acceptera "figursatta" UDT-instanser direkt.</span><span class="sxs-lookup"><span data-stu-id="40fed-194">Ensuring that other functions and operations can accept   "wrapped" UDT instances directly.</span></span>

- <span data-ttu-id="40fed-195">⛔️ introducerar **inte** nya användardefinierade typer som duplicerar inbyggda typer utan att tillhandahålla ytterligare Expressiveness.</span><span class="sxs-lookup"><span data-stu-id="40fed-195">⛔️ **DON'T** introduce new user-defined types that duplicate   built-in types without providing additional expressiveness.</span></span>

  <span data-ttu-id="40fed-196">*Exempel:*</span><span class="sxs-lookup"><span data-stu-id="40fed-196">*Examples:*</span></span>
  - <span data-ttu-id="40fed-197">En UDT `newtype QubitRegister = Qubit[]` ger ingen ytterligare Expressiveness över `Qubit[]` , och är därför svårare att använda utan går-förmån.</span><span class="sxs-lookup"><span data-stu-id="40fed-197">A UDT `newtype QubitRegister = Qubit[]` provides no   additional expressiveness over `Qubit[]`, and is thus harder   to use with no discernable benefit.</span></span>
  - <span data-ttu-id="40fed-198">En UDT `newtype LittleEndian = Qubit[]` -dokument beskriver hur det underliggande registret ska användas och tolkas och ger därmed ytterligare Expressiveness över dess bastyp.</span><span class="sxs-lookup"><span data-stu-id="40fed-198">A UDT `newtype LittleEndian = Qubit[]` documents how the   underlying register is to be used and interpreted, and thus   provides additional expressiveness over its base type.</span></span>

- <span data-ttu-id="40fed-199">⛔️ introducerar **inte** accessor-funktioner om det inte är absolut nödvändigt.   föredra namngivna objekt i det här fallet.</span><span class="sxs-lookup"><span data-stu-id="40fed-199">⛔️ **DON'T** introduce accessor functions unless strictly required;   strongly prefer named items in this case.</span></span>

  <span data-ttu-id="40fed-200">*Exempel:*</span><span class="sxs-lookup"><span data-stu-id="40fed-200">*Examples:*</span></span>
  - <span data-ttu-id="40fed-201">När du introducerar en UDT `newtype Complex = (Double, Double)` , föredrar du att ändra definitionen till   `newtype Complex = (Real : Double, Imag : Double)` att introducera funktioner `GetReal : Complex -> Double` och   `GetImag : Complex -> Double` .</span><span class="sxs-lookup"><span data-stu-id="40fed-201">When introducing a UDT `newtype Complex = (Double, Double)`,   prefer modifying the definition to   `newtype Complex = (Real : Double, Imag : Double)` to introducing   functions `GetReal : Complex -> Double` and   `GetImag : Complex -> Double`.</span></span>

## <a name="namespaces-and-organization"></a><span data-ttu-id="40fed-202">Namn områden och organisation</span><span class="sxs-lookup"><span data-stu-id="40fed-202">Namespaces and Organization</span></span>

<span data-ttu-id="40fed-203">**Nyckel princip:** Välj namn områdes namn som är förutsägbara och som tydligt kommunicerar syftet med funktioner, åtgärder och användardefinierade typer i varje namnrymd.</span><span class="sxs-lookup"><span data-stu-id="40fed-203">**Key principle:** choose namespace names that are predictable and that clearly communicate the purpose of functions, operations, and user-defined types in each namespace.</span></span>

- <span data-ttu-id="40fed-204">✅**Gör** namn namn rymder som `Publisher.Product.DomainArea` .</span><span class="sxs-lookup"><span data-stu-id="40fed-204">✅ **DO** name namespaces as `Publisher.Product.DomainArea`.</span></span>

  <span data-ttu-id="40fed-205">*Exempel:*</span><span class="sxs-lookup"><span data-stu-id="40fed-205">*Examples:*</span></span>
  - <span data-ttu-id="40fed-206">Funktioner, åtgärder och UDTs som publiceras av Microsoft som en del av funktionen Quantum-simulering i Quantum Development Kit placeras i   `Microsoft.Quantum.Simulation` namn området.</span><span class="sxs-lookup"><span data-stu-id="40fed-206">Functions, operations, and UDTs published by Microsoft as a   part of the quantum simulation feature of the Quantum   Development Kit are placed in the   `Microsoft.Quantum.Simulation` namespace.</span></span>
  - <span data-ttu-id="40fed-207">`Microsoft.Quantum.Math` representerar ett namn område som publicerats av Microsoft som en del av Quantum Development Kit som hör till området matematik.</span><span class="sxs-lookup"><span data-stu-id="40fed-207">`Microsoft.Quantum.Math` represents a namespace   published by Microsoft as part of the Quantum Development   Kit pertaining to the mathematics domain area.</span></span>

- <span data-ttu-id="40fed-208">✅**Utför** åtgärder, funktioner och användardefinierade typer som används för vissa funktioner i ett namn område som beskriver den funktionen, även när funktionen används i olika problem domäner.</span><span class="sxs-lookup"><span data-stu-id="40fed-208">✅ **DO** place operations, functions, and user-defined types used   for specific functionality into a namespace that describes that   functionality, even when that functionality is used across   different problem domains.</span></span>

  <span data-ttu-id="40fed-209">*Exempel:*</span><span class="sxs-lookup"><span data-stu-id="40fed-209">*Examples:*</span></span>
  - <span data-ttu-id="40fed-210">API: er för tillstånds förberedelse som publicerats av Microsoft som en del av Quantum Development Kit skulle placeras i   `Microsoft.Quantum.Preparation` .</span><span class="sxs-lookup"><span data-stu-id="40fed-210">State preparation APIs published by Microsoft as a part of   the Quantum Development Kit would be placed into   `Microsoft.Quantum.Preparation`.</span></span>
  - <span data-ttu-id="40fed-211">API: er för Quantum simulator som publicerats av Microsoft som en del av Quantum Development Kit skulle placeras i   `Microsoft.Quantum.Simulation` .</span><span class="sxs-lookup"><span data-stu-id="40fed-211">Quantum simulation APIs published by Microsoft as a part of the Quantum   Development Kit would be placed into   `Microsoft.Quantum.Simulation`.</span></span>

- <span data-ttu-id="40fed-212">✅**Utför** åtgärder, funktioner och användardefinierade typer som enbart används inom vissa domäner i namn områden som indikerar deras domän.</span><span class="sxs-lookup"><span data-stu-id="40fed-212">✅ **DO** place operations, functions, and user-defined types used only within specific domains into namespaces indicating their domain of utility.</span></span> <span data-ttu-id="40fed-213">Om det behövs använder du under namn rymder för att indikera fokuserade uppgifter inom varje domänbaserat namn område.</span><span class="sxs-lookup"><span data-stu-id="40fed-213">If needed, use subnamespaces to indicate focused tasks within each domain-specific namespace.</span></span>

  <span data-ttu-id="40fed-214">*Exempel:*</span><span class="sxs-lookup"><span data-stu-id="40fed-214">*Examples:*</span></span>
  - <span data-ttu-id="40fed-215">Quantum Machine Learning-biblioteket som publicerades av Microsoft placeras i stort sett i @"microsoft.quantum.machinelearning" namn området, men exempel data uppsättningar tillhandahålls av @"microsoft.quantum.machinelearning.datasets"   namn området.</span><span class="sxs-lookup"><span data-stu-id="40fed-215">The quantum machine learning library published by Microsoft is largely   placed into the @"microsoft.quantum.machinelearning" namespace, but example   datasets are provided by the @"microsoft.quantum.machinelearning.datasets"   namespace.</span></span>
  - <span data-ttu-id="40fed-216">Quantum kemi-API: er som publicerats av Microsoft som en del av Quantum Development Kit bör placeras i `Microsoft.Quantum.Chemistry` .</span><span class="sxs-lookup"><span data-stu-id="40fed-216">Quantum chemistry APIs published by Microsoft as a part of the Quantum Development Kit should be placed into `Microsoft.Quantum.Chemistry`.</span></span> <span data-ttu-id="40fed-217">Funktioner som är speciella för att implementera Jordanien-Wigner-dekompositionen kan placeras i `Microsoft.Quantum.Chemistry.JordanWigner` , så att det primära gränssnittet för domän arean Quantum kemi inte är bekymrat till implementeringar.</span><span class="sxs-lookup"><span data-stu-id="40fed-217">Functionality specific to implementing the Jordan--Wigner decomposition may be placed in `Microsoft.Quantum.Chemistry.JordanWigner`, so that the primary interface for the quantum chemistry domain area is not concerned with implementations.</span></span>

<span data-ttu-id="40fed-218">**Nyckel princip:** Använd namn rymder och åtkomst modifierare för att vara avsiktliga om den API-yta som visas för användarna och för att dölja intern information som rör implementering och testning av dina API: er.</span><span class="sxs-lookup"><span data-stu-id="40fed-218">**Key principle:** Use namespaces and access modifiers together to be intentional about the API surface exposed to users, and to hide internal details related to implementation and testing of your APIs.</span></span>

- <span data-ttu-id="40fed-219">✅ När det är rimligt bör **du** placera alla funktioner och åtgärder som behövs för att implementera ett API i samma namnrymd som API: et som implementeras, men markerat med nyckelorden "privat" eller "internt" för att ange att de inte ingår i den offentliga API-ytan för ett bibliotek.</span><span class="sxs-lookup"><span data-stu-id="40fed-219">✅ Whenever reasonable, **DO** place all functions and operations needed to implement an API into the same namespace as the API being implemented, but marked with the "private" or "internal" keywords to indicate that they are not part of the public API surface for a library.</span></span> <span data-ttu-id="40fed-220">Använd ett namn som börjar med ett under streck ( `_` ) för att visuellt särskilja privata och interna åtgärder och funktioner från offentliga callables.</span><span class="sxs-lookup"><span data-stu-id="40fed-220">Use a name beginning with an underscore (`_`) to visually distinguish private and internal operations and functions from public callables.</span></span>

  <span data-ttu-id="40fed-221">*Exempel:*</span><span class="sxs-lookup"><span data-stu-id="40fed-221">*Examples:*</span></span>
  - <span data-ttu-id="40fed-222">Åtgärds namnet `_Features` anger en funktion som är privat för en specifik namnrymd och sammansättning och som ska åtföljas av antingen `internal` nyckelordet.</span><span class="sxs-lookup"><span data-stu-id="40fed-222">The operation name `_Features` indicates a function that is   private to a given namespace and assembly, and should be   accompanied by either the `internal` keyword.</span></span>

- <span data-ttu-id="40fed-223">✅ I sällsynta fall kan en omfattande uppsättning privata funktioner eller åtgärder behövas för att implementera API: et för ett angivet namn område **, placera** dem i ett nytt namn område som matchar namn området som implementeras och slutar `.Private` .</span><span class="sxs-lookup"><span data-stu-id="40fed-223">✅ In the rare case that an extensive set of private functions or operations are needed to implement the API for a given namespace, **DO** place them in a new namespace matching the namespace being implemented and ending in `.Private`.</span></span>

- <span data-ttu-id="40fed-224">✅**Placera alla** enhets tester i namn områden som matchar namn området under test och slutar `.Tests` .</span><span class="sxs-lookup"><span data-stu-id="40fed-224">✅ **DO** place all unit tests into namespaces matching the     namespace under test and ending in `.Tests`.</span></span>

## <a name="naming-conventions-and-vocabulary"></a><span data-ttu-id="40fed-225">Namngivnings konventioner och vokabulär</span><span class="sxs-lookup"><span data-stu-id="40fed-225">Naming Conventions and Vocabulary</span></span>

<span data-ttu-id="40fed-226">**Nyckel princip:** Välj namn och terminologi som är tydliga, tillgängliga och läsbara i flera olika mål grupper, inklusive både Quantum Novices och experter.</span><span class="sxs-lookup"><span data-stu-id="40fed-226">**Key principle:** Choose names and terminology that are clear, accessible, and readable across a diverse range of audiences, including both quantum novices and experts.</span></span>

- <span data-ttu-id="40fed-227">⛔️ **inte** använda diskriminerande eller undantags identifierare, eller terminologi i kommentarer för API-dokumentation.</span><span class="sxs-lookup"><span data-stu-id="40fed-227">⛔️ **DON'T** use discriminatory or exclusionary identifier names,   nor terminology in API documentation comments.</span></span>

- <span data-ttu-id="40fed-228">✅**Använd kommentarer** i API-dokumentation för att tillhandahålla relevant kontext, exempel och referenser, särskilt för svårare koncept.</span><span class="sxs-lookup"><span data-stu-id="40fed-228">✅ **DO** use API documentation comments to provide relevant   context, examples, and references, especially for more difficult   concepts.</span></span>

- <span data-ttu-id="40fed-229">⛔️ **inte** använda ID-namn som inte är nödvändigt för Esoteric, eller som kräver betydande Quantum-algoritmer att läsa.</span><span class="sxs-lookup"><span data-stu-id="40fed-229">⛔️ **DON'T** use identifier names that are unnecessarily esoteric,   or that require significant quantum algorithms knowledge to   read.</span></span>

  <span data-ttu-id="40fed-230">*Exempel:*</span><span class="sxs-lookup"><span data-stu-id="40fed-230">*Examples:*</span></span>
  - <span data-ttu-id="40fed-231">Föredra "amplitud förstärkning iteration" till "Grover iteration".</span><span class="sxs-lookup"><span data-stu-id="40fed-231">Prefer "amplitude amplification iteration" to "Grover   iteration."</span></span>

- <span data-ttu-id="40fed-232">✅**Välj drift** -och funktions namn som tydligt förmedlar den avsedda påverkan av en anropad och inte dess implementering.</span><span class="sxs-lookup"><span data-stu-id="40fed-232">✅ **DO** choose operations and function names that clearly communicate the intended effect of a callable, and not its implementation.</span></span> <span data-ttu-id="40fed-233">Observera att implementeringen kan och bör dokumenteras i [kommentarer om API-dokumentation](xref:microsoft.quantum.qsharp.comments#documentation-comments).</span><span class="sxs-lookup"><span data-stu-id="40fed-233">Note that the implementation can and should be documented in [API documentation comments](xref:microsoft.quantum.qsharp.comments#documentation-comments).</span></span>

  <span data-ttu-id="40fed-234">*Exempel:*</span><span class="sxs-lookup"><span data-stu-id="40fed-234">*Examples:*</span></span>
  - <span data-ttu-id="40fed-235">Föredra "uppskatta överlappande" till "Hadamard test", eftersom den senare kommunicerar hur den tidigare implementeras.</span><span class="sxs-lookup"><span data-stu-id="40fed-235">Prefer "estimate overlap" to "Hadamard test," as the latter   communicates how the former is implemented.</span></span>

- <span data-ttu-id="40fed-236">✅**Använd ord** på ett konsekvent sätt i alla \# API: er för Q:</span><span class="sxs-lookup"><span data-stu-id="40fed-236">✅ **DO** use words in a consistent fashion across all Q\# APIs:</span></span>

  - <span data-ttu-id="40fed-237">**Verb**</span><span class="sxs-lookup"><span data-stu-id="40fed-237">**Verbs:**</span></span>

    - <span data-ttu-id="40fed-238">**Assert**: kontrol lera att ett antagande om status för en måldator och dess qubits innehåller, möjligen med hjälp av fysiska resurser.</span><span class="sxs-lookup"><span data-stu-id="40fed-238">**Assert**: Check that an assumption about the state of a target machine and its qubits holds, possibly by using unphysical resources.</span></span> <span data-ttu-id="40fed-239">Åtgärder som använder det här verbet bör alltid vara säkert flyttbara utan att det påverkar funktionerna i bibliotek och körbara program.</span><span class="sxs-lookup"><span data-stu-id="40fed-239">Operations using this verb should always be safely removable without affecting the functionality of libraries and executable programs.</span></span> <span data-ttu-id="40fed-240">Observera att till skillnad från fakta, i allmänhet, är beroende av externt tillstånd, t. ex. status för ett qubit register, körnings miljön eller så vidare.</span><span class="sxs-lookup"><span data-stu-id="40fed-240">Note that unlike facts, assertions may, in general, depend on external state, such as the state of a qubit register, the run environment or so forth.</span></span> <span data-ttu-id="40fed-241">Som beroende av extern status är en typ av sido effekt, och försäkrar måste visas som åtgärder i stället för functions.</span><span class="sxs-lookup"><span data-stu-id="40fed-241">As dependency on external state is a kind of side effect, assertions must be exposed as operations rather than functions.</span></span>

    - <span data-ttu-id="40fed-242">**Uppskattning**: Använd en eller flera eventuellt upprepade mätningar för att beräkna en klassisk kvantitet från mätnings resultaten.</span><span class="sxs-lookup"><span data-stu-id="40fed-242">**Estimate**: Using one or more possibly repeated   measurements, estimate a classical quantity from   measurement results.</span></span>

      <span data-ttu-id="40fed-243">*Exempel:*</span><span class="sxs-lookup"><span data-stu-id="40fed-243">*Examples:*</span></span>
      - @"microsoft.quantum.characterization.estimatefrequency"
      - @"microsoft.quantum.characterization.estimateoverlapbetweenstates"

    - <span data-ttu-id="40fed-244">**Förbered**: tillämpa en Quantum-åtgärd eller en sekvens med åtgärder för en eller flera qubits som antas starta i ett visst ursprungligt tillstånd (vanligt vis $ \ket{00\cdots 0), vilket gör att tillstånden för dessa qubits utvecklas till ett önskat slut tillstånd.</span><span class="sxs-lookup"><span data-stu-id="40fed-244">**Prepare**: Apply a quantum operation or sequence of operations to one or more qubits assumed to start in a particular initial state (typically $\ket{00\cdots 0}$), causing the state of those qubits to evolve to a desired end state.</span></span> <span data-ttu-id="40fed-245">I allmänhet **kan** man på andra stater än det som anges i andra länder leda till en odefinierad allmän omvandling, men **bör** fortfarande bevara en åtgärd och dess angränsande "annullera ut" och tillämpa en no-op.</span><span class="sxs-lookup"><span data-stu-id="40fed-245">In general, acting on states other than the given starting state **MAY** result in an undefined unitary transformation, but **SHOULD** still preserve that an operation and its adjoint "cancel out" and apply a no-op.</span></span>

      <span data-ttu-id="40fed-246">*Exempel:*</span><span class="sxs-lookup"><span data-stu-id="40fed-246">*Examples:*</span></span>
      - @"microsoft.quantum.preparation.preparearbitrarystate"
      - @"microsoft.quantum.preparation.prepareuniformsuperposition"

    - <span data-ttu-id="40fed-247">**Mått**: tillämpa en Quantum-åtgärd eller en sekvens med åtgärder för en eller flera qubits, och Läs sedan ut klassiska data.</span><span class="sxs-lookup"><span data-stu-id="40fed-247">**Measure**: Apply a quantum operation or sequence of   operations to one or more qubits, reading classical data   back out.</span></span>

      <span data-ttu-id="40fed-248">*Exempel:*</span><span class="sxs-lookup"><span data-stu-id="40fed-248">*Examples:*</span></span>
      - @"Microsoft.Quantum.Intrinsic.Measure"
      - @"microsoft.quantum.arithmetic.measurefxp"
      - @"microsoft.quantum.arithmetic.measureinteger"

    - <span data-ttu-id="40fed-249">**Tillämpa**: tillämpa en Quantum-åtgärd eller en sekvens med åtgärder på en eller flera qubits, vilket gör att qubits ändras på ett konsekvent sätt.</span><span class="sxs-lookup"><span data-stu-id="40fed-249">**Apply**: Apply a quantum operation or sequence of operations to one or more qubits, causing the state of those qubits to change in a coherent fashion.</span></span> <span data-ttu-id="40fed-250">Det här verbet är det mest generella verbet i Q \# -nomenklaturen och **bör inte** användas när ett mer särskilt verb är direkt relevant.</span><span class="sxs-lookup"><span data-stu-id="40fed-250">This verb is the most general verb in Q\# nomenclature, and **SHOULD NOT BE** used when a more specific verb is more directly relevant.</span></span>

  - <span data-ttu-id="40fed-251">**Substantiv**:</span><span class="sxs-lookup"><span data-stu-id="40fed-251">**Nouns**:</span></span>

    - <span data-ttu-id="40fed-252">**Fakta**: ett booleskt villkor som bara är beroende av sina indata och inte på en måldators tillstånd, dess miljö eller tillståndet för datorns qubits.</span><span class="sxs-lookup"><span data-stu-id="40fed-252">**Fact**: A Boolean condition which depends only on its inputs and not on the state of a target machine, its environment, or the state of the machine's qubits.</span></span> <span data-ttu-id="40fed-253">Till skillnad från en försäkran är ett faktum bara känsligt för de *värden* som anges i detta faktum.</span><span class="sxs-lookup"><span data-stu-id="40fed-253">By contrast with an assertion, a fact is only sensitive to the *values* provided to that fact.</span></span> <span data-ttu-id="40fed-254">Exempel:</span><span class="sxs-lookup"><span data-stu-id="40fed-254">For example:</span></span>

      <span data-ttu-id="40fed-255">*Exempel:*</span><span class="sxs-lookup"><span data-stu-id="40fed-255">*Examples:*</span></span>
      - <span data-ttu-id="40fed-256">@"microsoft.quantum.diagnostics.equalityfacti": representerar ett likhets faktum mellan två heltals indata; antingen är de heltal som anges som indata lika med varandra, eller inte, oberoende av andra program tillstånd.</span><span class="sxs-lookup"><span data-stu-id="40fed-256">@"microsoft.quantum.diagnostics.equalityfacti": represents an equality fact about two integer inputs; either the integers provided as input are equal to each other, or they are not, independent of any other program state.</span></span>

    - <span data-ttu-id="40fed-257">**Alternativ:** En UDT som innehåller flera namngivna objekt som kan fungera som valfria argument till en funktion eller åtgärd.</span><span class="sxs-lookup"><span data-stu-id="40fed-257">**Options:** A UDT containing several named items that can act as "optional arguments" to a function or operation.</span></span> <span data-ttu-id="40fed-258">Exempel:</span><span class="sxs-lookup"><span data-stu-id="40fed-258">For example:</span></span>

      <span data-ttu-id="40fed-259">*Exempel:*</span><span class="sxs-lookup"><span data-stu-id="40fed-259">*Examples:*</span></span>
      - <span data-ttu-id="40fed-260">@"microsoft.quantum.machinelearning.trainingoptions"UDT innehåller namngivna objekt för inlärnings pris, minibatch storlek och andra konfigurerbara parametrar för ml-utbildning.</span><span class="sxs-lookup"><span data-stu-id="40fed-260">The @"microsoft.quantum.machinelearning.trainingoptions" UDT includes named items for learning rate, minibatch size, and other configurable parameters for ML training.</span></span>

  - <span data-ttu-id="40fed-261">**Adjektiv**:</span><span class="sxs-lookup"><span data-stu-id="40fed-261">**Adjectives**:</span></span>

    - <span data-ttu-id="40fed-262">⛔️ **nytt**: denna ADJEKTIV **bör inte** användas, för att undvika förvirring med användning som ett verb i många programmeringsspråk (t. ex.: C++, C#, Java, typescript, PowerShell).</span><span class="sxs-lookup"><span data-stu-id="40fed-262">⛔️ **New**: This adjective **SHOULD NOT** be used, as to avoid confusion   with its usage as a verb in many   programming languages (e.g.: C++, C#, Java, TypeScript, PowerShell).</span></span>

  - <span data-ttu-id="40fed-263">**Förpositioner:** I vissa fall kan förpositioner användas för att ytterligare disambiguate eller för tydliga roller i Substantiv och verb i funktions-och åtgärds namn.</span><span class="sxs-lookup"><span data-stu-id="40fed-263">**Prepositions:** In some cases, prepositions can be used to further disambiguate or clarify the roles of nouns and verbs in function and operation names.</span></span> <span data-ttu-id="40fed-264">Bryr dig om att göra detta sparsamt och konsekvent.</span><span class="sxs-lookup"><span data-stu-id="40fed-264">Care should be taken to do so sparingly and consistently, however.</span></span>

    - <span data-ttu-id="40fed-265">**Som:** Visar att en funktions indata och utdata representerar samma information, men att utdata representerar den informationen **som** ett *X* i stället för den ursprungliga representationen.</span><span class="sxs-lookup"><span data-stu-id="40fed-265">**As:** Represents that a function's input and output represent the same information, but that the output represents that information **as** an *X* instead of its original representation.</span></span> <span data-ttu-id="40fed-266">Detta är särskilt vanligt för typ konverterings funktioner.</span><span class="sxs-lookup"><span data-stu-id="40fed-266">This is especially common for type conversion functions.</span></span>

      <span data-ttu-id="40fed-267">*Exempel:*</span><span class="sxs-lookup"><span data-stu-id="40fed-267">*Examples:*</span></span>
      - <span data-ttu-id="40fed-268">`IntAsDouble(2)` anger att både indata ( `2` ) och utdata ( `2.0` ) representerar samma information, men använder olika frågor \# för att göra detta.</span><span class="sxs-lookup"><span data-stu-id="40fed-268">`IntAsDouble(2)` indicates that both the input (`2`) and the output (`2.0`)   represent qualitatively the same information, but using   different Q\# data types to do so.</span></span>

    - <span data-ttu-id="40fed-269">**Från:** För att säkerställa konsekvens   **bör** denna förposition inte användas för att indikera typ konverterings funktioner eller andra **fall där det** är lämpligt.</span><span class="sxs-lookup"><span data-stu-id="40fed-269">**From:** To ensure consistency, this preposition   **SHOULD NOT** be used to indicate type conversion   functions or any other case where **As** is appropriate.</span></span>

    - <span data-ttu-id="40fed-270">⛔️ **till:** den här förpositionen **bör inte** användas för att undvika förvirring med användning som ett verb i flera programmeringsspråk.</span><span class="sxs-lookup"><span data-stu-id="40fed-270">⛔️ **To:** This preposition **SHOULD NOT** be used, as to   avoid confusion with its usage as a verb in many   programming languages.</span></span>
