---
title: Introduktion till Quantum Development-metoder | Microsoft Docs
description: Introduktion till Quantum Development-metoder
author: QuantumWriter
ms.author: Christopher.Granade@microsoft.com
ms.date: 12/11/2017
ms.topic: article
ms.openlocfilehash: 702d23293a1c340ddd3d7032d0e05294345469b2
ms.sourcegitcommit: aa5e6f4a2deb4271a333d3f1b1eb69b5bb9a7bad
ms.translationtype: MT
ms.contentlocale: sv-SE
ms.lasthandoff: 11/02/2019
ms.locfileid: "73442564"
---
# <a name="q-program-overview"></a><span data-ttu-id="26aec-103">Översikt över Q # program</span><span class="sxs-lookup"><span data-stu-id="26aec-103">Q# program overview</span></span>

<span data-ttu-id="26aec-104">Q # är ett skalbart, beskärmat programmeringsspråk för flera paradigm för Quantum Computing.</span><span class="sxs-lookup"><span data-stu-id="26aec-104">Q# is a scalable, multi-paradigm, domain-specific programming language for quantum computing.</span></span> <span data-ttu-id="26aec-105">Q # är ett Quantum-programmeringsspråk där det kan användas för att beskriva hur instruktioner körs på Quantum Machines.</span><span class="sxs-lookup"><span data-stu-id="26aec-105">Q# is a quantum programming language in that it can be used to describe how instructions are executed on quantum machines.</span></span> <span data-ttu-id="26aec-106">De datorer som kan vara riktade till den faktiska Quantum-maskinvaran.</span><span class="sxs-lookup"><span data-stu-id="26aec-106">The machines that can be targeted range from simulators to actual quantum hardware.</span></span> <span data-ttu-id="26aec-107">Q # är skalbart: det kan användas för att skriva enkla demonstrations program, t. ex. teleport som körs på några qubits, men som också har stöd för skrivning av stora, sofistikerade program som simulering av komplexa molekyler som kräver stora datorer med miljon tals qubits.</span><span class="sxs-lookup"><span data-stu-id="26aec-107">Q# is scalable: it can be used to write simple demonstration programs like teleport that run on a few qubits, but also supports writing large, sophisticated programs such as simulations of complex molecules that will require large machines with millions of qubits.</span></span> <span data-ttu-id="26aec-108">Även om stora fysiska datorer fortfarande är i framtiden, tillåter Q # att en programmerare programmerar komplexa Quantum-algoritmer nu.</span><span class="sxs-lookup"><span data-stu-id="26aec-108">Even though large physical machines are still in the future, Q# allows a programmer to program complex quantum algorithms now.</span></span> <span data-ttu-id="26aec-109">Vad är mer, Q # stöder olika uppgifter som fel sökning, profilering, resurs uppskattning och vissa simuleringar av särskilda ändamål på ett skalbart sätt.</span><span class="sxs-lookup"><span data-stu-id="26aec-109">What is more, Q# supports various tasks such as debugging, profiling, resource estimation, and certain special-purpose simulations in a scalable way.</span></span> 

<span data-ttu-id="26aec-110">Från ett tekniskt perspektiv kan ett Quantum-program ses som en viss uppsättning klassiska funktioner som, när de anropas, genererar Quantum-kretsar som deras sido effekter.</span><span class="sxs-lookup"><span data-stu-id="26aec-110">From a technical perspective, a quantum program can be seen as a particular set of classical functions which, when called, generate quantum circuits as their side effects.</span></span> <span data-ttu-id="26aec-111">En viktig följd av den vyn är att ett program som skrivits i Q # inte direkt modellerar qubits själva, utan beskriver i stället hur en klassisk kontroll dator interagerar med dessa qubits.</span><span class="sxs-lookup"><span data-stu-id="26aec-111">An important consequence of that view is that a program written in Q# does not directly model qubits themselves, but rather describes how a classical control computer interacts with those qubits.</span></span>
<span data-ttu-id="26aec-112">Enligt design definierar Q # alltså inte Quantum-tillstånd eller andra egenskaper för Quantum Mechanics direkt, utan i stället indirekt genom åtgärden för de olika under rutiner som definierats på språket.</span><span class="sxs-lookup"><span data-stu-id="26aec-112">By design, Q# thus does not define quantum states or other properties of quantum mechanics directly, but rather does so indirectly through the action of the various subroutines defined in the language.</span></span>
<span data-ttu-id="26aec-113">Anta till exempel att State $ \ket{+} = \left (\ket{0} + \ket{1}\right)/\sqrt{2}$ beskrivs i instruktionen [Quantum Computing Concepts](xref:microsoft.quantum.concepts.intro) .</span><span class="sxs-lookup"><span data-stu-id="26aec-113">For instance, consider the state $\ket{+} = \left(\ket{0} + \ket{1}\right) / \sqrt{2}$ discussed in the [Quantum Computing Concepts](xref:microsoft.quantum.concepts.intro) guide.</span></span>
<span data-ttu-id="26aec-114">För att förbereda detta tillstånd i Q #, använder vi de fakta som qubits initieras i $ \ket{0}$ State och att $ \ket{+} = H\ket{0}$, där $H $ är Hadamard-transformeringen:</span><span class="sxs-lookup"><span data-stu-id="26aec-114">To prepare this state in Q#, we use the facts that the qubits are initialized in the $\ket{0}$ state, and that $\ket{+} = H\ket{0}$, where $H$ is the Hadamard transform:</span></span>

```qsharp
using (qubit = Qubit()) {
    // At this point, qubit is in the state |0〉.
    H(qubit);
    // We've now applied H, such that our qubit is in H|0〉 = |+〉, as we wanted.
}
```
## <a name="q-tranformations-of-quantum-states"></a><span data-ttu-id="26aec-115">Q # tranformations av Quantum-tillstånd</span><span class="sxs-lookup"><span data-stu-id="26aec-115">Q# tranformations of quantum states</span></span>

<span data-ttu-id="26aec-116">Det är viktigt att i Skriv programmet ovan inte uttryckligen referera till statusen inom Q #, utan att i stället se hur tillstånd har *omvandlats* av vårt program.</span><span class="sxs-lookup"><span data-stu-id="26aec-116">Importantly, in writing the above program, we did not explicitly refer to the state within Q#, but rather described how the state was *transformed* by our program.</span></span>
<span data-ttu-id="26aec-117">På samma sätt som när ett grafik shader-program samlar in en beskrivning av omvandlingar till varje hörn, ackumulerar ett Quantum-program i Q # omvandlingar till Quantum-tillstånd.</span><span class="sxs-lookup"><span data-stu-id="26aec-117">Thus, similar to how a graphics shader program accumulates a description of transformations to each vertex, a quantum program in Q# accumulates transformations to quantum states.</span></span>
<span data-ttu-id="26aec-118">På så sätt kan vi helt oberoende om vad ett Quantum-tillstånd *är* även på varje måldator, vilket kan ha olika tolkningar beroende på datorn.</span><span class="sxs-lookup"><span data-stu-id="26aec-118">This allows us to be entirely agnostic about what a quantum state even *is* on each target machine, which might have different interpretations depending on the machine.</span></span> 

<span data-ttu-id="26aec-119">Från perspektivet i ett Q #-program är en qubit en helt ogenomskinlig referens till den interna strukturen på mål datorn.</span><span class="sxs-lookup"><span data-stu-id="26aec-119">From the perspective of a Q# program, a qubit is an entirely opaque reference to the internal structure of a target machine.</span></span>
<span data-ttu-id="26aec-120">Ett Q #-program har ingen möjlighet att introspect en qubit, dess representation på en måldator, eller till och med om det är samma qubit som andra qubit som är tillgängliga för programmet.</span><span class="sxs-lookup"><span data-stu-id="26aec-120">A Q# program has no ability to introspect into the state of a qubit, its representation on a target machine, or even whether it is the same qubit as any other qubit available to the program.</span></span>
<span data-ttu-id="26aec-121">Ett program kan istället anropa åtgärder som `Measure` för att lära sig information från en qubit och anropa åtgärder som `X` och `H` för att agera för en qubit.</span><span class="sxs-lookup"><span data-stu-id="26aec-121">Rather, a program can call operations such as `Measure` to learn information from a qubit, and call operations such as `X` and `H` to act on the state of a qubit.</span></span>
<span data-ttu-id="26aec-122">Dessa åtgärder har ingen inbyggd definition på språket och görs konkreta enbart av mål datorn som används för att köra ett visst Q #-program.</span><span class="sxs-lookup"><span data-stu-id="26aec-122">These operations have no intrinsic definition within the language, and are made concrete only by the target machine used to run a particular Q# program.</span></span>
<span data-ttu-id="26aec-123">Ett Q #-program kombinerar dessa åtgärder så som definieras av en mål dator för att skapa nya, högre åtgärder för att uttrycka Quantum-beräkning.</span><span class="sxs-lookup"><span data-stu-id="26aec-123">A Q# program recombines these operations as defined by a target machine to create new, higher-level operations to express quantum computation.</span></span>
<span data-ttu-id="26aec-124">På så sätt gör Q # det enkelt att uttrycka logiken för de underliggande Quantum-och hybrid-klassiska algoritmerna, samtidigt som det är allmänt vad gäller strukturen för en mål dator eller Simulator.</span><span class="sxs-lookup"><span data-stu-id="26aec-124">In this way, Q# makes it easy to express the logic underlying quantum and hybrid quantum-classical algorithms, while also being general with respect to the structure of a target machine or simulator.</span></span>

## <a name="q-operations-and-functions"></a><span data-ttu-id="26aec-125">Q #-åtgärder och-funktioner</span><span class="sxs-lookup"><span data-stu-id="26aec-125">Q# operations and functions</span></span>

<span data-ttu-id="26aec-126">Konkret, ett Q #-program består av en eller flera *åtgärder*, en eller flera *funktioner*och användardefinierade typer.</span><span class="sxs-lookup"><span data-stu-id="26aec-126">Concretely, a Q# program is comprised of one or more *operations*, one or more *functions*, and user defined types.</span></span> <span data-ttu-id="26aec-127">Åtgärder används för att beskriva omvandlingar av status för en Quantum Machine och är de mest grundläggande Bygg stenarna för Q #-program.</span><span class="sxs-lookup"><span data-stu-id="26aec-127">Operations are used to describe the transformations of the state of a quantum machine and are the most basic building block of Q# programs.</span></span> <span data-ttu-id="26aec-128">Varje åtgärd som definierats i Q # kan sedan anropa valfritt antal andra åtgärder, inklusive inbyggda *inbyggda åtgärder som* implementeras av en måldator.</span><span class="sxs-lookup"><span data-stu-id="26aec-128">Each operation defined in Q# may then call any number of other operations, including the built-in *intrinsic* operations implemented by a target machine.</span></span>
<span data-ttu-id="26aec-129">När de kompileras visas varje åtgärd som en .NET-klass typ som kan tillhandahållas mål datorer.</span><span class="sxs-lookup"><span data-stu-id="26aec-129">When compiled, each operation is represented as a .NET class type that can be provided to target machines.</span></span>

<span data-ttu-id="26aec-130">Till skillnad från åtgärder används funktioner för att beskriva rent klassiskt beteende och har inga effekter, förutom att använda klassiska utmatnings värden.</span><span class="sxs-lookup"><span data-stu-id="26aec-130">In contrast to operations, functions are used to describe purely classical behavior and do not have any effects besides computing classical output values.</span></span> <span data-ttu-id="26aec-131">Q # är ett starkt skrivet språk och levereras med en uppsättning inbyggda primitiva typer samt stöd för användardefinierade typer.</span><span class="sxs-lookup"><span data-stu-id="26aec-131">Q# is a strongly typed language and comes with a set of built-in primitive types as well as support for user defined types.</span></span> 

<span data-ttu-id="26aec-132">I resten av den här guiden kommer vi att se hur du använder olika språkkoncept och utformar för att hjälpa oss att definiera komplexa Quantum-program genom de grundläggande Bygg stenarna för åtgärder, funktioner och typer.</span><span class="sxs-lookup"><span data-stu-id="26aec-132">Throughout the rest of this guide, we will see how to use different language concepts and constructs to help us define complex quantum programs through the basic building blocks of operations, functions, and types.</span></span> 

## <a name="structure-of-q-source-files"></a><span data-ttu-id="26aec-133">Struktur för Q # källfiler</span><span class="sxs-lookup"><span data-stu-id="26aec-133">Structure of Q# Source Files</span></span>

<span data-ttu-id="26aec-134">En Q #-källfil består till minimalt av en *namn områdes deklaration*som anger ett .net-namn område som innehåller definitionerna i käll filen.</span><span class="sxs-lookup"><span data-stu-id="26aec-134">Minimally, a Q# source file consists of a *namespace declaration*, which specifies a .NET namespace which will contain the definitions in the source file.</span></span>
<span data-ttu-id="26aec-135">Definitioner från andra Q #-källfiler och-bibliotek kan inkluderas med hjälp av `open`-instruktionen.</span><span class="sxs-lookup"><span data-stu-id="26aec-135">Definitions from other Q# source files and libraries can be included using the `open` statement.</span></span>
<span data-ttu-id="26aec-136">Till exempel definieras de flesta av de åtgärder som definierar de grundläggande grindarna i namn området <xref:microsoft.quantum.intrinsic>.</span><span class="sxs-lookup"><span data-stu-id="26aec-136">For instance, most of the operations defining fundamental gates are defined in the <xref:microsoft.quantum.intrinsic> namespace.</span></span>
<span data-ttu-id="26aec-137">För att göra detta tillgängligt för vår kod `open` vi bara det namn området överst i varje fil:</span><span class="sxs-lookup"><span data-stu-id="26aec-137">To make this available to our code, we simply `open` that namespace at the top of each file:</span></span>

```qsharp
namespace Example {
    open Microsoft.Quantum.Intrinsic;

    // ...
}
```

<span data-ttu-id="26aec-138">I ett namn område kan varje Q #-källfil definiera en kombination av *åtgärder*, *funktioner*och *användardefinierade typer*.</span><span class="sxs-lookup"><span data-stu-id="26aec-138">Within a namespace, each Q# source file can define any combination of *operations*, *functions*, and *user-defined types*.</span></span>
<span data-ttu-id="26aec-139">I resten av det här avsnittet ska vi beskriva var och en i sin tur och tillhandahålla exempel på hur de kan användas i praktiken för att göra användbara Quantum-program.</span><span class="sxs-lookup"><span data-stu-id="26aec-139">In the rest of this section, we will describe each in turn and provide examples of how they can be used in practice to make useful quantum programs.</span></span>
