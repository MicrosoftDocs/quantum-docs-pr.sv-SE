---
title: Kvantutvecklingstekniker | Microsoft Docs
description: Kvantutvecklingstekniker
keywords: Lägg inte till eller redigera nyckelord utan att först kontakta den SEO-ansvarige.
author: QuantumWriter
ms.author: MSFT-alias-person-or-DL
ms.date: 9/20/2019
ms.topic: article-type-from-white-list
uid: microsoft.quantum.techniques.intro
ms.openlocfilehash: c1263edb75f903702ab3c16cec0443857150b662
ms.sourcegitcommit: f8d6d32d16c3e758046337fb4b16a8c42fb04c39
ms.translationtype: HT
ms.contentlocale: sv-SE
ms.lasthandoff: 01/29/2020
ms.locfileid: "76820818"
---
# <a name="quantum-development-techniques"></a><span data-ttu-id="6f705-104">Kvantutvecklingstekniker</span><span class="sxs-lookup"><span data-stu-id="6f705-104">Quantum Development Techniques</span></span>

<span data-ttu-id="6f705-105">I det här avsnittet av dokumentationen beskrivs de grundläggande begrepp som används för att skapa kvantprogram i Q#, samt hur man interagerar med dessa program från klassiska program.</span><span class="sxs-lookup"><span data-stu-id="6f705-105">This section of our documentation details the core concepts used to create quantum programs in Q#, and to interact with those programs from classical applications.</span></span>
<span data-ttu-id="6f705-106">Vi antar att du har *viss* kunskap om kvantberäkning, t.ex. de som beskrivs i [Begrepp inom kvantberäkning](xref:microsoft.quantum.concepts.intro), men du behöver inte vara expert på kvantberäkning för att förstå dessa avsnitt.</span><span class="sxs-lookup"><span data-stu-id="6f705-106">We assume *some* knowledge of quantum computing concepts, like those described in [Quantum computing concepts](xref:microsoft.quantum.concepts.intro), but you need not be an expert in quantum computing to get a lot from these sections.</span></span>

<span data-ttu-id="6f705-107">Innehållet är följande.</span><span class="sxs-lookup"><span data-stu-id="6f705-107">Their contents are as follows.</span></span>

- <span data-ttu-id="6f705-108">I [Översikt över Q#-programmet](xref:microsoft.quantum.techniques.file-structure) finns en översikt över syftet med och funktionerna i programmeringsspråket Q#.</span><span class="sxs-lookup"><span data-stu-id="6f705-108">[Q# program overview](xref:microsoft.quantum.techniques.file-structure) provides an overview of the purpose and functionality of the Q# programming language.</span></span> 
    <span data-ttu-id="6f705-109">I synnerhet klargörs hur Q# *inte* ett språk som enbart simulerar kvantmekanik – även om den funktionen givetvis finns i vår simulator med fullständigt tillstånd.</span><span class="sxs-lookup"><span data-stu-id="6f705-109">In particular, it clarifies how Q# is *not* a language for merely simulating quantum mechanics---though that functionality is of course provided by our full state simulator.</span></span> 
    <span data-ttu-id="6f705-110">I stället har Q# utformats med tanke på framtiden och i programmen beskrivs hur en klassisk kontrolldator *interagerar* med kvantbitar.</span><span class="sxs-lookup"><span data-stu-id="6f705-110">Rather, Q# was designed with an eye on the future, and its programs describe how a classical control computer *interacts* with qubits.</span></span> 

- <span data-ttu-id="6f705-111">I [Åtgärder och funktioner](xref:microsoft.quantum.techniques.opsandfunctions) visas de två anropningsbara typerna av Q#-språket: *Åtgärder* som innehåller åtgärder för kvantbitar och kvantsystem, samt *funktioner* som enbart arbetar med klassisk information.</span><span class="sxs-lookup"><span data-stu-id="6f705-111">[Operations and functions](xref:microsoft.quantum.techniques.opsandfunctions) details the two callable types of the Q# language: *operations*, which include action on qubits and quantum systems; and *functions*, which strictly work with classical information.</span></span> 
    <span data-ttu-id="6f705-112">Om inte både klassisk information och kvantinformation kunde användas samtidigt, skulle kvantberäkningen vara omöjlig.</span><span class="sxs-lookup"><span data-stu-id="6f705-112">Without both classical and quantum information working in tandem, quantum computing would remain out of reach.</span></span> 
    <span data-ttu-id="6f705-113">I det här avsnittet beskrivs hur du definierar och använder dessa anropningsbara typer i kontrollflödet för ett Q#-program.</span><span class="sxs-lookup"><span data-stu-id="6f705-113">This section describes how to define and use these callables within the control flow of a Q# program.</span></span>

- <span data-ttu-id="6f705-114">I [Lokala variabler](xref:microsoft.quantum.techniques.local-variables) beskrivs variablernas roll i Q#-program och hur du använder dem på ett effektivt sätt.</span><span class="sxs-lookup"><span data-stu-id="6f705-114">[Local variables](xref:microsoft.quantum.techniques.local-variables) describes the role of variables within Q# programs and how to leverage them effectively.</span></span> 
    <span data-ttu-id="6f705-115">I synnerhet kommer du att lära dig skillnaden mellan oföränderliga/föränderliga variabler och hur du tilldelar/omtilldelar dem.</span><span class="sxs-lookup"><span data-stu-id="6f705-115">In particular, you will learn the difference between immutable/mutable variables and how to assign/re-assign them.</span></span>

- <span data-ttu-id="6f705-116">I [Arbeta med kvantbitar](xref:microsoft.quantum.techniques.qubits) beskrivs de funktioner i Q# som du kan använda för enskilda kvantbitar och system med kvantbitar.</span><span class="sxs-lookup"><span data-stu-id="6f705-116">[Working with qubits](xref:microsoft.quantum.techniques.qubits) describes the features of Q# that you can use to address individual qubits and systems of qubits.</span></span> 
    <span data-ttu-id="6f705-117">Det innebär mer specifikt deras allokering, att utföra åtgärder på dem och slutligen deras mått.</span><span class="sxs-lookup"><span data-stu-id="6f705-117">Specifically, that entails their allocation, performing operations on them, and ultimately their measurement.</span></span> 
    <span data-ttu-id="6f705-118">Dessutom får du lära dig några användbara kontrollflödestekniker.</span><span class="sxs-lookup"><span data-stu-id="6f705-118">Additionally, you will learn some useful control flow techniques.</span></span>

- <span data-ttu-id="6f705-119">I [Färdigställa allt](xref:microsoft.quantum.techniques.puttingittogether) använder du teknikerna från avsnitten ovan till att skapa ett program som utför **kvantteleportering**: Med hjälp av två klassiska bitar ”teleporteras” hela tillståndet i en kvantbit till en annan.</span><span class="sxs-lookup"><span data-stu-id="6f705-119">In [Putting it all together](xref:microsoft.quantum.techniques.puttingittogether), you will leverage the techniques from the sections above to create a program which performs **quantum teleportation**: using two classical bits to "teleport" the full state of one qubit onto another.</span></span>

- <span data-ttu-id="6f705-120">I [Gå vidare](xref:microsoft.quantum.techniques.going-further) introduceras avancerade tekniker som kan vara till hjälp när du går vidare mot mer komplex kvantprogrammering.</span><span class="sxs-lookup"><span data-stu-id="6f705-120">[Going further](xref:microsoft.quantum.techniques.going-further) introduces advanced techniques that can prove helpful as you move toward more complex quantum programming.</span></span> 
    <span data-ttu-id="6f705-121">I synnerhet diskuterar vi användningen av *typparametriserade* åtgärder och funktioner i Q#, som möjliggör kontrollflöden på högre nivå genom att förbli oberoende av specifika typer av indata/utdata, samt att *låna* kvantbitar.</span><span class="sxs-lookup"><span data-stu-id="6f705-121">In particular, we discuss the use of *type-parameterized* operations and functions in Q#, which enable higher-order control flow by remaining agnostic to the specific types of their input/output, as well as *borrowing* qubits.</span></span> 
    <span data-ttu-id="6f705-122">Det senare skiljer sig från grundläggande kvantbitsallokering i och med att en Q#-åtgärd kan använda ”felaktiga” kvantbitar – dvs. kvantbitar som inte nödvändigtvis initierats till ett känt tillstånd – som hjälp vid beräkningar.</span><span class="sxs-lookup"><span data-stu-id="6f705-122">The latter differs from basic qubit allocation in that a Q# operation may use "dirty" qubits---qubits not necessarily initialized to a known state---to assist computations.</span></span>

- <span data-ttu-id="6f705-123">I [Testa och felsöka](xref:microsoft.quantum.techniques.testing-and-debugging) beskrivs vissa tekniker där du kan kontrollera att din kod gör det den ska.</span><span class="sxs-lookup"><span data-stu-id="6f705-123">[Testing and debugging](xref:microsoft.quantum.techniques.testing-and-debugging) details some techniques for making sure your code is doing what it is supposed to do.</span></span> 
    <span data-ttu-id="6f705-124">På grund av den övergripande komplexiteten i kvantinformation, kan det krävas särskilda tekniker när kvantprogram ska felsökas.</span><span class="sxs-lookup"><span data-stu-id="6f705-124">Due to the general opacity of quantum information, debugging a quantum program can require specialized techniques.</span></span> 
    <span data-ttu-id="6f705-125">Lyckligtvis stöder Q# många av de klassiska felsökningstekniker som programmerare brukar använda, samt även de som är kvantspecifika.</span><span class="sxs-lookup"><span data-stu-id="6f705-125">Fortunately, Q# supports many of the classical debugging techniques programmers are used to, as well as those that are quantum-specific.</span></span> <span data-ttu-id="6f705-126">Detta innefattar att skapa/köra enhetstester i Q#, bädda in *kontroller* av värden och sannolikheter i koden, samt `Dump`-funktioner som visar status för måldatorn.</span><span class="sxs-lookup"><span data-stu-id="6f705-126">These include creating/running unit tests in Q#, embedding *assertions* on values and probabilities in your code, and the `Dump` functions which output the state of target machine.</span></span> 
    <span data-ttu-id="6f705-127">Den senare kan användas tillsammans med vår simulator med fullständigt tillstånd till att felsöka vissa delar av beräkningarna genom att kringgå vissa kvantbegränsningar (t.ex. ”no-cloning theorem”).</span><span class="sxs-lookup"><span data-stu-id="6f705-127">The latter can be used alongside our full state simulator to debug certain parts of computations by skirting some quantum limitations (e.g. the no-cloning theorem).</span></span>


![Quantum](~/media/mobius_strip_preview.png)
