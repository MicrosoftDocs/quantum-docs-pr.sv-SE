---
title: 'Q #-grunder'
description: 'Grundläggande begrepp för Q #'
author: gillenhaalb
ms.author: a-gibec@microsoft.com
ms.date: 02/28/2020
ms.topic: article
uid: microsoft.quantum.guide.basics
ms.openlocfilehash: 45e6f2f33dafc2aec177091d3cfa94aca14fbf0a
ms.sourcegitcommit: af10179284967bd7a72a52ae7e1c4da65c7d128d
ms.translationtype: MT
ms.contentlocale: sv-SE
ms.lasthandoff: 06/26/2020
ms.locfileid: "85415375"
---
# <a name="q-basics"></a><span data-ttu-id="1a437-103">Q #-grunder</span><span class="sxs-lookup"><span data-stu-id="1a437-103">Q# Basics</span></span>

<span data-ttu-id="1a437-104">Den här artikeln innehåller en kort introduktion till de grundläggande Bygg stenarna för Q #.</span><span class="sxs-lookup"><span data-stu-id="1a437-104">This article presents a brief introduction to the basic building blocks of Q#.</span></span>

<span data-ttu-id="1a437-105">En översikt över vad Q # är och var det passar in som en grundläggande komponent i Quantum Development Kit finns i [Vad är Q #?](xref:microsoft.quantum.overview.q-sharp).</span><span class="sxs-lookup"><span data-stu-id="1a437-105">For an overview of what Q# is and where it fits in as a fundamental component of the Quantum Development Kit, see [What is Q#?](xref:microsoft.quantum.overview.q-sharp).</span></span> 

## <a name="what-is-a-quantum-program"></a><span data-ttu-id="1a437-106">Vad är ett Quantum-program?</span><span class="sxs-lookup"><span data-stu-id="1a437-106">What is a quantum program?</span></span>

<span data-ttu-id="1a437-107">Från ett tekniskt perspektiv är ett Quantum-program en viss uppsättning klassiska del rutiner som, vid anrop, utför vissa åtgärder på ett Quantum-system.</span><span class="sxs-lookup"><span data-stu-id="1a437-107">From a technical perspective, a quantum program is a particular set of classical subroutines which, when called, perform certain operations on a quantum system.</span></span>
<span data-ttu-id="1a437-108">En viktig konsekvens i den vyn är att ett Q #-program inte direkt modellerar qubits, utan beskriver i stället hur en klassisk kontrollerad dator interagerar med dessa qubits.</span><span class="sxs-lookup"><span data-stu-id="1a437-108">An important consequence of that view is that a Q# program does not directly model qubits themselves, but rather describes how a classically controlled computer interacts with those qubits.</span></span>
<span data-ttu-id="1a437-109">Som design definierar Q # inte Quantum-tillstånd eller andra egenskaper för Quantum Mechanics direkt.</span><span class="sxs-lookup"><span data-stu-id="1a437-109">By design, Q# does not define quantum states or other properties of quantum mechanics directly.</span></span>
<span data-ttu-id="1a437-110">Anta till exempel att State $ \ket{+} = \left (\ket {0} + \ket {1} \right)/\sqrt {2} $ beskrivs i guiden för [Quantum Computing-koncept](xref:microsoft.quantum.concepts.intro) .</span><span class="sxs-lookup"><span data-stu-id="1a437-110">For instance, consider the state $\ket{+} = \left(\ket{0} + \ket{1}\right) / \sqrt{2}$ discussed in the [Quantum Computing Concepts](xref:microsoft.quantum.concepts.intro) guide.</span></span>
<span data-ttu-id="1a437-111">För att förbereda det här läget i Q # börjar du med de fakta som qubits initieras i $ \ket {0} $ State och att $ \ket{+} = H\ket {0} $, där $H $ är [Hadamard-transformeringen](xref:microsoft.quantum.glossary#hadamard), som implementeras av [ `H` åtgärden](xref:microsoft.quantum.intrinsic.h).</span><span class="sxs-lookup"><span data-stu-id="1a437-111">To prepare this state in Q#, start with the facts that the qubits are initialized in the $\ket{0}$ state, and that $\ket{+} = H\ket{0}$, where $H$ is the [Hadamard transform](xref:microsoft.quantum.glossary#hadamard), implemented by the [`H` operation](xref:microsoft.quantum.intrinsic.h).</span></span> <span data-ttu-id="1a437-112">Basic Q #-kod som initierar och transformerar en qubit, ser ut så här:</span><span class="sxs-lookup"><span data-stu-id="1a437-112">The basic Q# code to initialize and transform a qubit, then, looks like this:</span></span>

```qsharp
using (qubit = Qubit()) {
    // At this point, the qubit is in the state |0⟩.
    H(qubit);
    // H is now applied, such that the qubit is in H|0⟩ = |+⟩, as desired.
}
```
<span data-ttu-id="1a437-113">Mer information om att initiera eller *allokera*, qubits finns i [arbeta med qubits](xref:microsoft.quantum.guide.qubits).</span><span class="sxs-lookup"><span data-stu-id="1a437-113">For more information on initializing, or *allocating*, qubits, see [Working with qubits](xref:microsoft.quantum.guide.qubits).</span></span>

## <a name="quantum-states-in-q"></a><span data-ttu-id="1a437-114">Quantum-tillstånd i Q #</span><span class="sxs-lookup"><span data-stu-id="1a437-114">Quantum states in Q#</span></span>

<span data-ttu-id="1a437-115">Det tidigare programmet refererar inte uttryckligen till statusen inom Q # men vi har beskrivit hur vårt program *omvandlade* statusen.</span><span class="sxs-lookup"><span data-stu-id="1a437-115">Importantly, the previous program does not explicitly refer to the state within Q# but described how our program *transformed* the state.</span></span>
<span data-ttu-id="1a437-116">Med den här metoden kan du helt oberoende om vad ett Quantum-tillstånd *är* på varje måldator, vilket kan ha olika tolkningar beroende på datorn.</span><span class="sxs-lookup"><span data-stu-id="1a437-116">With this approach, you can be entirely agnostic about what a quantum state even *is* on each target machine, which might have different interpretations depending on the machine.</span></span> 

<span data-ttu-id="1a437-117">Ett Q #-program kan inte Introspect till status för en qubit.</span><span class="sxs-lookup"><span data-stu-id="1a437-117">A Q# program cannot introspect into the state of a qubit.</span></span>
<span data-ttu-id="1a437-118">I stället kan ett program anropa åtgärder, till exempel [`Measure`](xref:microsoft.quantum.intrinsic.measure) för att lära sig information från en qubit och anropa åtgärder som [`X`](xref:microsoft.quantum.intrinsic.x) och [`H`](xref:microsoft.quantum.intrinsic.h) för att agera för en qubit-status.</span><span class="sxs-lookup"><span data-stu-id="1a437-118">Instead, a program can call operations such as [`Measure`](xref:microsoft.quantum.intrinsic.measure) to learn information from a qubit, and call operations such as [`X`](xref:microsoft.quantum.intrinsic.x) and [`H`](xref:microsoft.quantum.intrinsic.h) to act on the state of a qubit.</span></span>
<span data-ttu-id="1a437-119">De här *åtgärderna faktiskt görs* enbart konkret av mål datorn som används för att köra det särskilda Q #-programmet.</span><span class="sxs-lookup"><span data-stu-id="1a437-119">What these operations actually *do* is only made concrete by the target machine used to run the particular Q# program.</span></span>
<span data-ttu-id="1a437-120">Om du till exempel kör programmet i en [full-State-Simulator](xref:microsoft.quantum.machines.full-state-simulator)utför simulatorn motsvarande matematiska åtgärder till det simulerade Quantum-systemet.</span><span class="sxs-lookup"><span data-stu-id="1a437-120">For example, if running the program on our [full-state simulator](xref:microsoft.quantum.machines.full-state-simulator), the simulator performs the corresponding mathematical operations to the simulated quantum system.</span></span>
<span data-ttu-id="1a437-121">Men om mål datorn är en verklig Quantum-dator kan du, men i framtiden, använda den här typen av åtgärder i Q # och dirigerar den Quantum datorn för att utföra motsvarande *verkliga* åtgärder på det *verkliga* Quantum-systemet, till exempel exakta Timed laser pulsering.</span><span class="sxs-lookup"><span data-stu-id="1a437-121">But looking toward the future, when the target machine is a real quantum computer, calling such operations in Q# directs the quantum computer to perform the corresponding *real* operations on the *real* quantum system, for example, precisely timed laser pulses).</span></span>

<span data-ttu-id="1a437-122">Ett Q #-program kombinerar dessa åtgärder så som definieras av en mål dator för att skapa nya, högre åtgärder för att uttrycka Quantum-beräkning.</span><span class="sxs-lookup"><span data-stu-id="1a437-122">A Q# program recombines these operations as defined by a target machine to create new, higher-level operations to express quantum computation.</span></span>
<span data-ttu-id="1a437-123">På så sätt gör Q # det enkelt att uttrycka logiken för de underliggande Quantum-och hybrid Quantum-algoritmerna, samtidigt som det är allmänt vad gäller strukturen för en mål dator eller Simulator.</span><span class="sxs-lookup"><span data-stu-id="1a437-123">In this way, Q# makes it easy to express the logic underlying quantum and hybrid quantum–classical algorithms, while also being general with respect to the structure of a target machine or simulator.</span></span>

## <a name="q-operations-and-functions"></a><span data-ttu-id="1a437-124">Q #-åtgärder och-funktioner</span><span class="sxs-lookup"><span data-stu-id="1a437-124">Q# operations and functions</span></span>

<span data-ttu-id="1a437-125">Konkret, ett Q #-program omfattar *åtgärder*, *funktioner*och alla användardefinierade typer.</span><span class="sxs-lookup"><span data-stu-id="1a437-125">Concretely, a Q# program comprises *operations*, *functions*, and any user-defined types.</span></span> 

<span data-ttu-id="1a437-126">Åtgärder används för att beskriva omvandlingar av Quantum Systems och är de mest grundläggande Bygg stenarna för Q #-program.</span><span class="sxs-lookup"><span data-stu-id="1a437-126">Operations are used to describe the transformations of quantum systems and are the most fundamental building block of Q# programs.</span></span> <span data-ttu-id="1a437-127">Varje åtgärd som definierats i Q # kan sedan anropa valfritt antal andra åtgärder.</span><span class="sxs-lookup"><span data-stu-id="1a437-127">Each operation defined in Q# may then call any number of other operations.</span></span>

<span data-ttu-id="1a437-128">Till skillnad från åtgärder används funktioner för att beskriva rent *deterministiskt* klassiskt klassiskt beteende och har inga effekter, förutom att beräkna klassiska värden.</span><span class="sxs-lookup"><span data-stu-id="1a437-128">In contrast to operations, functions are used to describe purely *deterministic* classical behavior and do not have any effects besides computing classical values.</span></span> <span data-ttu-id="1a437-129">Anta till exempel att du vill mäta qubits i slutet av ett program och lägga till mått resultatet i en matris.</span><span class="sxs-lookup"><span data-stu-id="1a437-129">For example, suppose you want to measure the qubits at the end of a program and add the measurement results to an array.</span></span>
<span data-ttu-id="1a437-130">I det här fallet `Measure` är en *åtgärd* som instruerar mål datorn att utföra en mätning på (verkliga eller simulerade) qubits.</span><span class="sxs-lookup"><span data-stu-id="1a437-130">In this case, `Measure` is an *operation* that instructs the target machine to perform a measurement on the (real or simulated) qubits.</span></span> <span data-ttu-id="1a437-131">På samma gång hanterar *Functions* den klassiska processen för att lägga till de returnerade resultaten i en matris.</span><span class="sxs-lookup"><span data-stu-id="1a437-131">At the same time, *functions* handle the classical process of adding the returned results to an array.</span></span>

<span data-ttu-id="1a437-132">Åtgärder och funktioner kallas tillsammans *callables*.</span><span class="sxs-lookup"><span data-stu-id="1a437-132">Together, operations and functions are known as *callables*.</span></span> <span data-ttu-id="1a437-133">Deras underliggande struktur och beteende införs och beskrivs i [åtgärder och funktioner i Q #](xref:microsoft.quantum.guide.operationsfunctions).</span><span class="sxs-lookup"><span data-stu-id="1a437-133">Their underlying structure and behavior are introduced and detailed in [Operations and Functions in Q#](xref:microsoft.quantum.guide.operationsfunctions).</span></span>


## <a name="q-syntax-overview"></a><span data-ttu-id="1a437-134">Översikt över Q # syntax</span><span class="sxs-lookup"><span data-stu-id="1a437-134">Q# syntax overview</span></span>

<span data-ttu-id="1a437-135">Syntaxen för ett språk beskriver de olika kombinationer av symboler som utgör ett syntaktiskt korrekt program.</span><span class="sxs-lookup"><span data-stu-id="1a437-135">The syntax of a language describes the different combinations of symbols that form a syntactically correct program.</span></span>
<span data-ttu-id="1a437-136">I Q # klassificeras syntax-element i tre olika grupper: typer, uttryck och uttryck.</span><span class="sxs-lookup"><span data-stu-id="1a437-136">In Q#, syntax elements are classified into three different groups: types, expressions, and statements.</span></span>

### <a name="types"></a><span data-ttu-id="1a437-137">Typer</span><span class="sxs-lookup"><span data-stu-id="1a437-137">Types</span></span>
<span data-ttu-id="1a437-138">Q # är ett starkt skrivet språk, så att en noggrann användning av typer kan hjälpa kompilatorn att tillhandahålla starka garantier för Q #-program vid kompilering.</span><span class="sxs-lookup"><span data-stu-id="1a437-138">Q# is a strongly-typed language, such that careful use of types can help the compiler provide strong guarantees about Q# programs at compile time.</span></span>
<span data-ttu-id="1a437-139">Förutom standard-och Quantum-/regionsspecifika inbyggda primitiva typer, till exempel,,, `Int` `Bool` `Qubit` och `Result` , innehåller Q # stöd för användardefinierade typer.</span><span class="sxs-lookup"><span data-stu-id="1a437-139">In addition to standard and quantum-specific built-in primitive types, for example, `Int`, `Bool`, `Qubit`, and `Result`, Q# provides support for user-defined types.</span></span>

<span data-ttu-id="1a437-140">För beskrivningar av alla primitiva typer, information om matris-och tupel typer och steg för att definiera nya typer i en Q #-fil, se [typer i q #](xref:microsoft.quantum.guide.types).</span><span class="sxs-lookup"><span data-stu-id="1a437-140">For descriptions of all the primitive types, details for array and tuple types, and steps to define new types within a Q# file, see [Types in Q#](xref:microsoft.quantum.guide.types).</span></span>

### <a name="expressions"></a><span data-ttu-id="1a437-141">Uttryck</span><span class="sxs-lookup"><span data-stu-id="1a437-141">Expressions</span></span>
<span data-ttu-id="1a437-142">Ett uttryck i ett programmeringsspråk är en kombination av en eller flera konstanter, variabler, operatorer och funktioner som programmerings språket tolkar och utvärderar till ett särskilt värde.</span><span class="sxs-lookup"><span data-stu-id="1a437-142">An expression in a programming language is a combination of one or more constants, variables, operators, and functions that the programming language interprets and evaluates to a specific value.</span></span>
<span data-ttu-id="1a437-143">För varje typ på ett språk kan exempelvis uttryck av den typen vara antingen *litteraler* eller symboler som är kopplade till ett värde av den typen.</span><span class="sxs-lookup"><span data-stu-id="1a437-143">Most simply, for every type in a language, expressions of that type can be either *literals* or symbols bound to a value of that type.</span></span>
<span data-ttu-id="1a437-144">Till exempel `5` är en `Int` literal (vilket även ett uttryck av typen `Int` ) och om symbolen `count` är kopplad till heltal svärdet `5` är det `count` också ett heltals uttryck.</span><span class="sxs-lookup"><span data-stu-id="1a437-144">For example, `5` is an `Int` literal (thus also an expression of type `Int`), and if the symbol `count` is bound to the integer value `5`, then `count` is also an integer expression.</span></span>

<span data-ttu-id="1a437-145">Dessutom kan ett uttryck bestå av andra uttryck som kombineras av vissa operatorer.</span><span class="sxs-lookup"><span data-stu-id="1a437-145">Additionally, an expression can consist of other expressions combined by certain operators.</span></span>
<span data-ttu-id="1a437-146">Till exempel ett annat `Int` uttryck som utvärderas till `5` är `2+3` .</span><span class="sxs-lookup"><span data-stu-id="1a437-146">For example, another `Int` expression that evaluates to `5` is `2+3`.</span></span>

<span data-ttu-id="1a437-147">Mer information om uttryck och kompatibla operatorer i Q # finns i [typ uttryck i q #](xref:microsoft.quantum.guide.expressions).</span><span class="sxs-lookup"><span data-stu-id="1a437-147">For more information about expressions and compatible operators in Q#, see [Type Expressions in Q#](xref:microsoft.quantum.guide.expressions).</span></span> 

### <a name="statements"></a><span data-ttu-id="1a437-148">Instruktioner</span><span class="sxs-lookup"><span data-stu-id="1a437-148">Statements</span></span> 
<span data-ttu-id="1a437-149">En instruktion är en syntaktisk enhet av ett tvingande programmeringsspråk som uttrycker en åtgärd som ska utföras. Uttryck med uttryck i dessa instruktioner returnerar inte resultat och utförs enbart för deras sido effekter.</span><span class="sxs-lookup"><span data-stu-id="1a437-149">A statement is a syntactic unit of an imperative programming language that expresses some action to carry out. Statements contrast with expressions in that statements do not return results and are executed solely for their side effects.</span></span> <span data-ttu-id="1a437-150">Uttryck returnerar dock alltid ett resultat och ofta har inte sido effekter alls.</span><span class="sxs-lookup"><span data-stu-id="1a437-150">Expressions, however, always return a result and often do not have side effects at all.</span></span> <span data-ttu-id="1a437-151">I korthet körs Q #-instruktioner, medan uttryck utvärderas.</span><span class="sxs-lookup"><span data-stu-id="1a437-151">In short, Q# statements are executed, while expressions are evaluated.</span></span>

<span data-ttu-id="1a437-152">Ett enkelt exempel på en instruktion i Q # tilldelar en symbol till ett uttryck:</span><span class="sxs-lookup"><span data-stu-id="1a437-152">A simple example of a statement in Q# is assigning a symbol to an expression:</span></span>
```qsharp
let count = 5;
```

<span data-ttu-id="1a437-153">Ett mer intressant exempel är en `for` instruktion som stöder iteration och innehåller ett *instruktions block*.</span><span class="sxs-lookup"><span data-stu-id="1a437-153">A more interesting example is the `for` statement which supports iteration and includes a *statement block*.</span></span>
<span data-ttu-id="1a437-154">Anta `qubits` att är symbolen knuten till ett register över qubits (tekniskt av typen `Qubit[]` eller en matris av `Qubit` typer).</span><span class="sxs-lookup"><span data-stu-id="1a437-154">Suppose `qubits` is the symbol bound to a register of qubits (technically of type `Qubit[]`, or an array of `Qubit` types).</span></span> <span data-ttu-id="1a437-155">Dra</span><span class="sxs-lookup"><span data-stu-id="1a437-155">Then</span></span>
```qsharp
for (qubit in qubits) {
    H(qubit);
}
```
<span data-ttu-id="1a437-156">är en instruktion som itererar över varje qubit i registret, vilket utför `H` åtgärden på var och en.</span><span class="sxs-lookup"><span data-stu-id="1a437-156">is a statement that iterates over each qubit in the register, performing the `H` operation on each one.</span></span> <span data-ttu-id="1a437-157">Observera att `H(qubit);` även är en instruktion i sig själv.</span><span class="sxs-lookup"><span data-stu-id="1a437-157">Note that `H(qubit);` is a statement in itself as well.</span></span>

<span data-ttu-id="1a437-158">Du kan använda valfritt anrops uttryck av typen `Unit` (en `Unit` typ returnerar ingen information) som en instruktion.</span><span class="sxs-lookup"><span data-stu-id="1a437-158">You can use any call expression of type `Unit` (a `Unit` type does not return any information) as a statement.</span></span>
<span data-ttu-id="1a437-159">Den här typen av uttryck är användbar när du anropar åtgärder på qubits som returneras `Unit` eftersom syftet med instruktionen är att ändra det implicita Quantum-läget.</span><span class="sxs-lookup"><span data-stu-id="1a437-159">This type of expression is useful when calling operations on qubits that return `Unit` because the purpose of the statement is to modify the implicit quantum state.</span></span>
<span data-ttu-id="1a437-160">Uttrycks utvärderings uttryck kräver ett avslutande semikolon.</span><span class="sxs-lookup"><span data-stu-id="1a437-160">Expression evaluation statements require a terminating semicolon.</span></span>

<span data-ttu-id="1a437-161">Du använder instruktioner för att bygga nästan varje aspekt av ett Q #-program, och ingen enskild sida kan omfatta all information som är relaterad till dem.</span><span class="sxs-lookup"><span data-stu-id="1a437-161">You use statements to build nearly every aspect of a Q# program, and no single page could encompass all the information relating to them.</span></span>
<span data-ttu-id="1a437-162">Mer information om deras lexikala struktur och formatering finns i [Q # fil struktur](xref:microsoft.quantum.guide.filestructure); för symbol bindnings tilldelning och omfattning, se [variabler i Q #](xref:microsoft.quantum.guide.variables); och för kontroll flödes slingor som `for` , se [kontroll flöde i Q #](xref:microsoft.quantum.guide.controlflow).</span><span class="sxs-lookup"><span data-stu-id="1a437-162">For more information about their lexical structure and formatting, see [Q# File Structure](xref:microsoft.quantum.guide.filestructure); for symbol binding assignment and scope, see [Variables in Q#](xref:microsoft.quantum.guide.variables); and for control flow loops such as `for`, see [Control Flow in Q#](xref:microsoft.quantum.guide.controlflow).</span></span>

## <a name="next-steps"></a><span data-ttu-id="1a437-163">Nästa steg</span><span class="sxs-lookup"><span data-stu-id="1a437-163">Next steps</span></span>

<span data-ttu-id="1a437-164">Börja lära dig om [typer i Q #](xref:microsoft.quantum.guide.types).</span><span class="sxs-lookup"><span data-stu-id="1a437-164">Start learning about [Types in Q#](xref:microsoft.quantum.guide.types).</span></span>

<span data-ttu-id="1a437-165">Mer bakgrund om grunderna och motivation bakom Q # finns i [Varför behöver vi Q #?](https://devblogs.microsoft.com/qsharp/why-do-we-need-q/).</span><span class="sxs-lookup"><span data-stu-id="1a437-165">For more background about the foundations and motivation behind Q#, see [Why do we need Q#?](https://devblogs.microsoft.com/qsharp/why-do-we-need-q/).</span></span>
