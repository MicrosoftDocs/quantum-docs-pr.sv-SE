---
title: Data strukturer i Q# standard biblioteken
description: Lär dig mer om data strukturer, Oracle och dynamiska generatorer i Microsofts Q# standard bibliotek.
author: QuantumWriter
uid: microsoft.quantum.libraries.data-structures
ms.author: martinro@microsoft.com
ms.date: 12/11/2017
ms.topic: article
no-loc:
- Q#
- $$v
ms.openlocfilehash: 222fa7d0d33d4ac6c15e9ee9e6e97f380867a145
ms.sourcegitcommit: 6bf99d93590d6aa80490e88f2fd74dbbee8e0371
ms.translationtype: MT
ms.contentlocale: sv-SE
ms.lasthandoff: 08/06/2020
ms.locfileid: "87868532"
---
# <a name="data-structures-and-modeling"></a><span data-ttu-id="b6292-103">Data strukturer och modeller</span><span class="sxs-lookup"><span data-stu-id="b6292-103">Data Structures and Modeling</span></span> #

## <a name="classical-data-structures"></a><span data-ttu-id="b6292-104">Klassiska data strukturer</span><span class="sxs-lookup"><span data-stu-id="b6292-104">Classical Data Structures</span></span> ##

<span data-ttu-id="b6292-105">Tillsammans med användardefinierade typer för att representera Quantum-koncept, innehåller Canon även åtgärder, funktioner och typer för att arbeta med klassiska data som används i kontrollen över Quantum Systems.</span><span class="sxs-lookup"><span data-stu-id="b6292-105">Along with user-defined types for representing quantum concepts, the canon also provides operations, functions, and types for working with classical data used in the control of quantum systems.</span></span>
<span data-ttu-id="b6292-106">Funktionen tar till exempel <xref:microsoft.quantum.arrays.reversed> en matris som inmatad och returnerar samma matris i omvänd ordning.</span><span class="sxs-lookup"><span data-stu-id="b6292-106">For instance, the <xref:microsoft.quantum.arrays.reversed> function takes an array as input and returns the same array in reverse order.</span></span>
<span data-ttu-id="b6292-107">Detta kan sedan användas på en matris av typen `Qubit[]` för att undvika att behöva tillämpa onödiga $ \operatorname{swap} $-grindar vid konvertering mellan Quantum-representationer av heltal.</span><span class="sxs-lookup"><span data-stu-id="b6292-107">This can then be used on an array of type `Qubit[]` to avoid having to apply unnecessary $\operatorname{SWAP}$ gates when converting between quantum representations of integers.</span></span>
<span data-ttu-id="b6292-108">På samma sätt såg vi i föregående avsnitt att typer av formulär `(Int, Int -> T)` kan vara användbara för att representera slumpmässiga åtkomst samlingar, så <xref:microsoft.quantum.arrays.lookupfunction> funktionen ger ett bekvämt sätt att konstruera sådana typer från mat ris typer.</span><span class="sxs-lookup"><span data-stu-id="b6292-108">Similarly, we saw in the previous section that types of the form `(Int, Int -> T)` can be useful for representing random access collections, so the <xref:microsoft.quantum.arrays.lookupfunction> function provides a convenient way of constructing such types from array types.</span></span>

### <a name="pairs"></a><span data-ttu-id="b6292-109">Stod</span><span class="sxs-lookup"><span data-stu-id="b6292-109">Pairs</span></span> ###

<span data-ttu-id="b6292-110">Canon stöder funktionell notation för par som kompletterar åtkomst till tupler genom att avkonstrueras:</span><span class="sxs-lookup"><span data-stu-id="b6292-110">The canon supports functional-style notation for pairs, complementing accessing tuples by deconstruction:</span></span>

```qsharp
let pair = (PauliZ, register); // type (Pauli, Qubit[])
ApplyToEach(H, Snd(pair)); // No need to deconstruct to access the register.
```

### <a name="arrays"></a><span data-ttu-id="b6292-111">Matriser</span><span class="sxs-lookup"><span data-stu-id="b6292-111">Arrays</span></span> ###

<span data-ttu-id="b6292-112">Canon innehåller flera funktioner för att ändra matriser.</span><span class="sxs-lookup"><span data-stu-id="b6292-112">The canon provides several functions for manipulating arrays.</span></span>
<span data-ttu-id="b6292-113">Dessa funktioner är Type-parameterd och kan därför användas med matriser av valfri Q# typ.</span><span class="sxs-lookup"><span data-stu-id="b6292-113">These functions are type-parameterized, and thus can be used with arrays of any Q# type.</span></span>
<span data-ttu-id="b6292-114">Funktionen returnerar till exempel <xref:microsoft.quantum.arrays.reversed> en ny matris vars element är i omvänd ordning från dess Indatatyp.</span><span class="sxs-lookup"><span data-stu-id="b6292-114">For instance, the <xref:microsoft.quantum.arrays.reversed> function returns a new array whose elements are in reverse order from its input.</span></span>
<span data-ttu-id="b6292-115">Detta kan användas för att ändra hur ett Quantum-register representeras vid anrop av åtgärder:</span><span class="sxs-lookup"><span data-stu-id="b6292-115">This can be used to change how a quantum register is represented when calling operations:</span></span>

```qsharp
let leRegister = LittleEndian(register);
// QFT expects a BigEndian, so we can reverse before calling.
QFT(BigEndian(Reversed(leRegister!)));
// This is how the LittleEndianAsBigEndian function is implemented:
QFT(LittleEndianAsBigEndian(leRegister));
```

<span data-ttu-id="b6292-116">På samma sätt <xref:microsoft.quantum.arrays.subarray> kan funktionen användas för att ändra ordning på eller ta med del mängder av elementen i en matris:</span><span class="sxs-lookup"><span data-stu-id="b6292-116">Similarly, the <xref:microsoft.quantum.arrays.subarray> function can be used to reorder or take subsets of the elements of an array:</span></span>

```qsharp
// Applies H to qubits 2 and 5.
ApplyToEach(H, Subarray([2, 5], register));
```

<span data-ttu-id="b6292-117">I kombination med Flow-kontroll fungerar mat ris funktioner som exempelvis <xref:microsoft.quantum.arrays.zip> kan ge ett kraftfullt sätt att uttrycka Quantum-program:</span><span class="sxs-lookup"><span data-stu-id="b6292-117">When combined with flow control, array manipulation functions such as <xref:microsoft.quantum.arrays.zip> can provide a powerful way to express quantum programs:</span></span>

```qsharp
// Applies X₃ Y₁ Z₇ to a register of any size.
ApplyToEach(
    ApplyPauli(_, register),
    Map(
        EmbedPauli(_, _, Length(register)),
        Zip([PauliX, PauliY, PauliZ], [3, 1, 7])
    )
);
```

## <a name="oracles"></a><span data-ttu-id="b6292-118">Oracle</span><span class="sxs-lookup"><span data-stu-id="b6292-118">Oracles</span></span> ##

<span data-ttu-id="b6292-119">I steg-för- [steg-uppskattning](https://en.wikipedia.org/wiki/Quantum_phase_estimation_algorithm) och litteratur för [amplitud förstärkning](https://en.wikipedia.org/wiki/Amplitude_amplification) används begreppet Oracle ofta.</span><span class="sxs-lookup"><span data-stu-id="b6292-119">In the [phase estimation](https://en.wikipedia.org/wiki/Quantum_phase_estimation_algorithm) and [amplitude amplification](https://en.wikipedia.org/wiki/Amplitude_amplification) literature the concept of an oracle appears frequently.</span></span>
<span data-ttu-id="b6292-120">Här är termen Oracle en blackbox Quantum-underrutin som agerar på en uppsättning qubits och returnerar svaret som en fas.</span><span class="sxs-lookup"><span data-stu-id="b6292-120">Here the term oracle refers to a blackbox quantum subroutine that acts upon a set of qubits and returns the answer as a phase.</span></span>
<span data-ttu-id="b6292-121">Den här subrutinen kan ofta ses som en inläsning av en Quantum-algoritm som godkänner Oracle, förutom andra parametrar, och som använder en serie Quantum-åtgärder och som behandlar ett anrop till den här Quantum-underrutinen som om det vore en grundläggande grind.</span><span class="sxs-lookup"><span data-stu-id="b6292-121">This subroutine often can be thought of as an input to a quantum algorithm that accepts the oracle, in addition to some other parameters, and applies a series of quantum operations and treating a call to this quantum subroutine as if it were a fundamental gate.</span></span>
<span data-ttu-id="b6292-122">För att du ska kunna implementera den större algoritmen måste en konkret nedbrytning av Oracle till fundamental Gates tillhandahållas, men sådan dekomposition behövs inte för att förstå algoritmen som anropar Oracle.</span><span class="sxs-lookup"><span data-stu-id="b6292-122">Obviously, in order to actually implement the larger algorithm a concrete decomposition of the oracle into fundamental gates must be provided but such a decomposition is not needed in order to understand the algorithm that calls the oracle.</span></span>
<span data-ttu-id="b6292-123">I Q# representeras den här abstraktionen med hjälp av den här typen av värden i första klass, så att åtgärder kan skickas till implementeringar av Quantum-algoritmer i ett svart-box.</span><span class="sxs-lookup"><span data-stu-id="b6292-123">In Q#, this abstraction is represented by using that operations are first-class values, such that operations can be passed to implementations of quantum algorithms in a black-box manner.</span></span>
<span data-ttu-id="b6292-124">Dessutom används användardefinierade typer för att märka olika Oracle-representationer på ett typ säkert sätt, vilket gör det svårt att oavsiktligt dela olika typer av svarta Box-åtgärder.</span><span class="sxs-lookup"><span data-stu-id="b6292-124">Moreover, user-defined types are used to label the different oracle representations in a type-safe way, making it difficult to accidentally conflate different kinds of black box operations.</span></span>

<span data-ttu-id="b6292-125">Sådana Oracle visas i ett antal olika kontexter, inklusive berömda-exempel, till exempel [Grover search](https://en.wikipedia.org/wiki/Grover%27s_algorithm) -och Quantum simulering-algoritmer.</span><span class="sxs-lookup"><span data-stu-id="b6292-125">Such oracles appear in a number of different contexts, including famous examples such as [Grover's search](https://en.wikipedia.org/wiki/Grover%27s_algorithm) and quantum simulation algorithms.</span></span>
<span data-ttu-id="b6292-126">Här fokuserar vi på de Oracle som behövs för bara två program: amplitud förstärkning och fas uppskattning.</span><span class="sxs-lookup"><span data-stu-id="b6292-126">Here we focus on the oracles needed for just two applications: amplitude amplification and phase estimation.</span></span>
<span data-ttu-id="b6292-127">Vi ska först diskutera amplituds förstärknings Oracle innan du fortsätter till fas uppskattningen.</span><span class="sxs-lookup"><span data-stu-id="b6292-127">We will first discuss amplitude amplification oracles before proceeding to phase estimation.</span></span>

### <a name="amplitude-amplification-oracles"></a><span data-ttu-id="b6292-128">Oracle-förstärkning för amplitud</span><span class="sxs-lookup"><span data-stu-id="b6292-128">Amplitude Amplification Oracles</span></span> ###

<span data-ttu-id="b6292-129">Algoritmen för amplitud förstärkning syftar till att utföra en rotation mellan ett ursprungligt tillstånd och ett slutligt tillstånd genom att använda en sekvens av reflexer av staten.</span><span class="sxs-lookup"><span data-stu-id="b6292-129">The amplitude amplification algorithm aims to perform a rotation between an initial state and a final state by applying a sequence of reflections of the state.</span></span>
<span data-ttu-id="b6292-130">För att algoritmen ska fungera krävs en specifikation av båda dessa tillstånd.</span><span class="sxs-lookup"><span data-stu-id="b6292-130">In order for the algorithm to function, it needs a specification of both of these states.</span></span>
<span data-ttu-id="b6292-131">Dessa specifikationer ges av två Oracle-enheter.</span><span class="sxs-lookup"><span data-stu-id="b6292-131">These specifications are given by two oracles.</span></span>
<span data-ttu-id="b6292-132">Dessa Oracle fungerar genom att dela upp indata i två blank steg, ett "mål"-och under utrymme.</span><span class="sxs-lookup"><span data-stu-id="b6292-132">These oracles work by breaking the inputs into two spaces, a "target" subspace and an "initial" subspace.</span></span>
<span data-ttu-id="b6292-133">Oracle-enheterna identifierar sådana under utrymmen, liknande hur Pauli-operatörer identifierar två mellanslag genom att tillämpa en $ \pm $1-fas på dessa utrymmen.</span><span class="sxs-lookup"><span data-stu-id="b6292-133">The oracles identify such subspaces, similar to how Pauli operators identify two spaces, by applying a $\pm 1$ phase to these spaces.</span></span>
<span data-ttu-id="b6292-134">Den största skillnaden är att dessa utrymmen inte behöver vara hälften-blank steg i det här programmet.</span><span class="sxs-lookup"><span data-stu-id="b6292-134">The main difference is that these spaces need not be half-spaces in this application.</span></span>
<span data-ttu-id="b6292-135">Observera också att dessa två del utrymmen vanligt vis inte är ömsesidigt uteslutande: det kommer att vara vektorer som är medlemmar i båda områdena.</span><span class="sxs-lookup"><span data-stu-id="b6292-135">Also note that these two subspaces are not usually mutually exclusive: there will be vectors that are members of both spaces.</span></span>
<span data-ttu-id="b6292-136">Om detta inte var sant skulle amplitud-förstärkningen ha ingen påverkan, så vi behöver det inledande under utrymmet för att få icke-noll överlappande mål under utrymmet.</span><span class="sxs-lookup"><span data-stu-id="b6292-136">If this were not true then amplitude amplification would have no effect so we need the initial subspace to have non-zero overlap with the target subspace.</span></span>

<span data-ttu-id="b6292-137">Vi anger den första Oracle som vi behöver för amplitud-förstärkningen $P \_ $0, som definieras för att ha följande åtgärd.</span><span class="sxs-lookup"><span data-stu-id="b6292-137">We will denote the first oracle that we need for amplitude amplification to be $P\_0$, defined to have the following action.</span></span>  <span data-ttu-id="b6292-138">För alla delstater $ \ket{x} $ i "första" under utrymmet $P \_ 0 \ket{x} =-\ket{x} $ och för alla tillstånd $ \ket{y} $ som inte ingår i det här under utrymmet har vi $P \_ 0 \ket{y} = \ket{y} $.</span><span class="sxs-lookup"><span data-stu-id="b6292-138">For all states $\ket{x}$ in the "initial" subspace $P\_0 \ket{x} = -\ket{x}$ and for all states $\ket{y}$ that are not in this subspace we have $P\_0 \ket{y} = \ket{y}$.</span></span>
<span data-ttu-id="b6292-139">Oracle som markerar mål under utrymmet, $P _1 $, tar exakt samma formulär.</span><span class="sxs-lookup"><span data-stu-id="b6292-139">The oracle that marks the target subspace, $P_1$, takes exactly the same form.</span></span>
<span data-ttu-id="b6292-140">För alla tillstånd $ \ket{x} $ i mål under utrymmet (dvs. för alla tillstånd som du vill att algoritmen ska mata ut), $P _1 \ ket {x} =-\ket{x} $.</span><span class="sxs-lookup"><span data-stu-id="b6292-140">For all states $\ket{x}$ in the target subspace (i.e., for all states that you'd like the algorithm to output), $P_1\ket{x} = -\ket{x}$.</span></span>
<span data-ttu-id="b6292-141">På samma sätt gäller för alla tillstånd $ \ket{y} $ som inte finns i mål under utrymmet $P _1 \ ket {y} = \ket{y} $.</span><span class="sxs-lookup"><span data-stu-id="b6292-141">Similarly, for all states $\ket{y}$ that are not in the target subspace $P_1\ket{y} = \ket{y}$.</span></span>
<span data-ttu-id="b6292-142">Dessa två reflektioner kombineras sedan för att bilda en operatör som agerar i ett enda steg av amplitud-förstärkning, $Q =-P_0 P_1 $, där det totala minus tecknet bara är viktigt att tänka på i kontrollerade program.</span><span class="sxs-lookup"><span data-stu-id="b6292-142">These two reflections are then combined to form an operator that enacts a single step of amplitude amplification, $Q = -P_0 P_1$, where the overall minus sign is only important to consider in controlled applications.</span></span>
<span data-ttu-id="b6292-143">Amplitud-förstärkningen fortsätter sedan genom att göra ett ursprungligt tillstånd, $ \ket{\psi} $ som är i det första under utrymmet och sedan utföra $ \ket{\psi} \mapsto Q ^ m \ket{\psi} $.</span><span class="sxs-lookup"><span data-stu-id="b6292-143">Amplitude amplification then proceeds by taking an initial state, $\ket{\psi}$ that is in the initial subspace and then performs $\ket{\psi} \mapsto Q^m \ket{\psi}$.</span></span>
<span data-ttu-id="b6292-144">Att utföra en sådan upprepning garanterar att om en börjar med ett ursprungligt tillstånd som har överlappande $ \sin ^ 2 (\theta) $ med det markerade utrymmet $m kommer den överlappande att bli $ \sin ^ 2 ([2 m + 1] \theta) $.</span><span class="sxs-lookup"><span data-stu-id="b6292-144">Performing such an iteration guarantees that if one starts with an initial state that has overlap $\sin^2(\theta)$ with the marked space then after $m$ iterations this overlap becomes $\sin^2([2m + 1] \theta)$.</span></span>
<span data-ttu-id="b6292-145">Vi vill därför vanligt vis välja $m $ som en kostnads fri parameter som $ [2 m + 1] \theta = \ Pi/2 $; sådana fasta val är dock inte lika viktiga för vissa former av amplitud förstärkning, till exempel amplitud förstärkning av fast punkt.</span><span class="sxs-lookup"><span data-stu-id="b6292-145">We therefore typically wish to choose $m$ to be a free parameter such that $[2m+1]\theta = \pi/2$; however, such rigid choices are not as important for some forms of amplitude amplification such as fixed point amplitude amplification.</span></span>
<span data-ttu-id="b6292-146">Med den här processen kan vi förbereda ett tillstånd i det markerade del utrymmet med hjälp av kvadratiskt färre frågor till märknings funktionen och tillstånds förberedelse funktionen än vad som skulle vara möjligt på en absolut klassisk enhet.</span><span class="sxs-lookup"><span data-stu-id="b6292-146">This process allows us to prepare a state in the marked subspace using quadratically fewer queries to the marking function and the state preparation function than would be possible on a strictly classical device.</span></span>
<span data-ttu-id="b6292-147">Det är därför som amplitud förstärkning är ett betydande Bygg block för många program av Quantum Computing.</span><span class="sxs-lookup"><span data-stu-id="b6292-147">This is why amplitude amplification is a significant building block for many applications of quantum computing.</span></span>

<span data-ttu-id="b6292-148">För att förstå hur du använder algoritmen, är det praktiskt att tillhandahålla ett exempel som ger en konstruktion av Oracle.</span><span class="sxs-lookup"><span data-stu-id="b6292-148">In order to understand how to use the algorithm, it is useful to provide an example that gives a construction of the oracles.</span></span>  <span data-ttu-id="b6292-149">Överväg att utföra Grover-algoritmen för Databass ökningar i den här inställningen.</span><span class="sxs-lookup"><span data-stu-id="b6292-149">Consider performing Grover's algorithm for database searches in this setting.</span></span>
<span data-ttu-id="b6292-150">I Groverens sökning är målet att transformera tillståndet $ \ket{+} ^ {\otimes n} = H ^ {\otimes n} \ket {0} $ till ett av (potentiellt) många markerade tillstånd.</span><span class="sxs-lookup"><span data-stu-id="b6292-150">In Grover's search the goal is to transform the state $\ket{+}^{\otimes n} = H^{\otimes n} \ket{0}$ into one of (potentially) many marked states.</span></span>
<span data-ttu-id="b6292-151">För att ytterligare förenkla ska vi bara titta på det fall där det enda markerade läget är $ \ket {0} $.</span><span class="sxs-lookup"><span data-stu-id="b6292-151">To further simplify, let's just look at the case where the only marked state is $\ket{0}$.</span></span>
<span data-ttu-id="b6292-152">Sedan har vi designat två Oracle: One som bara markerar det ursprungliga läget $ \ket{+} ^ {\otimes n} $ med ett minus tecken och en annan som markerar det markerade läget $ \ket {0} $ med ett minus tecken.</span><span class="sxs-lookup"><span data-stu-id="b6292-152">Then we have design two oracles: one that only marks the initial state $\ket{+}^{\otimes n}$ with a minus sign and another that marks the marked state $\ket{0}$ with a minus sign.</span></span>
<span data-ttu-id="b6292-153">Den sistnämnda porten kan implementeras med hjälp av följande process-åtgärder med hjälp av åtgärder för kontroll flöde i filen Canon:</span><span class="sxs-lookup"><span data-stu-id="b6292-153">The latter gate can be implemented using the following process operation, by using the control flow operations in the canon:</span></span>

```qsharp
operation ReflectAboutAllZeros(register : Qubit[]) : Unit 
is Adj + Ctl {

    // Apply $X$ gates to every qubit.
    ApplyToEach(X, register);

    // Apply an $n-1$ controlled $Z$-gate to the $n^{\text{th}}$ qubit.
    // This gate will lead to a sign flip if and only if every qubit is
    // $1$, which happens only if each of the qubits were $0$ before step 1.
    Controlled Z(Most(register), Tail(register));

    // Apply $X$ gates to every qubit.
    ApplyToEach(X, register);
}
```

<span data-ttu-id="b6292-154">Den här Oracle är sedan ett specialfall av <xref:microsoft.quantum.canon.rall1> åtgärden, som gör det möjligt att rotera med en godtycklig fas i stället för reflektions väskan $ \phi = \pi $.</span><span class="sxs-lookup"><span data-stu-id="b6292-154">This oracle is then a special case of the <xref:microsoft.quantum.canon.rall1> operation, which allows for rotating by an arbitrary phase instead of the reflection case $\phi = \pi$.</span></span>
<span data-ttu-id="b6292-155">I det här fallet `RAll1` liknar <xref:microsoft.quantum.intrinsic.r1> åtgärden inledning, i så här roterar vi om $ \ket{11\cdots1} $ i stället för qubit-tillstånd $ \ket {1} $.</span><span class="sxs-lookup"><span data-stu-id="b6292-155">In this case, `RAll1` is similar to the <xref:microsoft.quantum.intrinsic.r1> prelude operation, in that it rotates about $\ket{11\cdots1}$ instead of the single-qubit state $\ket{1}$.</span></span>

<span data-ttu-id="b6292-156">Oracle som markerar det inledande under utrymmet kan skapas på samma sätt.</span><span class="sxs-lookup"><span data-stu-id="b6292-156">The oracle that marks the initial subspace can be constructed similarly.</span></span>
<span data-ttu-id="b6292-157">I pseudocode:</span><span class="sxs-lookup"><span data-stu-id="b6292-157">In pseudocode:</span></span>

1. <span data-ttu-id="b6292-158">Använd $H $ Gates för varje qubit.</span><span class="sxs-lookup"><span data-stu-id="b6292-158">Apply $H$ gates to every qubit.</span></span>
2. <span data-ttu-id="b6292-159">Använd $X $ Gates för varje qubit.</span><span class="sxs-lookup"><span data-stu-id="b6292-159">Apply $X$ gates to every qubit.</span></span>
3. <span data-ttu-id="b6292-160">Använd en $n-$1-kontrollerad $Z $-grind till $n ^ {\text{th}} $ qubit.</span><span class="sxs-lookup"><span data-stu-id="b6292-160">Apply an $n-1$ controlled $Z$-gate to the $n^{\text{th}}$ qubit.</span></span>
4. <span data-ttu-id="b6292-161">Använd $X $ Gates för varje qubit.</span><span class="sxs-lookup"><span data-stu-id="b6292-161">Apply $X$ gates to every qubit.</span></span>
5. <span data-ttu-id="b6292-162">Använd $H $ Gates för varje qubit.</span><span class="sxs-lookup"><span data-stu-id="b6292-162">Apply $H$ gates to every qubit.</span></span>

<span data-ttu-id="b6292-163">Den här gången demonstrerar vi också användning <xref:microsoft.quantum.canon.applywith> tillsammans med <xref:microsoft.quantum.canon.rall1> åtgärden som diskuteras ovan:</span><span class="sxs-lookup"><span data-stu-id="b6292-163">This time, we also demonstrate using <xref:microsoft.quantum.canon.applywith> together with the <xref:microsoft.quantum.canon.rall1> operation discussed above:</span></span>

```qsharp
operation ReflectAboutInitial(register : Qubit[]) : Unit
is Adj + Ctl {
    ApplyWithCA(ApplyToEach(H, _), ApplyWith(ApplyToEach(X, _), RAll1(_, PI()), _), register);
}
```

<span data-ttu-id="b6292-164">Vi kan sedan kombinera dessa två Oracle-grupper för att rotera mellan de två tillstånden och deterministiskt Transform $ \ket{+} ^ {\otimes n} $ till $ \ket {0} $ med ett antal lager av Hadamard-portar som är proportionella till $ \sqrt{2 ^ n} $ (ie $m \propto \sqrt{2 ^ n} $) jämfört med de ungefär $2 ^ n $-lager som skulle behövas för att icke-deterministiskt ska förbereda $ \ket {0} $-tillstånd genom att förbereda och mäta det ursprungliga läget tills resultatet $0 $ observeras.</span><span class="sxs-lookup"><span data-stu-id="b6292-164">We can then combine these two oracles together to rotate between the two states and deterministically transform $\ket{+}^{\otimes n}$ to $\ket{0}$ using a number of layers of Hadamard gates that is proportional to $\sqrt{2^n}$ (ie $m\propto \sqrt{2^n}$) versus the roughly $2^n$ layers that would be needed to non-deterministically prepare the $\ket{0}$ state by preparing and measuring the initial state until the outcome $0$ is observed.</span></span>

### <a name="phase-estimation-oracles"></a><span data-ttu-id="b6292-165">Fas uppskattning i Oracle</span><span class="sxs-lookup"><span data-stu-id="b6292-165">Phase Estimation Oracles</span></span> ###

<span data-ttu-id="b6292-166">För fas uppskattning är Oracle-formerna något mer naturliga.</span><span class="sxs-lookup"><span data-stu-id="b6292-166">For phase estimation the oracles are somewhat more natural.</span></span>
<span data-ttu-id="b6292-167">Syftet med fas uppskattning är att utforma en subrutin som kan sampla från Eigenvalues i en enhetlig matris.</span><span class="sxs-lookup"><span data-stu-id="b6292-167">The aim in phase estimation is to design a subroutine that is capable of sampling from the eigenvalues of a unitary matrix.</span></span>
<span data-ttu-id="b6292-168">Den här metoden är inte användbar i Quantum-simuleringen eftersom det för många fysiska problem i kemi-och material vetenskap i dessa Eigenvalues ger Energies av Quantum-system, vilket ger oss värdefull information om fas diagram för material och reaktions dynamik för molekyler.</span><span class="sxs-lookup"><span data-stu-id="b6292-168">This method is indispensable in quantum simulation because for many physical problems in chemistry and material science these eigenvalues give the ground-state energies of quantum systems which provides us valuable information about the phase diagrams of materials and reaction dynamics for molecules.</span></span>
<span data-ttu-id="b6292-169">Varje smak av fas uppskattning behöver en enhetlighet.</span><span class="sxs-lookup"><span data-stu-id="b6292-169">Every flavor of phase estimation needs an input unitary.</span></span>
<span data-ttu-id="b6292-170">Den här enhetliga beskrivningen beskrivs av en av två typer av Oracle.</span><span class="sxs-lookup"><span data-stu-id="b6292-170">This unitary is customarily described by one of two types of oracles.</span></span>

> [!TIP]
> <span data-ttu-id="b6292-171">Båda typerna av Oracle som beskrivs nedan beskrivs i exemplen.</span><span class="sxs-lookup"><span data-stu-id="b6292-171">Both of the oracle types described below are covered in the samples.</span></span>
> <span data-ttu-id="b6292-172">Om du vill veta mer om kontinuerliga frågor och Oracle kan du se [ **PhaseEstimation** -exemplet](https://github.com/microsoft/Quantum/tree/master/samples/characterization/phase-estimation).</span><span class="sxs-lookup"><span data-stu-id="b6292-172">To learn more about continuous query oracles, please see the [**PhaseEstimation** sample](https://github.com/microsoft/Quantum/tree/master/samples/characterization/phase-estimation).</span></span>
> <span data-ttu-id="b6292-173">Om du vill veta mer om diskreta frågor och Oracle kan du se [ **IsingPhaseEstimation** -exemplet](https://github.com/microsoft/Quantum/tree/master/samples/simulation/ising/phase-estimation).</span><span class="sxs-lookup"><span data-stu-id="b6292-173">To learn more about discrete query oracles, please see the [**IsingPhaseEstimation** sample](https://github.com/microsoft/Quantum/tree/master/samples/simulation/ising/phase-estimation).</span></span>

<span data-ttu-id="b6292-174">Den första typen av Oracle, som vi anropar en diskret fråga i Oracle och representerar den användardefinierade typen <xref:microsoft.quantum.oracles.discreteoracle> , inbegriper helt enkelt en enhetlig matris.</span><span class="sxs-lookup"><span data-stu-id="b6292-174">The first type of oracle, which we call a discrete query oracle and represent with the user-defined type <xref:microsoft.quantum.oracles.discreteoracle>, simply involves a unitary matrix.</span></span>
<span data-ttu-id="b6292-175">Om $U $ är den höga vars Eigenvalues vi vill uppskatta, är Oracle för $U $ helt enkelt ett enda sätt att använda en subrutin som implementerar $U $.</span><span class="sxs-lookup"><span data-stu-id="b6292-175">If $U$ is the unitary whose eigenvalues we wish to estimate then the oracle for $U$ is simply a stand-in for a subroutine that implements $U$.</span></span>
<span data-ttu-id="b6292-176">Det kan till exempel ta $U $ att vara den Oracle $Q $ som definieras ovan för amplituds uppskattning.</span><span class="sxs-lookup"><span data-stu-id="b6292-176">For example, one could take $U$ to be the oracle $Q$ defined above for amplitude estimation.</span></span>
<span data-ttu-id="b6292-177">Eigenvalues för den här matrisen kan användas för att uppskatta överlappningen mellan de initiala och mål tillstånden, $ \sin ^ 2 (\theta) $, med en kvadratiskt färre sampel än en som annars skulle behövas.</span><span class="sxs-lookup"><span data-stu-id="b6292-177">The eigenvalues of this matrix can be used to estimate the overlap between the initial and target states, $\sin^2(\theta)$, using quadratically fewer samples than one would need otherwise.</span></span>
<span data-ttu-id="b6292-178">Detta är programmet för fas uppskattning med hjälp av Grover Oracle $Q $ som inmatade moniker för amplitud-uppskattning.</span><span class="sxs-lookup"><span data-stu-id="b6292-178">This earns the application of phase estimation using the Grover oracle $Q$ as input the moniker of amplitude estimation.</span></span>
<span data-ttu-id="b6292-179">Ett annat vanligt program, som ofta används i Quantum metrologi, innebär en liten rotations vinkel.</span><span class="sxs-lookup"><span data-stu-id="b6292-179">Another common application, widely used in quantum metrology, involves estimating a small rotation angle.</span></span>
<span data-ttu-id="b6292-180">Med andra ord vill vi uppskatta $ \theta $ för en okänd rotations grind av formuläret $R _z (\theta) $.</span><span class="sxs-lookup"><span data-stu-id="b6292-180">In other words, we wish to estimate $\theta$ for an unknown rotation gate of the form $R_z(\theta)$.</span></span>
<span data-ttu-id="b6292-181">I sådana fall är underrutinen som vi skulle interagera med för att lära sig detta fasta värde på $ \theta $ för porten $ $ \begin{align} U & = R_z (\theta) \\ \\ & = \begin{bmatrix} e ^ {-i \theta/2} & 0 \\ \\ 0 & e ^ {i \ theta/2} \end{bmatrix}.</span><span class="sxs-lookup"><span data-stu-id="b6292-181">In such cases, the subroutine that we would interact with in order to learn this fixed value of $\theta$ for the gate is $$ \begin{align} U & = R_z(\theta) \\\\ & = \begin{bmatrix} e^{-i \theta / 2} & 0 \\\\ 0 & e^{i\theta/2} \end{bmatrix}.</span></span>
<span data-ttu-id="b6292-182">\end{align} $ $</span><span class="sxs-lookup"><span data-stu-id="b6292-182">\end{align} $$</span></span>

<span data-ttu-id="b6292-183">Den andra typen av Oracle som används i fas uppskattning är den kontinuerliga frågan Oracle, som representeras av <xref:microsoft.quantum.oracles.continuousoracle> typen.</span><span class="sxs-lookup"><span data-stu-id="b6292-183">The second type of oracle used in phase estimation is the continuous query oracle, represented by the <xref:microsoft.quantum.oracles.continuousoracle> type.</span></span>
<span data-ttu-id="b6292-184">En kontinuerlig fråga för beräkning av Oracle för fas tar formuläret $U (t) $ där $t $ är ett klassiskt känt reellt tal.</span><span class="sxs-lookup"><span data-stu-id="b6292-184">A continuous query oracle for phase estimation takes the form $U(t)$ where $t$ is a classically known real number.</span></span>
<span data-ttu-id="b6292-185">Om vi låter $U $ vara en fast enhetlig, tar den kontinuerliga frågan Oracle formen $U (t) = U ^ t $.</span><span class="sxs-lookup"><span data-stu-id="b6292-185">If we let $U$ be a fixed unitary then the continuous query oracle takes the form $U(t) = U^t$.</span></span>
<span data-ttu-id="b6292-186">Detta gör att vi kan fråga matriser som $ \sqrt{U} $, som inte kunde implementeras direkt i den diskreta fråge modellen.</span><span class="sxs-lookup"><span data-stu-id="b6292-186">This allows us to query matrices such as $\sqrt{U}$, which could not be implemented directly in the discrete query model.</span></span>

<span data-ttu-id="b6292-187">Den här typen av Oracle är värdefull när du inte har en viss enhetlighet, utan i stället vill lära dig egenskaperna för generatorn för den enhetliga.</span><span class="sxs-lookup"><span data-stu-id="b6292-187">This type of oracle is valuable when you're not probing a particular unitary, but rather wish to learn the properties of the generator of the unitary.</span></span>
<span data-ttu-id="b6292-188">I en dynamisk Quantum-simulering är målet till exempel att utforma Quantum-kretsar som närmar sig $U (t) = e ^ {-i H t} $ för en Hermitian-matris $H $ och utvecklings tid $t $.</span><span class="sxs-lookup"><span data-stu-id="b6292-188">For example, in dynamical quantum simulation the goal is to devise quantum circuits that closely approximate $U(t)=e^{-i H t}$ for a Hermitian matrix $H$ and evolution time $t$.</span></span>
<span data-ttu-id="b6292-189">Eigenvalues för $U (t) $ är direkt relaterat till Eigenvalues för $H $.</span><span class="sxs-lookup"><span data-stu-id="b6292-189">The eigenvalues of $U(t)$ are directly related to the eigenvalues of $H$.</span></span>
<span data-ttu-id="b6292-190">För att se detta bör du överväga en eigenvector av $H $: $H \ket{E} = E\ket {E} $ och det är enkelt att se från Power-seriens definition av matrisen exponent som $U (t) \ket{E} = e ^ {i\phi} \ ket {E} = e ^ {-iEt} \ket{E} $.</span><span class="sxs-lookup"><span data-stu-id="b6292-190">To see this, consider an eigenvector of $H$: $H \ket{E} = E\ket{E}$ then it is easy to see from the power-series definition of the matrix exponential that $U(t) \ket{E} = e^{i\phi}\ket{E}= e^{-iEt}\ket{E}$.</span></span>
<span data-ttu-id="b6292-191">Därför uppskattar eigenphase i $U (t) $ eigenvalue $E $ förutsatt att eigenvector $ \ket{E} $ är inmatat i algoritmen för fas uppskattning.</span><span class="sxs-lookup"><span data-stu-id="b6292-191">Thus estimating the eigenphase of $U(t)$ gives the eigenvalue $E$ assuming the eigenvector $\ket{E}$ is input into the phase estimation algorithm.</span></span>
<span data-ttu-id="b6292-192">I det här fallet kan värdet $t $ väljas på användarens eget gottfinnande eftersom det finns tillräckligt mycket små värdet $t $ eigenvalue $E $ kan inverteras unikt genom $E =-\ Fi/t $.</span><span class="sxs-lookup"><span data-stu-id="b6292-192">However, in this case the value $t$ can be chosen at the user's discretion since for any sufficiently small value of $t$ the eigenvalue $E$ can be uniquely inverted through $E=-\phi/t$.</span></span>
<span data-ttu-id="b6292-193">Eftersom Quantum simulerings metoder ger möjlighet att utföra en fraktions utveckling ger detta en ytterligare frihet vid frågor till den enhetliga frågan, särskilt när den diskreta fråge modellen bara tillåter att unitaries av formuläret $U ^ j $ till att gälla heltal $j $ den kontinuerliga frågan Oracle gör det möjligt för oss att approximera unitaries i formuläret $U ^ t $ för alla verkliga värdefulla $t $.</span><span class="sxs-lookup"><span data-stu-id="b6292-193">Since quantum simulation methods provide the ability to perform a fractional evolution, this grants phase estimation algorithms an additional freedom when querying the unitary, specifically while the discrete query model allows only unitaries of the form $U^j$ to applied for integer $j$ the continuous query oracle allows us to approximate unitaries of the form $U^t$ for any real valued $t$.</span></span>
<span data-ttu-id="b6292-194">Det är viktigt att du går igenom var och en av de sista ouncena av fas uppskattnings algoritmer eftersom vi kan välja exakt det experiment som skulle ge mest information om $E $; metoder som baseras på diskreta frågor måste göra detta genom att välja det bästa heltals antalet frågor i algoritmen.</span><span class="sxs-lookup"><span data-stu-id="b6292-194">This is important to squeeze every last ounce of efficiency out of phase estimation algorithms because it allows us to choose precisely the experiment that would provide the most information about $E$; whereas methods based on discrete queries must make do with compromising by choosing the best integer number of queries in the algorithm.</span></span>

<span data-ttu-id="b6292-195">Som ett konkret exempel på detta bör du överväga problemet med att uppskatta inte rotations vinkeln för en grind, men process frekvensen för ett roterande Quantum-system.</span><span class="sxs-lookup"><span data-stu-id="b6292-195">As a concrete example of this, consider the problem of estimating not the rotation angle of a gate but the procession frequency of a rotating quantum system.</span></span>
<span data-ttu-id="b6292-196">Den enhetliga som beskriver den här Quantum Dynamics är $U (t) = R_z (2 \ Omega t) $ för utvecklings tid $t $ och okänd frekvens $ \omega $.</span><span class="sxs-lookup"><span data-stu-id="b6292-196">The unitary that describes such quantum dynamics is $U(t)=R_z(2\omega t)$ for evolution time $t$ and unknown frequency $\omega$.</span></span>
<span data-ttu-id="b6292-197">I det här sammanhanget kan vi simulera $U (t) $ för alla $t $ med en enda $R _z $-grind och eftersom sådana inte behöver begränsa skapar till enbart diskreta frågor till den enhetliga.</span><span class="sxs-lookup"><span data-stu-id="b6292-197">In this context, we can simulate $U(t)$ for any $t$ using a single $R_z$ gate and as such do not need to restrict ourselves to only discrete queries to the unitary.</span></span>
<span data-ttu-id="b6292-198">En sådan kontinuerlig modell har också egenskapen att frekvenser som är större än $2 \ PI $ kan hämtas från fas uppskattnings processer som använder kontinuerliga frågor, eftersom den information som annars annars skulle maskeras av gren-klippen i logaritm-funktionen kan visas från resultaten av experiment som har utförts på värden som inte ligger i proportion till $t $.</span><span class="sxs-lookup"><span data-stu-id="b6292-198">Such a continuous model also has the property that frequencies greater than $2\pi$ can be learned from phase estimation processes that use continuous queries because phase information that would otherwise be masked by the branch-cuts of the logarithm function can be revealed from the results of experiments performed on non-commensurate values of $t$.</span></span>
<span data-ttu-id="b6292-199">Därför är det inte bara lämpligt för problem som den här kontinuerliga fråg ande frågan för fas uppskattning av Oracle, men det är också bättre än den diskreta fråge modellen.</span><span class="sxs-lookup"><span data-stu-id="b6292-199">Thus for problems such as this continuous query models for the phase estimation oracle are not only appropriate but are also preferable to the discrete query model.</span></span>
<span data-ttu-id="b6292-200">Av den här orsaken Q# finns funktioner för båda typerna av frågor och lämna dem till användaren för att bestämma en fas uppskattnings algoritm som passar deras behov och vilken typ av Oracle som är tillgänglig.</span><span class="sxs-lookup"><span data-stu-id="b6292-200">For this reason Q# has functionality for both forms of queries and leave it to the user to decide upon a phase estimation algorithm to fit their needs and the type of oracle that is available.</span></span>

## <a name="dynamical-generator-modeling"></a><span data-ttu-id="b6292-201">Modell för dynamisk Generator</span><span class="sxs-lookup"><span data-stu-id="b6292-201">Dynamical Generator Modeling</span></span> ##

<span data-ttu-id="b6292-202">Generatorer för tids utveckling beskriver hur tillstånd utvecklas med tiden.</span><span class="sxs-lookup"><span data-stu-id="b6292-202">Generators of time-evolution describe how states evolve through time.</span></span> <span data-ttu-id="b6292-203">Till exempel regleras dynamiken för ett Quantum-tillstånd $ \ket{\psi} $ av Schrödinger ekvation $ $ \begin{align} i\frac {d \ket{\psi (t)}} {d t} & = H \ket{\psi (t)}, \end{align} $ $ med en Hermitian-matris $H $, kallat Hamiltonian, som generator av rörelse.</span><span class="sxs-lookup"><span data-stu-id="b6292-203">For instance, the dynamics of a quantum state $\ket{\psi}$ is governed by the Schrödinger equation $$ \begin{align} i\frac{d \ket{\psi(t)}}{d t} & = H \ket{\psi(t)}, \end{align} $$ with a Hermitian matrix $H$, known as the Hamiltonian, as the generator of motion.</span></span> <span data-ttu-id="b6292-204">Fått ett första tillstånd $ \ket{\psi (0)} $ vid tiden $t = $0, den formella lösningen till den här ekvationen vid tidpunkten $t $ kan i princip skriva $ $ \begin{align} \ket{\psi (t)} = U (t) \ket{\psi (0)}, \end{align} $ $ där matrisen exponentiell $U (t) = e ^ {-i H t} $ är känd som den enhetliga tids utvecklings operatorn.</span><span class="sxs-lookup"><span data-stu-id="b6292-204">Given an initial state $\ket{\psi(0)}$ at time $t=0$, the formal solution to this equation at time $t$ may be, in principle, written $$ \begin{align} \ket{\psi(t)} = U(t)\ket{\psi(0)}, \end{align} $$ where the matrix exponential $U(t)=e^{-i H t}$ is known as the unitary time-evolution operator.</span></span> <span data-ttu-id="b6292-205">Även om vi fokuserar på generatorer för det här formuläret i följande betonar vi att konceptet är mer brett, till exempel simuleringen av öppna Quantum-system, eller till fler abstrakta differential formler.</span><span class="sxs-lookup"><span data-stu-id="b6292-205">Though we focus on generators of this form in the following, we emphasize that the concept applies more broadly, such as to the simulation of open quantum systems, or to more abstract differential equations.</span></span>

<span data-ttu-id="b6292-206">Ett primärt mål för dynamisk simulering är att implementera tids utvecklings operatorn för vissa Quantum-tillstånd som är kodade i qubits på en Quantum-dator.</span><span class="sxs-lookup"><span data-stu-id="b6292-206">A primary goal of dynamical simulation is to implement the time-evolution operator on some quantum state encoded in qubits of a quantum computer.</span></span>  <span data-ttu-id="b6292-207">I många fall kan Hamiltonian delas upp i en summa av vissa $d enklare och enklare villkor</span><span class="sxs-lookup"><span data-stu-id="b6292-207">In many cases, the Hamiltonian may be broken into a sum of some $d$ simpler terms</span></span>

<span data-ttu-id="b6292-208">$ $ \begin{align} H & = \sum ^ {d-1} _ {j = 0} H_j, \end{align} $ $</span><span class="sxs-lookup"><span data-stu-id="b6292-208">$$ \begin{align} H & = \sum^{d-1}_{j=0} H_j, \end{align} $$</span></span>

<span data-ttu-id="b6292-209">där tids utvecklingen för varje enskilt fall är lätt att implementera på en Quantum-dator.</span><span class="sxs-lookup"><span data-stu-id="b6292-209">where time-evolution by each term alone is easy to implement on a quantum computer.</span></span> <span data-ttu-id="b6292-210">Om $H _j $ till exempel är en Pauli $X _1X_2 $-operatör som agerar på de första och andra elementen i qubit `qubits` -registret, kan tids utvecklingen av den vara så fort som möjligt $t $ implementeras bara genom att anropa åtgärden `Exp([PauliX,PauliX], t, qubits[1..2])` , som har signatur `((Pauli[], Double, Qubit[]) => Unit is Adj + Ctl)` .</span><span class="sxs-lookup"><span data-stu-id="b6292-210">For instance, if $H_j$ is a Pauli $X_1X_2$ operator acting on the 1st and 2nd elements of the qubit register `qubits`, time-evolution by it for any time $t$ may be implemented simply by calling the operation `Exp([PauliX,PauliX], t, qubits[1..2])`, which has signature `((Pauli[], Double, Qubit[]) => Unit is Adj + Ctl)`.</span></span> <span data-ttu-id="b6292-211">Som vi diskuterade senare i Hamiltonian-simuleringen är det en lösning som sedan är att uppskatta tids utvecklingen genom $H $ med en sekvens med enklare åtgärder</span><span class="sxs-lookup"><span data-stu-id="b6292-211">As discussed later in Hamiltonian Simulation, one solution then is to approximate time-evolution by $H$ with a sequence of simpler operations</span></span>

<span data-ttu-id="b6292-212">$ $ \begin{align} U (t) & = \left (e ^ {-iH \_ 0 t/r} e ^ {-IH \_ 1 t/r} \cdots e ^ {-IH \_ {d-1} t/r} \right) ^ {r} + \mathcal{O} (d ^ 2 \ max_j \\ | H \_ j \\ | ^ 2 t ^ 2/r), \end{align} $ $</span><span class="sxs-lookup"><span data-stu-id="b6292-212">$$ \begin{align} U(t) & = \left( e^{-iH\_0 t / r} e^{-iH\_1 t / r} \cdots e^{-iH\_{d-1} t / r} \right)^{r} + \mathcal{O}(d^2 \max_j \\|H\_j\\|^2 t^2/r), \end{align} $$</span></span>

<span data-ttu-id="b6292-213">där heltals $r > $0 styr det ungefärliga felet.</span><span class="sxs-lookup"><span data-stu-id="b6292-213">where the integer $r > 0$ controls the approximation error.</span></span>

<span data-ttu-id="b6292-214">Modell biblioteket för dynamisk generator ger ett ramverk för att systematiskt koda komplicerade generatorer i termer av enklare generatorer.</span><span class="sxs-lookup"><span data-stu-id="b6292-214">The dynamical generator modeling library provides a framework for systematically encoding complicated generators in terms of simpler generators.</span></span> <span data-ttu-id="b6292-215">En sådan beskrivning kan sedan skickas till, till exempel bibliotek för simulering för att implementera tids utveckling med en vald simulerings algoritm, med många detaljer som automatiskt tar hand om.</span><span class="sxs-lookup"><span data-stu-id="b6292-215">Such a description may then be passed to, say, the simulation library to implement time-evolution by a simulation algorithm of choice, with many details automatically taken care of.</span></span>

> [!TIP]
> <span data-ttu-id="b6292-216">Det dynamiska Generator biblioteket som beskrivs nedan beskrivs i exemplen.</span><span class="sxs-lookup"><span data-stu-id="b6292-216">The dynamical generator library described below is covered in the samples.</span></span> <span data-ttu-id="b6292-217">Ett exempel som baseras på Ising-modellen finns i [ **IsingGenerators** -exemplet](https://github.com/microsoft/Quantum/tree/master/samples/simulation/ising/generators).</span><span class="sxs-lookup"><span data-stu-id="b6292-217">For an example based on the Ising model, please see the [**IsingGenerators** sample](https://github.com/microsoft/Quantum/tree/master/samples/simulation/ising/generators).</span></span>
> <span data-ttu-id="b6292-218">Ett exempel som baseras på molekylen väte finns i exemplen [**H2SimulationCmdLine**](https://github.com/microsoft/Quantum/tree/master/samples/simulation/h2/command-line) och [**H2SimulationGUI**](https://github.com/microsoft/Quantum/tree/master/samples/simulation/h2/gui) .</span><span class="sxs-lookup"><span data-stu-id="b6292-218">For an example based on molecular Hydrogen, please see the [**H2SimulationCmdLine**](https://github.com/microsoft/Quantum/tree/master/samples/simulation/h2/command-line) and [**H2SimulationGUI**](https://github.com/microsoft/Quantum/tree/master/samples/simulation/h2/gui) samples.</span></span>

### <a name="complete-description-of-a-generator"></a><span data-ttu-id="b6292-219">Fullständig beskrivning av en generator</span><span class="sxs-lookup"><span data-stu-id="b6292-219">Complete Description of a Generator</span></span> ###

<span data-ttu-id="b6292-220">På den översta nivån finns en fullständig beskrivning av en Hamiltonian i den `EvolutionGenerator` användardefinierade typ som har två komponenter.:</span><span class="sxs-lookup"><span data-stu-id="b6292-220">At the top level, a complete description of a Hamiltonian is contained in the `EvolutionGenerator` user-defined type which has two components.:</span></span>

```qsharp
newtype EvolutionGenerator = (EvolutionSet, GeneratorSystem);
```

<span data-ttu-id="b6292-221">Den `GeneratorSystem` användardefinierade typen är en klassisk Beskrivning av Hamiltonian.</span><span class="sxs-lookup"><span data-stu-id="b6292-221">The `GeneratorSystem` user-defined type is a classical description of the Hamiltonian.</span></span>

```qsharp
newtype GeneratorSystem = (Int, (Int -> GeneratorIndex));
```

<span data-ttu-id="b6292-222">Det första elementet `Int` i tuppeln lagrar antalet termer $d $ i Hamiltonian och det andra elementet `(Int -> GeneratorIndex)` är en funktion som mappar ett heltals index i $ \{ 0, 1,..., d-1 \} $ till en `GeneratorIndex` användardefinierad typ som unikt identifierar varje primitiv term i Hamiltonian.</span><span class="sxs-lookup"><span data-stu-id="b6292-222">The first element `Int` of the tuple stores the number of terms $d$ in the Hamiltonian, and the second element `(Int -> GeneratorIndex)` is a function that maps an integer index in $\{0,1,...,d-1\}$ to a `GeneratorIndex` user-defined type which uniquely identifies each primitive term in the Hamiltonian.</span></span> <span data-ttu-id="b6292-223">Observera att genom att uttrycka samlings villkoren i Hamiltonian som en funktion i stället för som en matris `GeneratorIndex[]` , tillåter detta att du använder den här åtgärden på ett sätt `GeneratorIndex` som är särskilt användbart när du beskriver Hamiltonians med ett stort antal villkor.</span><span class="sxs-lookup"><span data-stu-id="b6292-223">Note that by expressing the collection of terms in the Hamiltonian as a function rather than as an array `GeneratorIndex[]`, this allows for on-the-fly computation of the `GeneratorIndex` which is especially useful when describing Hamiltonians with a large number of terms.</span></span>

<span data-ttu-id="b6292-224">Det är mycket viktigt att du inte tillämpar någon konvention om vilka primitiva termer som identifieras av `GeneratorIndex` är lätta att simulera.</span><span class="sxs-lookup"><span data-stu-id="b6292-224">Crucially, we do not impose a convention on what primitive terms identified by the `GeneratorIndex` are easy-to-simulate.</span></span> <span data-ttu-id="b6292-225">Primitiva termer kan till exempel vara Pauli-operatörer enligt beskrivningen ovan, men de kan också vara Fermionic Annihilation och skapande operatörer som ofta används i Quantum kemi-simulering.</span><span class="sxs-lookup"><span data-stu-id="b6292-225">For instance, primitive terms could be Pauli operators as discussed above, but they could also be Fermionic annihilation and creation operators commonly used in quantum chemistry simulation.</span></span> <span data-ttu-id="b6292-226">En `GeneratorIndex` är meningslös eftersom den inte beskriver hur tids utvecklingen på den period som det pekar på kan implementeras som en Quantum-krets.</span><span class="sxs-lookup"><span data-stu-id="b6292-226">By itself, a `GeneratorIndex` is meaningless as it does not describe how time-evolution by the term it points to may be implemented as a quantum circuit.</span></span>

<span data-ttu-id="b6292-227">Detta löses genom att ange en `EvolutionSet` användardefinierad typ som mappar alla, som `GeneratorIndex` hämtas från vissa kanoniska uppsättningar, till en enhetlig operatör, `EvolutionUnitary` uttryckt som en Quantum-krets.</span><span class="sxs-lookup"><span data-stu-id="b6292-227">This is resolved by specifying an `EvolutionSet` user-defined type that maps any `GeneratorIndex`, drawn from some canonical set, to a unitary operator, the `EvolutionUnitary`, expressed as a quantum circuit.</span></span> <span data-ttu-id="b6292-228">I `EvolutionSet` definieras konventionen för hur en `GeneratorIndex` är strukturerad och definierar också en uppsättning möjliga `GeneratorIndex` .</span><span class="sxs-lookup"><span data-stu-id="b6292-228">The `EvolutionSet` defines the convention of how a `GeneratorIndex` is structured, and also defines the set of possible `GeneratorIndex`.</span></span>

```qsharp
newtype EvolutionSet = (GeneratorIndex -> EvolutionUnitary);
```

### <a name="pauli-operator-generators"></a><span data-ttu-id="b6292-229">Pauli-operatörs generatorer</span><span class="sxs-lookup"><span data-stu-id="b6292-229">Pauli Operator Generators</span></span> ###

<span data-ttu-id="b6292-230">Ett konkret och användbart exempel på generatorer är Hamiltonians som är en summa av Pauli-operatörer, var och en med olika koefficienter.</span><span class="sxs-lookup"><span data-stu-id="b6292-230">A concrete and useful example of generators are Hamiltonians that are a sum of Pauli operators, each possibly with a different coefficient.</span></span>
<span data-ttu-id="b6292-231">$ $ \begin{align} H & = \sum ^ {d-1} _ {j = 0} a_j H_j, \end{align} $ $ där varje $ \hat H_j $ nu har ritats från Pauli-gruppen.</span><span class="sxs-lookup"><span data-stu-id="b6292-231">$$ \begin{align} H & = \sum^{d-1}_{j=0} a_j H_j, \end{align} $$ where each $\hat H_j$ is now drawn from the Pauli group.</span></span> <span data-ttu-id="b6292-232">För sådana system tillhandahåller vi den `PauliEvolutionSet()` typ `EvolutionSet` som definierar en konvention för hur ett element i Pauli-gruppen och en koefficient kan identifieras av en `GeneratorIndex` , som har följande signatur.</span><span class="sxs-lookup"><span data-stu-id="b6292-232">For such systems, we provide the `PauliEvolutionSet()` of type `EvolutionSet` that defines a convention for how an element of the Pauli group and a coefficient may be identified by a `GeneratorIndex`, which has the following signature.</span></span>

```qsharp
newtype GeneratorIndex = ((Int[], Double[]), Int[]);
```

<span data-ttu-id="b6292-233">I vår kodning anger den första parametern `Int[]` en Pauli-sträng där $ \Hat I\rightarrow $0, $ \Hat X\rightarrow $1, $ \Hat Y\rightarrow $2 och $ \Hat Z\rightarrow $3.</span><span class="sxs-lookup"><span data-stu-id="b6292-233">In our encoding, the first parameter `Int[]` specifies a Pauli string, where $\hat I\rightarrow 0$, $\hat X\rightarrow 1$, $\hat Y\rightarrow 2$, and $\hat Z\rightarrow 3$.</span></span> <span data-ttu-id="b6292-234">Den andra parametern `Double[]` lagrar koefficienten för Pauli-strängen i Hamiltonian.</span><span class="sxs-lookup"><span data-stu-id="b6292-234">The second parameter `Double[]` stores the coefficient of the Pauli string in the Hamiltonian.</span></span> <span data-ttu-id="b6292-235">Observera att endast det första elementet i matrisen används.</span><span class="sxs-lookup"><span data-stu-id="b6292-235">Note that only the first element of this array is used.</span></span> <span data-ttu-id="b6292-236">Den tredje parametern `Int[]` indexerar den qubits som den här Pauli-strängen agerar på och får inte ha några dubbla element.</span><span class="sxs-lookup"><span data-stu-id="b6292-236">The third parameter `Int[]` indexes the qubits that this Pauli string acts on, and must have no duplicate elements.</span></span> <span data-ttu-id="b6292-237">Därför kan Hamiltonian-termen $0,4 \hat X_0 \hat Y_8 \hat I_2 \hat Z_1 $ visas som</span><span class="sxs-lookup"><span data-stu-id="b6292-237">Thus the Hamiltonian term $0.4 \hat X_0 \hat Y_8\hat I_2\hat Z_1$ may be represented as</span></span>

```qsharp
let generatorIndexExample = GeneratorIndex(([1,2,0,3], [0.4]]), [0,8,2,1]);
```

<span data-ttu-id="b6292-238">`PauliEvolutionSet()`Är en funktion som mappar något `GeneratorIndex` av detta formulär till en `EvolutionUnitary` med följande signatur.</span><span class="sxs-lookup"><span data-stu-id="b6292-238">The `PauliEvolutionSet()` is a function that maps any `GeneratorIndex` of this form to an `EvolutionUnitary` with the following signature.</span></span>

```qsharp
newtype EvolutionUnitary = ((Double, Qubit[]) => Unit is Adj + Ctl);
```

<span data-ttu-id="b6292-239">Den första parametern representerar en tids period som kommer att multipliceras med koefficienten i den `GeneratorIndex` enhetliga utvecklingen.</span><span class="sxs-lookup"><span data-stu-id="b6292-239">The first parameter represents a time-duration, that will be multiplied by the coefficient in the `GeneratorIndex`, of unitary evolution.</span></span> <span data-ttu-id="b6292-240">Den andra parametern är den qubit som registrerar de enhetliga åtgärderna på.</span><span class="sxs-lookup"><span data-stu-id="b6292-240">The second parameter is the qubit register the unitary acts on.</span></span> 

### <a name="time-dependent-generators"></a><span data-ttu-id="b6292-241">Tids beroende generatorer</span><span class="sxs-lookup"><span data-stu-id="b6292-241">Time-Dependent Generators</span></span> ###

<span data-ttu-id="b6292-242">I många fall är vi också intresserade av att utforma tids beroende generatorer som kan uppstå i Schrödinger ekvation $ $ \begin{align} i\frac {d \ket{\psi (t)}} {d t} & = \hat H (t) \ket{\psi (t)}, \end{align} $ $ där generatorn $ \hat H (t) $ nu är tids beroende.</span><span class="sxs-lookup"><span data-stu-id="b6292-242">In many cases, we are also interested in modelling time-dependent generators, as might occur in the Schrödinger equation $$ \begin{align} i\frac{d \ket{\psi(t)}}{d t} & = \hat H(t) \ket{\psi(t)}, \end{align} $$ where the generator $\hat H(t)$ is now time-dependent.</span></span> <span data-ttu-id="b6292-243">Det är enkelt att utöka tillägget från tids oberoende generatorer ovan till det här fallet.</span><span class="sxs-lookup"><span data-stu-id="b6292-243">The extension from the time-independent generators above to this case is straightforward.</span></span> <span data-ttu-id="b6292-244">I stället för att ha en fast `GeneratorSystem` Beskrivning av Hamiltonian för alla tider $t $, har vi i stället den `GeneratorSystemTimeDependent` användardefinierade typen.</span><span class="sxs-lookup"><span data-stu-id="b6292-244">Rather than having a fixed `GeneratorSystem` describing the Hamiltonian for all times $t$, we instead have the `GeneratorSystemTimeDependent` user-defined type.</span></span>

```qsharp
newtype GeneratorSystemTimeDependent = (Double -> GeneratorSystem);
```

<span data-ttu-id="b6292-245">Den första parametern är en kontinuerlig schema parameter $s \in [0, 1] $ och funktioner av den här typen returnerar a `GeneratorSystem` för det schemat.</span><span class="sxs-lookup"><span data-stu-id="b6292-245">The first parameter is a continuous schedule parameter $s\in [0,1]$, and functions of this type return a `GeneratorSystem` for that schedule.</span></span> <span data-ttu-id="b6292-246">Observera att schema parametern kan vara linjärt relaterad till den fysiska tids parametern, t. ex. $s = t/T $, för viss total tid för simulering $T $.</span><span class="sxs-lookup"><span data-stu-id="b6292-246">Note that the schedule parameter may be linearly related to the physical time parameter e.g. $s = t / T$, for some total time of simulation $T$.</span></span> <span data-ttu-id="b6292-247">I allmänhet behöver detta inte vara fallet.</span><span class="sxs-lookup"><span data-stu-id="b6292-247">In general however, this need not be the case.</span></span>

<span data-ttu-id="b6292-248">På samma sätt kräver en fullständig beskrivning av generatorn en `EvolutionSet` , och därför definieras en `EvolutionSchedule` användardefinierad typ.</span><span class="sxs-lookup"><span data-stu-id="b6292-248">Similarly, a complete description of this generator requires an `EvolutionSet`, and so we define an `EvolutionSchedule` user-defined type.</span></span>

```qsharp
newtype EvolutionSchedule = (EvolutionSet, GeneratorSystemTimeDependent);
```
