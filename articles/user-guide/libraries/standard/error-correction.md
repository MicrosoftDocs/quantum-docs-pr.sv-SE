---
title: 'Fel korrigering i :::no-loc(Q#)::: standard biblioteken'
description: 'Lär dig hur du använder fel när du korrigerar koder i dina :::no-loc(Q#)::: program samtidigt som du skyddar qubits-tillstånd.'
author: QuantumWriter
uid: microsoft.quantum.libraries.error-correction
ms.author: martinro
ms.date: 12/11/2017
ms.topic: article
no-loc:
- ':::no-loc(Q#):::'
- ':::no-loc($$v):::'
ms.openlocfilehash: 94251e185cea65c5fc08ed70d5fba9b7b19501e3
ms.sourcegitcommit: 29e0d88a30e4166fa580132124b0eb57e1f0e986
ms.translationtype: MT
ms.contentlocale: sv-SE
ms.lasthandoff: 10/27/2020
ms.locfileid: "92692048"
---
# <a name="error-correction"></a><span data-ttu-id="81a3a-103">Fel korrigering</span><span class="sxs-lookup"><span data-stu-id="81a3a-103">Error Correction</span></span> #

## <a name="introduction"></a><span data-ttu-id="81a3a-104">Introduktion</span><span class="sxs-lookup"><span data-stu-id="81a3a-104">Introduction</span></span> ##

<span data-ttu-id="81a3a-105">I klassisk data behandling, om en vill skydda en bit mot fel, kan det ofta räcka att representera den biten av en *logisk bit* genom att upprepa data biten.</span><span class="sxs-lookup"><span data-stu-id="81a3a-105">In classical computing, if one wants to protect a bit against errors, it can often suffice to represent that bit by a *logical bit* by repeating the data bit.</span></span>
<span data-ttu-id="81a3a-106">Låt säga att $ \overline {0} = $0 är kodningen för data bit 0, där vi använder en rad ovanför etiketten 0 för att ange att den är en kodning av en bit i status 0.</span><span class="sxs-lookup"><span data-stu-id="81a3a-106">For instance, let $\overline{0} = 000$ be the encoding of the data bit 0, where we use the a line above the label 0 to indicate that it is an encoding of a bit in the 0 state.</span></span>
<span data-ttu-id="81a3a-107">Om vi på liknande sätt meddelar $ \overline {1} = $111, har vi en enkel upprepnings kod som skyddar mot ett fel i en bit-flip.</span><span class="sxs-lookup"><span data-stu-id="81a3a-107">If we similarly let $\overline{1} = 111$, then we have a simple repetition code that protects against any one bit flip error.</span></span>
<span data-ttu-id="81a3a-108">Det vill säga om någon av de tre bitarna är vänd, kan vi återställa statusen för den logiska biten genom att göra en majoritets röst.</span><span class="sxs-lookup"><span data-stu-id="81a3a-108">That is, if any of the three bits are flipped, then we can recover the state of the logical bit by taking a majority vote.</span></span>
<span data-ttu-id="81a3a-109">Även om den klassiska fel korrigeringen är en mycket rikare del som det här exemplet (vi rekommenderar att du använder rad [Introduktion till kodnings teori](https://www.springer.com/us/book/9783540641339)), pekar upprepnings koden ovan redan på ett möjligt problem med att skydda Quantum-information.</span><span class="sxs-lookup"><span data-stu-id="81a3a-109">Though classical error correction is a much richer subject that this particular example (we recommend [Lint's introduction to coding theory](https://www.springer.com/us/book/9783540641339)), the repetition code above already points to a possible problem in protecting quantum information.</span></span>
<span data-ttu-id="81a3a-110">Dvs. [no-kloning-satsen](xref:microsoft.quantum.concepts.pauli#the-no-cloning-theorem) innebär att om vi mäter varje enskild qubit och tar en majoritets röst enligt den klassiska koden ovan, har vi förlorat den exakta informationen som vi försöker skydda.</span><span class="sxs-lookup"><span data-stu-id="81a3a-110">Namely, the [no-cloning theorem](xref:microsoft.quantum.concepts.pauli#the-no-cloning-theorem) implies that if we measure each individual qubit and take a majority vote by analogy to classical code above, then we have lost the precise information that we are trying to protect.</span></span>

<span data-ttu-id="81a3a-111">I inställningen Quantum ser vi att mätningen är problematisk.</span><span class="sxs-lookup"><span data-stu-id="81a3a-111">In the quantum setting, we will see that the measurement is problematic.</span></span> <span data-ttu-id="81a3a-112">Vi kan fortfarande implementera kodningen ovan.</span><span class="sxs-lookup"><span data-stu-id="81a3a-112">We can still implement the encoding above.</span></span>
<span data-ttu-id="81a3a-113">Det är praktiskt att göra detta för att se hur vi kan generalisera fel korrigering i Quantum-fallet.</span><span class="sxs-lookup"><span data-stu-id="81a3a-113">It is helpful to do so to see how we can generalize error correction to the quantum case.</span></span>
<span data-ttu-id="81a3a-114">Låt säga att $ \ket{\overline {0} } = \ket {000} = \ket {0} \otimes \ket {0} \otimes \ket {0} $ och låt $ \ket{\overline {1} } = \ket {111} $.</span><span class="sxs-lookup"><span data-stu-id="81a3a-114">Thus, let $\ket{\overline{0}} = \ket{000} = \ket{0} \otimes \ket{0} \otimes \ket{0}$, and let $\ket{\overline{1}} = \ket{111}$.</span></span>
<span data-ttu-id="81a3a-115">Efter linearitet har vi definierat vår upprepnings kod för alla indata. till exempel $ \ket{\overline{+}} = (\ket{\overline {0} } + \ket{\overline {1} })/\sqrt {2} = (\ket {000} + \ket {111} )/\sqrt {2} $.</span><span class="sxs-lookup"><span data-stu-id="81a3a-115">Then, by linearity, we have defined our repetition code for all inputs; for instance, $\ket{\overline{+}} = (\ket{\overline{0}} + \ket{\overline{1}}) / \sqrt{2} = (\ket{000} + \ket{111}) / \sqrt{2}$.</span></span>
<span data-ttu-id="81a3a-116">I synnerhet, med ett fel $X _1 $ Act på den mellersta qubit, ser vi att den korrigering som behövs i båda grenarna är exakt $X _1 $: $ $ \begin{align} X_1 \ket{\overline{+}} & = \frac {1} {\sqrt {2} } \left (X_1 \ket {000} + X_1 \ket {111} \right) \\ \\ & = \frac {1} {\sqrt {2} } \left (\ket {010} + \ket {101} \right).</span><span class="sxs-lookup"><span data-stu-id="81a3a-116">In particular, letting a bit-flip error $X_1$ act on the middle qubit, we see that the correction needed in both branches is precisely $X_1$: $$ \begin{align} X_1 \ket{\overline{+}} & = \frac{1}{\sqrt{2}} \left( X_1 \ket{000} + X_1 \ket{111} \right) \\\\ & = \frac{1}{\sqrt{2}} \left( \ket{010} + \ket{101} \right).</span></span>
<span data-ttu-id="81a3a-117">\end{align} $ $</span><span class="sxs-lookup"><span data-stu-id="81a3a-117">\end{align} $$</span></span>

<span data-ttu-id="81a3a-118">Om du vill se hur vi kan identifiera att detta är fallet utan att mäta det mycket tillstånd vi försöker skydda, är det bra att skriva ned vad de olika bit vändningarna gör till våra logiska tillstånd:</span><span class="sxs-lookup"><span data-stu-id="81a3a-118">To see how we can identify that this is the case without measuring the very state we are trying to protect, it is helpful to write down what each different bit flip error does to our logical states:</span></span>

| <span data-ttu-id="81a3a-119">Fel $E $</span><span class="sxs-lookup"><span data-stu-id="81a3a-119">Error $E$</span></span> | <span data-ttu-id="81a3a-120">$E \ket{\overline {0} } $</span><span class="sxs-lookup"><span data-stu-id="81a3a-120">$E\ket{\overline{0}}$</span></span> | <span data-ttu-id="81a3a-121">$E \ket{\overline {1} } $</span><span class="sxs-lookup"><span data-stu-id="81a3a-121">$E\ket{\overline{1}}$</span></span> |
| --- | --- | --- |
| <span data-ttu-id="81a3a-122">$ \boldone $</span><span class="sxs-lookup"><span data-stu-id="81a3a-122">$\boldone$</span></span> | <span data-ttu-id="81a3a-123">$ \ket {000} $</span><span class="sxs-lookup"><span data-stu-id="81a3a-123">$\ket{000}$</span></span> | <span data-ttu-id="81a3a-124">$ \ket {111} $</span><span class="sxs-lookup"><span data-stu-id="81a3a-124">$\ket{111}$</span></span> |
| <span data-ttu-id="81a3a-125">$X _0 $</span><span class="sxs-lookup"><span data-stu-id="81a3a-125">$X_0$</span></span> | <span data-ttu-id="81a3a-126">$ \ket {100} $</span><span class="sxs-lookup"><span data-stu-id="81a3a-126">$\ket{100}$</span></span> | <span data-ttu-id="81a3a-127">$ \ket {011} $</span><span class="sxs-lookup"><span data-stu-id="81a3a-127">$\ket{011}$</span></span> |
| <span data-ttu-id="81a3a-128">$X _1 $</span><span class="sxs-lookup"><span data-stu-id="81a3a-128">$X_1$</span></span> | <span data-ttu-id="81a3a-129">$ \ket {010} $</span><span class="sxs-lookup"><span data-stu-id="81a3a-129">$\ket{010}$</span></span> | <span data-ttu-id="81a3a-130">$ \ket {101} $</span><span class="sxs-lookup"><span data-stu-id="81a3a-130">$\ket{101}$</span></span> |
| <span data-ttu-id="81a3a-131">$X _2 $</span><span class="sxs-lookup"><span data-stu-id="81a3a-131">$X_2$</span></span> | <span data-ttu-id="81a3a-132">$ \ket {001} $</span><span class="sxs-lookup"><span data-stu-id="81a3a-132">$\ket{001}$</span></span> | <span data-ttu-id="81a3a-133">$ \ket {110} $</span><span class="sxs-lookup"><span data-stu-id="81a3a-133">$\ket{110}$</span></span> |

<span data-ttu-id="81a3a-134">För att skydda det tillstånd som vi kodar måste vi kunna särskilja de tre felen från varandra och från identiteten $ \boldone $ utan att skilja mellan $ \ket{\overline {0} } $ och $ \ket{\overline {1} } $.</span><span class="sxs-lookup"><span data-stu-id="81a3a-134">In order to protect the state that we're encoding, we need to be able to distinguish the three errors from each other and from the identity $\boldone$ without distinguishing between $\ket{\overline{0}}$ and $\ket{\overline{1}}$.</span></span>
<span data-ttu-id="81a3a-135">Om vi t. ex. mäter $Z _0 $ får vi ett annat resultat för $ \ket{\overline {0} } $ och $ \ket{\overline {1} } $ i No-Error-fallet, så att komprimerar det kodade läget.</span><span class="sxs-lookup"><span data-stu-id="81a3a-135">For example, if we measure $Z_0$, we get a different result for $\ket{\overline{0}}$ and $\ket{\overline{1}}$ in the no-error case, so that collapses the encoded state.</span></span>
<span data-ttu-id="81a3a-136">Å andra sidan kan du överväga att mäta $Z _0 Z_1 $, pariteten för de två första bitarna i varje beräknings grund tillstånd.</span><span class="sxs-lookup"><span data-stu-id="81a3a-136">On the other hand, consider measuring $Z_0 Z_1$, the parity of the first two bits in each computational basis state.</span></span>
<span data-ttu-id="81a3a-137">Kom ihåg att varje mätning av en Pauli-operatör kontrollerar vilken eigenvalue som det tillstånd som mäts motsvarar, så för varje tillstånd $ \ket{\psi} $ i tabellen ovan kan vi beräkna $Z _0 Z_1 \ket{\psi} $ för att se om vi får $ \pm\ket{\psi} $.</span><span class="sxs-lookup"><span data-stu-id="81a3a-137">Recall that each measurement of a Pauli operator checks which eigenvalue  the state being measured corresponds to, so for each state $\ket{\psi}$ in the table above, we can compute $Z_0 Z_1 \ket{\psi}$ to see if we get $\pm\ket{\psi}$.</span></span>
<span data-ttu-id="81a3a-138">Observera att $Z _0 Z_1 \ket {000} = \ket {000} $ och att $Z _0 Z_1 \ket {111} = \ket {111} $, så att den här mätningen gör samma sak i både kodade tillstånd.</span><span class="sxs-lookup"><span data-stu-id="81a3a-138">Note that $Z_0 Z_1 \ket{000} = \ket{000}$ and that $Z_0 Z_1 \ket{111} = \ket{111}$, so that we conclude that this measurement does the same thing to both encoded states.</span></span>
<span data-ttu-id="81a3a-139">Å andra sidan $Z _0 Z_1 \ket {100} =-\ket {100} $ och $Z _0 Z_1 \ket {011} =-\ket {011} $, så resultatet av att mäta $Z _0 Z_1 $ visar användbar information om vilket fel som har inträffat.</span><span class="sxs-lookup"><span data-stu-id="81a3a-139">On the other hand, $Z_0 Z_1 \ket{100} = - \ket{100}$ and $Z_0 Z_1 \ket{011} = -\ket{011}$, so the result of measuring $Z_0 Z_1$ reveals useful information about which error occurred.</span></span>

<span data-ttu-id="81a3a-140">För att framhäva detta upprepas tabellen ovan, men du kan lägga till resultaten från Mät $Z _0 Z_1 $ och $Z _1 Z_2 $ på varje rad.</span><span class="sxs-lookup"><span data-stu-id="81a3a-140">To emphasize this, we repeat the table above, but add the results of measuring $Z_0 Z_1$ and $Z_1 Z_2$ on each row.</span></span>
<span data-ttu-id="81a3a-141">Vi betecknar resultaten av varje mätning genom tecknet för det eigenvalue som observeras, antingen $ + $ eller $-$, som motsvarar respektive :::no-loc(Q#)::: `Result` `Zero` `One` respektive.</span><span class="sxs-lookup"><span data-stu-id="81a3a-141">We denote the results of each measurement by the sign of the eigenvalue that is observed, either $+$ or $-$, corresponding to the :::no-loc(Q#)::: `Result` values of `Zero` and `One`, respectively.</span></span>

| <span data-ttu-id="81a3a-142">Fel $E $</span><span class="sxs-lookup"><span data-stu-id="81a3a-142">Error $E$</span></span> | <span data-ttu-id="81a3a-143">$E \ket{\overline {0} } $</span><span class="sxs-lookup"><span data-stu-id="81a3a-143">$E\ket{\overline{0}}$</span></span> | <span data-ttu-id="81a3a-144">$E \ket{\overline {1} } $</span><span class="sxs-lookup"><span data-stu-id="81a3a-144">$E\ket{\overline{1}}$</span></span> | <span data-ttu-id="81a3a-145">Resultat av $Z _0 Z_1 $</span><span class="sxs-lookup"><span data-stu-id="81a3a-145">Result of $Z_0 Z_1$</span></span> | <span data-ttu-id="81a3a-146">Resultat av $Z _1 Z_2 $</span><span class="sxs-lookup"><span data-stu-id="81a3a-146">Result of $Z_1 Z_2$</span></span> |
| --- | --- | --- | --- | --- |
| <span data-ttu-id="81a3a-147">$ \boldone $</span><span class="sxs-lookup"><span data-stu-id="81a3a-147">$\boldone$</span></span> | <span data-ttu-id="81a3a-148">$ \ket {000} $</span><span class="sxs-lookup"><span data-stu-id="81a3a-148">$\ket{000}$</span></span> | <span data-ttu-id="81a3a-149">$ \ket {111} $</span><span class="sxs-lookup"><span data-stu-id="81a3a-149">$\ket{111}$</span></span> | $+$ | $+$ |
| <span data-ttu-id="81a3a-150">$X _0 $</span><span class="sxs-lookup"><span data-stu-id="81a3a-150">$X_0$</span></span> | <span data-ttu-id="81a3a-151">$ \ket {100} $</span><span class="sxs-lookup"><span data-stu-id="81a3a-151">$\ket{100}$</span></span> | <span data-ttu-id="81a3a-152">$ \ket {011} $</span><span class="sxs-lookup"><span data-stu-id="81a3a-152">$\ket{011}$</span></span> | $-$ | $+$ |
| <span data-ttu-id="81a3a-153">$X _1 $</span><span class="sxs-lookup"><span data-stu-id="81a3a-153">$X_1$</span></span> | <span data-ttu-id="81a3a-154">$ \ket {010} $</span><span class="sxs-lookup"><span data-stu-id="81a3a-154">$\ket{010}$</span></span> | <span data-ttu-id="81a3a-155">$ \ket {101} $</span><span class="sxs-lookup"><span data-stu-id="81a3a-155">$\ket{101}$</span></span> | $-$ | $-$ |
| <span data-ttu-id="81a3a-156">$X _2 $</span><span class="sxs-lookup"><span data-stu-id="81a3a-156">$X_2$</span></span> | <span data-ttu-id="81a3a-157">$ \ket {001} $</span><span class="sxs-lookup"><span data-stu-id="81a3a-157">$\ket{001}$</span></span> | <span data-ttu-id="81a3a-158">$ \ket {110} $</span><span class="sxs-lookup"><span data-stu-id="81a3a-158">$\ket{110}$</span></span> | $+$ | $-$ |

<span data-ttu-id="81a3a-159">Det innebär att resultaten av de två mätningarna unikt avgör vilken bit-flip-fel som inträffade, men utan att avslöja någon information om vilket tillstånd vi kodade.</span><span class="sxs-lookup"><span data-stu-id="81a3a-159">Thus, the results of the two measurements uniquely determines which bit-flip error occurred, but without revealing any information about which state we encoded.</span></span>
<span data-ttu-id="81a3a-160">Vi kallar dessa resultat en *Syndrome* och refererar till processen för att mappa en Syndrome tillbaka till det fel som orsakade *återställningen* .</span><span class="sxs-lookup"><span data-stu-id="81a3a-160">We call these results a *syndrome* , and refer to the process of mapping a syndrome back to the error that caused it as *recovery* .</span></span>
<span data-ttu-id="81a3a-161">I synnerhet betonar vi att återställningen är en *klassisk* härlednings process som tar sig in i den Syndrome som inträffat, och returnerar en recept för att åtgärda eventuella fel som kan ha inträffat.</span><span class="sxs-lookup"><span data-stu-id="81a3a-161">In particular, we emphasize that recovery is a *classical* inference procedure which takes as its input the syndrome which occurred, and returns a prescription for how to fix any errors that may have occurred.</span></span>

> [!NOTE]
> <span data-ttu-id="81a3a-162">Bit-flip-koden ovan kan endast korrigeras mot enstaka fel i en bit. det vill säga en `X` åtgärd som agerar på en enda qubit.</span><span class="sxs-lookup"><span data-stu-id="81a3a-162">The bit-flip code above can only correct against single bit-flip errors; that is, an `X` operation acting on a single qubit.</span></span>
> <span data-ttu-id="81a3a-163">`X`Om du använder mer än en qubit mappas $ \ket{\overline {0} } $ till $ \ket{\overline {1} } $ efter återställningen.</span><span class="sxs-lookup"><span data-stu-id="81a3a-163">Applying `X` to more than one qubit will map $\ket{\overline{0}}$ to $\ket{\overline{1}}$ following recovery.</span></span>
> <span data-ttu-id="81a3a-164">På samma sätt kommer du att använda en fas vändning `Z` -åtgärd för att mappa $ \ket{\overline {1} } $ till $-\ket{\overline {1} } $ och därmed mappa $ \ket{\overline{+}} $ till $ \ket{\overline {-} } $.</span><span class="sxs-lookup"><span data-stu-id="81a3a-164">Similarly, applying a phase flip operation `Z` will map $\ket{\overline{1}}$ to $-\ket{\overline{1}}$, and hence will map $\ket{\overline{+}}$ to $\ket{\overline{-}}$.</span></span>
> <span data-ttu-id="81a3a-165">Ofta kan koder skapas för att hantera större antal fel och för att hantera $Z $-fel samt $X $-fel.</span><span class="sxs-lookup"><span data-stu-id="81a3a-165">More generally, codes can be created to handle larger number of errors, and to handle $Z$ errors as well as $X$ errors.</span></span>

<span data-ttu-id="81a3a-166">Insikter om att vi kan beskriva mätningar i en Quantum-fel korrigering som fungerar på samma sätt i alla kod stater, är grunden för den *stabiliseringsbaserade formaliteten* .</span><span class="sxs-lookup"><span data-stu-id="81a3a-166">The insight that we can describe measurements in quantum error correction that act the same way on all code states, is the essence of the *stabilizer formalism* .</span></span>
<span data-ttu-id="81a3a-167">:::no-loc(Q#):::Canon innehåller ett ramverk för att beskriva kodning i och avkodning från stabiliserings koder och för att beskriva hur en återställning av fel uppstår.</span><span class="sxs-lookup"><span data-stu-id="81a3a-167">The :::no-loc(Q#)::: canon provides a framework for describing encoding into and decoding from stabilizer codes, and for describing how one recovers from errors.</span></span>
<span data-ttu-id="81a3a-168">I det här avsnittet beskriver vi det här ramverket och dess program till några vanliga Quantum Error-felkorrigerings koder.</span><span class="sxs-lookup"><span data-stu-id="81a3a-168">In this section, we describe this framework and its application to a few simple quantum error-correcting codes.</span></span>

> [!TIP]
> <span data-ttu-id="81a3a-169">En fullständig introduktion till stabiliserings-och stabiliserings funktionen ligger utanför det här avsnittets omfattning.</span><span class="sxs-lookup"><span data-stu-id="81a3a-169">A full introduction to the stabilizer formalism is beyond the scope of this section.</span></span>
> <span data-ttu-id="81a3a-170">Vi refererar till läsare som är intresserade av att lära sig mer till [Gottesman 2009](https://arxiv.org/abs/0904.2557).</span><span class="sxs-lookup"><span data-stu-id="81a3a-170">We refer readers interested in learning more to [Gottesman 2009](https://arxiv.org/abs/0904.2557).</span></span>

## <a name="representing-error-correcting-codes-in-no-locq"></a><span data-ttu-id="81a3a-171">Motsvarar fel korrigerings koder i :::no-loc(Q#):::</span><span class="sxs-lookup"><span data-stu-id="81a3a-171">Representing Error Correcting Codes in :::no-loc(Q#):::</span></span> ##

<span data-ttu-id="81a3a-172">För att hjälpa till att ange fel som korrigerar koder :::no-loc(Q#)::: ger Canon flera olika användardefinierade typer:</span><span class="sxs-lookup"><span data-stu-id="81a3a-172">To help specify error correcting codes, the :::no-loc(Q#)::: canon provides several distinct user-defined types:</span></span>

- <span data-ttu-id="81a3a-173"><xref:Microsoft.Quantum.ErrorCorrection.LogicalRegister>`= Qubit[]`: Anger att ett register över qubits ska tolkas som kod block för en felkorrigerande kod.</span><span class="sxs-lookup"><span data-stu-id="81a3a-173"><xref:Microsoft.Quantum.ErrorCorrection.LogicalRegister> `= Qubit[]`: Denotes that a register of qubits should be interpreted as the code block of an error-correcting code.</span></span>
- <span data-ttu-id="81a3a-174"><xref:Microsoft.Quantum.ErrorCorrection.Syndrome>`= Result[]`: Anger att en matris med mått resultat ska tolkas som Syndrome mätt i ett kodblock.</span><span class="sxs-lookup"><span data-stu-id="81a3a-174"><xref:Microsoft.Quantum.ErrorCorrection.Syndrome> `= Result[]`: Denotes that an array of measurement results should be interpreted as the syndrome measured on a code block.</span></span>
- <span data-ttu-id="81a3a-175"><xref:Microsoft.Quantum.ErrorCorrection.RecoveryFn>`= (Syndrome -> Pauli[])`: Anger att en *klassisk* funktion ska användas för att tolka en Syndrome och returnera en korrigering som ska tillämpas.</span><span class="sxs-lookup"><span data-stu-id="81a3a-175"><xref:Microsoft.Quantum.ErrorCorrection.RecoveryFn> `= (Syndrome -> Pauli[])`: Denotes that a *classical* function should be used to interpret a syndrome and return a correction that should be applied.</span></span>
- <span data-ttu-id="81a3a-176"><xref:Microsoft.Quantum.ErrorCorrection.EncodeOp>`= ((Qubit[], Qubit[]) => LogicalRegister)`: Anger att en åtgärd tar qubits som representerar data tillsammans med nya Ancilla-qubits för att skapa ett kodblock av en felkorrigerande kod.</span><span class="sxs-lookup"><span data-stu-id="81a3a-176"><xref:Microsoft.Quantum.ErrorCorrection.EncodeOp> `= ((Qubit[], Qubit[]) => LogicalRegister)`: Denotes that an operation takes qubits representing data along with fresh ancilla qubits in order to produce a code block of an error-correcting code.</span></span>
- <span data-ttu-id="81a3a-177"><xref:Microsoft.Quantum.ErrorCorrection.DecodeOp>`= (LogicalRegister => (Qubit[], Qubit[]))`: Om en åtgärd är indelad i ett kod block av ett fel korrigeras koden i data qubits och Ancilla-qubits som används för att representera Syndrome-information.</span><span class="sxs-lookup"><span data-stu-id="81a3a-177"><xref:Microsoft.Quantum.ErrorCorrection.DecodeOp> `= (LogicalRegister => (Qubit[], Qubit[]))`: Denotes than an operation decomposes a code block of an error correcting code into the data qubits and the ancilla qubits used to represent syndrome information.</span></span>
- <span data-ttu-id="81a3a-178"><xref:Microsoft.Quantum.ErrorCorrection.SyndromeMeasOp>`= (LogicalRegister => Syndrome)`: Anger en åtgärd som ska användas för att extrahera Syndrome-information från ett kodblock utan att störa det tillstånd som skyddas av koden.</span><span class="sxs-lookup"><span data-stu-id="81a3a-178"><xref:Microsoft.Quantum.ErrorCorrection.SyndromeMeasOp> `= (LogicalRegister => Syndrome)`: Denotes an operation that should be used to extract syndrome information from a code block, without disturbing the state protected by the code.</span></span>

<span data-ttu-id="81a3a-179">Dessutom tillhandahåller Canon <xref:Microsoft.Quantum.ErrorCorrection.QECC> typen för att samla in de andra typerna som krävs för att definiera en kod för Quantum-fel korrigering.</span><span class="sxs-lookup"><span data-stu-id="81a3a-179">Finally, the canon provides the <xref:Microsoft.Quantum.ErrorCorrection.QECC> type to collect the other types required to define a quantum error-correcting code.</span></span> <span data-ttu-id="81a3a-180">Associerad med varje stabiliserings-Quantum-kod är kod längden $n $, antalet $k $ för logiska qubits och minsta avstånd $d $, som ofta grupperas tillsammans i notationen ⟦ $n $, $k $, $d $ ⟧.</span><span class="sxs-lookup"><span data-stu-id="81a3a-180">Associated with each stabilizer quantum code is the code length $n$, the number $k$ of logical qubits, and the minimum distance $d$, often conveniently grouped together in the notation ⟦$n$, $k$, $d$⟧.</span></span> <span data-ttu-id="81a3a-181">Funktionen definierar t. ex. <xref:Microsoft.Quantum.ErrorCorrection.BitFlipCode> ⟦ 3, 1, 1 ⟧ bit flip Code:</span><span class="sxs-lookup"><span data-stu-id="81a3a-181">For example, the <xref:Microsoft.Quantum.ErrorCorrection.BitFlipCode> function defines the ⟦3, 1, 1⟧ bit flip code:</span></span>

```qsharp
let encodeOp = EncodeOp(BitFlipEncoder);
let decodeOp = DecodeOp(BitFlipDecoder);
let syndMeasOp = SyndromeMeasOp(MeasureStabilizerGenerators([
    [PauliZ, PauliZ, PauliI],
    [PauliI, PauliZ, PauliZ]
], _, MeasureWithScratch));
let code = QECC(encodeOp, decodeOp, syndMeasOp);
```

<span data-ttu-id="81a3a-182">Observera att `QECC` typen *inte* innehåller någon återställnings funktion.</span><span class="sxs-lookup"><span data-stu-id="81a3a-182">Notice that the `QECC` type does *not* include a recovery function.</span></span>
<span data-ttu-id="81a3a-183">Detta gör att vi kan ändra den återställnings funktion som används i korrigerande fel utan att ändra definitionen för själva koden. den här funktionen är särskilt användbar när du införlivar feedback från karakteriserings mätningar i modellen som antas av återställningen.</span><span class="sxs-lookup"><span data-stu-id="81a3a-183">This allows us to change the recovery function that is used in correcting errors without changing the definition of the code itself; this ability is in particular useful when incorporating feedback from characterization measurements into the model assumed by recovery.</span></span>

<span data-ttu-id="81a3a-184">När en kod har definierats på det här sättet kan vi använda <xref:Microsoft.Quantum.ErrorCorrection.Recover> åtgärden för att återställa från fel:</span><span class="sxs-lookup"><span data-stu-id="81a3a-184">Once a code is defined in this way, we can use the <xref:Microsoft.Quantum.ErrorCorrection.Recover> operation to recover from errors:</span></span>

```qsharp
let code = BitFlipCode();
let fn = BitFlipRecoveryFn();
let X0 = ApplyPauli([PauliX, PauliI, PauliI], _);
using (scratch = Qubit[nScratch]) {
    let logicalRegister = encode(data, scratch);
    // Cause an error.
    X0(logicalRegister);
    Recover(code, fn, logicalRegister);
    let (decodedData, decodedScratch) = decode(logicalRegister);
    ApplyToEach(Reset, decodedScratch);
}
```

<span data-ttu-id="81a3a-185">Vi utforskar detta mer detaljerat i [kod exemplet bit flip](https://github.com/microsoft/Quantum/tree/main/samples/error-correction/bit-flip-code).</span><span class="sxs-lookup"><span data-stu-id="81a3a-185">We explore this in more detail in the [bit flip code sample](https://github.com/microsoft/Quantum/tree/main/samples/error-correction/bit-flip-code).</span></span>

<span data-ttu-id="81a3a-186">Från bit-flip-koden :::no-loc(Q#)::: tillhandahålls Canon med implementeringar av den [qubit perfekta koden](https://arxiv.org/abs/quant-ph/9602019), och [koden för sju qubit](https://arxiv.org/abs/quant-ph/9705052), som båda kan åtgärda ett godtyckligt qubit-fel.</span><span class="sxs-lookup"><span data-stu-id="81a3a-186">Aside from the bit-flip code, the :::no-loc(Q#)::: canon is provided with implementations of the [five-qubit perfect code](https://arxiv.org/abs/quant-ph/9602019), and the [seven-qubit code](https://arxiv.org/abs/quant-ph/9705052), both of which can correct an arbitrary single-qubit error.</span></span>
