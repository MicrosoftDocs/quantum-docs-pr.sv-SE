---
title: Quantum-algoritmer i Q#
description: Lär dig mer om grundläggande Quantum Computing-algoritmer, inklusive amplitud-förstärkning, Fourier Transform, Draper och Beauregard Adders och fas uppskattning.
author: QuantumWriter
ms.author: martinro
ms.date: 12/11/2017
ms.topic: article
uid: microsoft.quantum.libraries.standard.algorithms
no-loc:
- Q#
- $$v
ms.openlocfilehash: 7ce13c5df3795656156cccf28640c0a4b0dcba2e
ms.sourcegitcommit: 9b0d1ffc8752334bd6145457a826505cc31fa27a
ms.translationtype: MT
ms.contentlocale: sv-SE
ms.lasthandoff: 09/21/2020
ms.locfileid: "90835680"
---
# <a name="quantum-algorithms"></a><span data-ttu-id="da597-103">Quantum-algoritmer</span><span class="sxs-lookup"><span data-stu-id="da597-103">Quantum Algorithms</span></span> #

## <a name="amplitude-amplification"></a><span data-ttu-id="da597-104">Amplitudförstärkning</span><span class="sxs-lookup"><span data-stu-id="da597-104">Amplitude Amplification</span></span> ##

<span data-ttu-id="da597-105">*Amplitud förstärkning* är ett av de grundläggande verktygen i Quantum Computing.</span><span class="sxs-lookup"><span data-stu-id="da597-105">*Amplitude Amplification* is one of the fundamental tools of Quantum Computing.</span></span> <span data-ttu-id="da597-106">Det är den grundläggande idén som ligger under Grover sökning, amplitud uppskattning och många Quantum Machine Learning-algoritmer.</span><span class="sxs-lookup"><span data-stu-id="da597-106">It is the fundamental idea that underlies Grover's search, amplitude estimation and many quantum machine learning algorithms.</span></span>  <span data-ttu-id="da597-107">Det finns många varianter, och i Q# vi erbjuder vi en allmän version som baseras på Oblivious amplitud-förstärkning med partiella reflektioner för att tillåta det bredaste programmet.</span><span class="sxs-lookup"><span data-stu-id="da597-107">There are many variants, and in Q# we provide a general version based on Oblivious Amplitude Amplification with Partial Reflections to allow for the widest area of application.</span></span>

<span data-ttu-id="da597-108">Den centrala idén bakom amplitud förstärkning är att utvidga sannolikheten för att ett önskat resultat inträffar genom att utföra en följd av reflektioner.</span><span class="sxs-lookup"><span data-stu-id="da597-108">The central idea behind amplitude amplification is to amplify the probability of a desired outcome occurring by performing a sequence of reflections.</span></span>  <span data-ttu-id="da597-109">Dessa reflektioner roterar det initiala läget närmare ett önskat mål tillstånd, ofta kallat ett märkt tillstånd.</span><span class="sxs-lookup"><span data-stu-id="da597-109">These reflections rotate the initial state closer towards a desired target state, often called a marked state.</span></span>  <span data-ttu-id="da597-110">Om sannolikheten för att mäta det initiala läget ska vara i ett markerat tillstånd är $ \sin ^ 2 (\theta) $ sedan efter att ha använt amplitud-förstärkning $m $ gånger sannolikheten att lyckas blir $ \sin ^ 2 ((2 m + 1) \theta) $.</span><span class="sxs-lookup"><span data-stu-id="da597-110">Specifically, if the probability of measuring the initial state to be in a marked state is $\sin^2(\theta)$ then after applying amplitude amplification $m$ times the probability of success becomes $\sin^2((2m+1)\theta)$.</span></span>  <span data-ttu-id="da597-111">Det innebär att om $ \theta = \ Pi/[2 (2n + 1)] $ för ett värde av $n $, kan amplitud-förstärkningen förbättra sannolikheten att lyckas till $100 \\ % $ efter $n $-iterationer av amplitud förstärkning.</span><span class="sxs-lookup"><span data-stu-id="da597-111">This means that if $\theta = \pi/[2(2n+1)]$ for some value of $n$ then amplitude amplification is capable of boosting the probability of success to $100\\%$ after $n$ iterations of amplitude amplification.</span></span>  <span data-ttu-id="da597-112">Sedan $ \theta = \sin ^ {-1} (\sqrt{\Pr (lyckades)}) $ betyder det att antalet iterationer som krävs för att hämta en lyckad deterministiskt är på rätt sätt lägre än det förväntade antalet som krävs för att hitta ett markerat tillstånd som inte är deterministiskt med slumpmässig provtagning.</span><span class="sxs-lookup"><span data-stu-id="da597-112">Since $\theta = \sin^{-1}(\sqrt{\Pr(success)})$ this means that the number of iterations needed to obtain a success deterministically is quadratically lower than the expected number needed to find a marked state non-deterministically using random sampling.</span></span>

<span data-ttu-id="da597-113">Varje iteration av amplitud-förstärkning kräver att två reflektions operatorer anges.</span><span class="sxs-lookup"><span data-stu-id="da597-113">Each iteration of Amplitude amplification requires that two reflection operators be specified.</span></span> <span data-ttu-id="da597-114">Mer specifikt, om $Q $ är amplitud-förstärkningen iterera och $P _0 $ är en projektor operator på det inledande under utrymmet och $P _1 $ är projektorn på det markerade under utrymmet $Q =-(\boldone-2P_0) (\boldone-2P_1) $.</span><span class="sxs-lookup"><span data-stu-id="da597-114">Specifically, if $Q$ is the amplitude amplification iterate and $P_0$ is a projector operator onto the initial subspace and $P_1$ is the projector onto the marked subspace then $Q=-(\boldone-2P_0)(\boldone -2P_1)$.</span></span>  <span data-ttu-id="da597-115">Kom ihåg att en projektor är en Hermitian-operator som har Eigenvalues $ + $1 och $0 $ och att $ (\boldone-2P_0) $ är enhetlig eftersom den har Eigenvalues som är enhets rötter (i det här fallet $ \pm $1).</span><span class="sxs-lookup"><span data-stu-id="da597-115">Recall that a projector is a Hermitian operator that has eigenvalues $+1$ and $0$ and as a result $(\boldone -2P_0)$ is unitary because it has eigenvalues that are roots of unity (in this case $\pm 1$).</span></span> <span data-ttu-id="da597-116">Som exempel kan du titta på fallet med Grover search med start tillstånd $H ^ {\otimes n} \ket {0} $ och markerat tillstånd $ \ket{m} $, $P _0 = H ^ {\otimes n} \ket {0} \bra {0} H ^ {\otimes n} $ och $P _1 = \ket{m}\bra{m} $.</span><span class="sxs-lookup"><span data-stu-id="da597-116">As an example, consider the case of Grover's search with initial state $H^{\otimes n} \ket{0}$ and marked state $\ket{m}$, $P_0 = H^{\otimes n}\ket{0}\bra{0}H^{\otimes n}$ and $P_1= \ket{m}\bra{m}$.</span></span>  <span data-ttu-id="da597-117">I de flesta program av amplitud förstärkning $P _0 $ en projektor i ett initialt tillstånd som $P _0 = \boldone-2 \ ket {\ PSI} \ bra {\ PSI} $ för vissa vektor $ \ket{\psi} $; för Oblivious amplitud amplication $P _0 $ vanligt vis projekt till många Quantum-tillstånd (d.v.s. multipliciteten hos $ + $1-eigenvalue för $P _0 $ är större än $1 $).</span><span class="sxs-lookup"><span data-stu-id="da597-117">In most applications of amplitude amplification $P_0$ will be a projector onto an initial state meaning that $P_0 = \boldone -2\ket{\psi}\bra{\psi}$ for some vector $\ket{\psi}$; however, for oblivious amplitude amplication $P_0$ will typically project onto many quantum states (i.e. the multiplicity of the $+1$ eigenvalue of $P_0$ is greater than $1$).</span></span>

<span data-ttu-id="da597-118">Logiken bakom amplitud-förstärkningen följer direkt från Eigen-dekompositionen för $Q $.</span><span class="sxs-lookup"><span data-stu-id="da597-118">The logic behind amplitude amplification follows directly from the eigen-decomposition of $Q$.</span></span>  <span data-ttu-id="da597-119">Mer specifikt, eigenvectors i $Q $ att det ursprungliga läget har icke-noll-support över kan visas som linjära kombinationer av $ + $1-eigenvectors för $P _0 $ och $P _1 $.</span><span class="sxs-lookup"><span data-stu-id="da597-119">Specifically, the eigenvectors of $Q$ that the initial state has non-zero support over can be shown to be linear combinations of the $+1$ eigenvectors of $P_0$ and $P_1$.</span></span>  <span data-ttu-id="da597-120">Mer specifikt är det ursprungliga läget för amplitud förstärkning (förutsatt att det är en $ + $1 eigenvector av $P _0 $) som kan skrivas som $ $ \ket{\psi} = \frac{-i}{\sqrt {2} } \left (e ^ {i\theta} \ ket {\ psi_ +} + e ^ {-i\theta} \ ket {\ psi_-} \right), $ $ WHERE $ \ket{\ psi_ \pm} $ eigenvectors $Q $ med eigenvalues $e ^ {\pm 2i \ theta} $ och har bara stöd för $ + $1 eigenvectors för $P _0 $ och $P _1 $.</span><span class="sxs-lookup"><span data-stu-id="da597-120">Specifically, the initial state for amplitude amplification (assuming it is a $+1$ eigenvector of $P_0$) can be written as $$ \ket{\psi}=\frac{-i}{\sqrt{2}}\left(e^{i\theta}\ket{\psi_+} + e^{-i\theta}\ket{\psi_-}\right), $$ where $\ket{\psi_\pm}$ are eigenvectors of $Q$ with eigenvalues $e^{\pm  2i\theta}$ and only have support on the $+1$ eigenvectors of $P_0$ and $P_1$.</span></span>  <span data-ttu-id="da597-121">Det faktum att Eigenvalues är $e ^ {\pm i \theta} $ betyder att operatorn $Q $ utför en rotation i ett tvådimensionellt del utrymme som anges av de två projektorerna och det inledande tillstånd där rotations vinkeln är $2 \ theta $.</span><span class="sxs-lookup"><span data-stu-id="da597-121">The fact that the eigenvalues are $e^{\pm i \theta}$ implies that the operator $Q$ performs a rotation in a two-dimensional subspace specified by the two projectors and the initial state where the rotation angle is $2\theta$.</span></span>  <span data-ttu-id="da597-122">Detta är varför efter $m $-iterationer av $Q $ den lyckade sannolikheten är $ \sin ^ 2 ([2 m + 1] \theta) $.</span><span class="sxs-lookup"><span data-stu-id="da597-122">This is why after $m$ iterations of $Q$ the success probability is $\sin^2([2m+1]\theta)$.</span></span>

<span data-ttu-id="da597-123">En annan användbar egenskap som kommer från detta är att eigenvalue $ \theta $ är direkt relaterad till sannolikheten att det ursprungliga läget skulle markeras (i det fall där $P _0 $ är en projektor på endast det ursprungliga läget).</span><span class="sxs-lookup"><span data-stu-id="da597-123">Another useful property that comes out of this is that the eigenvalue $\theta$ is directly related to probability that the initial state would be marked (in the case where $P_0$ is a projector onto only the initial state).</span></span>  <span data-ttu-id="da597-124">Eftersom eigenphases i $Q $ är $2 \ theta = 2 \ sin ^ {-1} (\sqrt{\Pr (lyckades)}) $, följer det sedan på att om vi tillämpar fas uppskattning i $Q $ kan vi lära dig sannolikheten för en enhetlig Quantum-procedur.</span><span class="sxs-lookup"><span data-stu-id="da597-124">Since the eigenphases of $Q$ are $2\theta = 2\sin^{-1}(\sqrt{\Pr(success)})$ it then follows that if we apply phase estimation to $Q$ then we can learn the probability of success for a unitary quantum procedure.</span></span>  <span data-ttu-id="da597-125">Detta är användbart eftersom det kräver kvadratiskt färre program i Quantum-proceduren för att få en bra sannolikhet än vad som annars skulle behövas.</span><span class="sxs-lookup"><span data-stu-id="da597-125">This is useful because it requires quadratically fewer applications of the quantum procedure to learn the success probability than would otherwise be needed.</span></span>

<span data-ttu-id="da597-126">Q# introducerar amplitud-förstärkning som en specialisering av Oblivious amplitud-förstärkning.</span><span class="sxs-lookup"><span data-stu-id="da597-126">Q# introduces amplitude amplification as a specialization of oblivious amplitude amplification.</span></span>  <span data-ttu-id="da597-127">Oblivious amplitud-förstärkningen använder denna moniker eftersom projektorn på den ursprungliga eigenspace inte behöver vara en projektor i det ursprungliga läget.</span><span class="sxs-lookup"><span data-stu-id="da597-127">Oblivious amplitude amplification earns this moniker because the projector onto the initial eigenspace need not be a projector onto the initial state.</span></span>  <span data-ttu-id="da597-128">I detta mening är protokollet Oblivious till det ursprungliga läget.</span><span class="sxs-lookup"><span data-stu-id="da597-128">In this sense, the protocol is oblivious to the initial state.</span></span>  <span data-ttu-id="da597-129">Nyckel tillämpningen av Oblivious amplitud-förstärkning är i vissa *linjära kombinationer av enhetliga* Hamiltonian-simulerings metoder, där start tillstånd är okänt men blir Entangled med en Ancilla-registrering i simulerings protokollet.</span><span class="sxs-lookup"><span data-stu-id="da597-129">The key application of oblivious amplitude amplification is in certain *linear combinations of unitary* Hamiltonian simulation methods, wherein the initial state is unknown but becomes entangled with an ancilla register in the simulation protocol.</span></span>  <span data-ttu-id="da597-130">Om det här Ancilla-registret skulle mätas som ett fast värde, t. ex. $0 $, tillämpar dessa simulerings metoder den önskade enhetliga omvandlingen för återstående qubits (kallas system registret).</span><span class="sxs-lookup"><span data-stu-id="da597-130">If this ancilla register were to be measured to be a fixed value, say $0$, then such simulation methods apply the desired unitary transformation to the remaining qubits (called the system register).</span></span>  <span data-ttu-id="da597-131">Alla andra mått kommer att leda till ett problem.</span><span class="sxs-lookup"><span data-stu-id="da597-131">All other measurement outcomes lead to failure however.</span></span>  <span data-ttu-id="da597-132">Oblivious amplitud-förstärkning gör att det går att öka sannolikheten för att denna mätning ska höjas till $100 \\ % $ med ovanstående orsak.</span><span class="sxs-lookup"><span data-stu-id="da597-132">Oblivious amplitude amplification allows the probability of success of this measurement to be boosted to $100\\%$ using the above reasoning.</span></span>  <span data-ttu-id="da597-133">Dessutom motsvarar den vanliga amplitud förstärkningen det fall där system registret är tomt.</span><span class="sxs-lookup"><span data-stu-id="da597-133">Further, ordinary amplitude amplification corresponds to the case where the system register is empty.</span></span>  <span data-ttu-id="da597-134">Detta är varför Q# använder Oblivious amplitud-förstärkning som dess grundläggande amplitud förstärknings subrutin.</span><span class="sxs-lookup"><span data-stu-id="da597-134">This is why Q# uses oblivious amplitude amplification as its fundamental amplitude amplification subroutine.</span></span>

<span data-ttu-id="da597-135">Den allmänna rutinen ( `AmpAmpObliviousByReflectionPhases` ) har två register som vi kallar `ancillaRegister` och `systemRegister` .</span><span class="sxs-lookup"><span data-stu-id="da597-135">The general routine (`AmpAmpObliviousByReflectionPhases`) has two registers that we call `ancillaRegister` and `systemRegister`.</span></span> <span data-ttu-id="da597-136">Den accepterar också två Oracle-uppgifter för nödvändiga reflektioner.</span><span class="sxs-lookup"><span data-stu-id="da597-136">It also accepts two oracles for the necessary reflections.</span></span> <span data-ttu-id="da597-137">De `ReflectionOracle` fungerar bara på de `ancillaRegister` åtgärder som utförs `ObliviousOracle` gemensamt i båda registren.</span><span class="sxs-lookup"><span data-stu-id="da597-137">The `ReflectionOracle` acts only on the `ancillaRegister` while the `ObliviousOracle` acts jointly on both registers.</span></span> <span data-ttu-id="da597-138">Indatamängden till `ancillaRegister` måste initieras till en-1-eigenstate av den första reflektions operatorn $ \boldone-2P_1 $.</span><span class="sxs-lookup"><span data-stu-id="da597-138">The input to `ancillaRegister` must be initialized to a -1 eigenstate of the first reflection operator $\boldone -2P_1$.</span></span>

<span data-ttu-id="da597-139">Oracle förbereder vanligt vis stadiet i beräknings basen $ \ket{0...0} $.</span><span class="sxs-lookup"><span data-stu-id="da597-139">Typically, the oracle prepares the state in the computational basis $\ket{0...0}$.</span></span> <span data-ttu-id="da597-140">I vår implementering består de `ancillaRegister` av en qubit ( `flagQubit` ) som styr `stateOracle` och resten av önskad ancillas.</span><span class="sxs-lookup"><span data-stu-id="da597-140">In our implementation, the `ancillaRegister` consistes of one qubit (`flagQubit`) that controls the `stateOracle` and the rest of the desired ancillas.</span></span> <span data-ttu-id="da597-141">Används `stateOracle` när `flagQubit` är $ \ket {1} $.</span><span class="sxs-lookup"><span data-stu-id="da597-141">The `stateOracle` is applied when the `flagQubit` is $\ket{1}$.</span></span>

<span data-ttu-id="da597-142">En kan också tillhandahålla Oracle `StateOracle` och `ObliviousOracle` istället för att avspeglas via ett anrop till `AmpAmpObliviousByOraclePhases` .</span><span class="sxs-lookup"><span data-stu-id="da597-142">One may also provide oracles `StateOracle` and `ObliviousOracle` instead of reflections via a call to `AmpAmpObliviousByOraclePhases`.</span></span>

<span data-ttu-id="da597-143">Som vi nämnt är den traditionella amplitud förstärkningen bara ett specialfall av dessa rutiner där `ObliviousOracle` är identitets operatorn och det inte finns något system qubits (dvs. `systemRegister` är tom).</span><span class="sxs-lookup"><span data-stu-id="da597-143">As mentioned, traditional Amplitude Amplification is just a special case of these routines where `ObliviousOracle` is the identity operator and there are no system qubits (i.e., `systemRegister` is empty).</span></span> <span data-ttu-id="da597-144">Om du vill hämta faser för partiella reflektioner (t. ex. för Grover-sökning) `AmpAmpPhasesStandard` är funktionen tillgänglig.</span><span class="sxs-lookup"><span data-stu-id="da597-144">If you wish to obtain phases for partial reflections (e.g., for Grover search), the function `AmpAmpPhasesStandard` is available.</span></span> <span data-ttu-id="da597-145">Se `DatabaseSearch.qs` för en exempel implementering av Grover-algoritmen.</span><span class="sxs-lookup"><span data-stu-id="da597-145">Please refer to `DatabaseSearch.qs` for a sample implementation of Grover's algorithm.</span></span>

<span data-ttu-id="da597-146">Vi relaterar qubit rotations faser till reflektions operator faserna som beskrivs på papperet av [G.H. Low, I. L. Chuang](https://arxiv.org/abs/1707.05391).</span><span class="sxs-lookup"><span data-stu-id="da597-146">We relate the single-qubit rotation phases to the reflection operator phases as described in the paper by [G.H. Low, I. L. Chuang](https://arxiv.org/abs/1707.05391).</span></span> <span data-ttu-id="da597-147">De fasta punkt faserna som används beskrivs i [Yoder, låg och Chuang](https://arxiv.org/abs/1409.3305) tillsammans med faserna i [låg, Yoder och Chuang](https://arxiv.org/abs/1603.03996).</span><span class="sxs-lookup"><span data-stu-id="da597-147">The fixed point phases that are used are detailed in [Yoder, Low and Chuang](https://arxiv.org/abs/1409.3305) along with the phases in [Low, Yoder and Chuang](https://arxiv.org/abs/1603.03996).</span></span>

<span data-ttu-id="da597-148">I bakgrunden kan du starta från [standard-amplitud-förstärkningen](https://arxiv.org/abs/quant-ph/0005055) och sedan övergå till en introduktion till [Oblivious amplitud-förstärkning](https://arxiv.org/abs/1312.1414) och finally-generaliseringar som presenteras i [låg och Chuang](https://arxiv.org/abs/1610.06546).</span><span class="sxs-lookup"><span data-stu-id="da597-148">For background, you could start from [Standard Amplitude Amplification](https://arxiv.org/abs/quant-ph/0005055) then move to an introduction to [Oblivious Amplitude Amplification](https://arxiv.org/abs/1312.1414) and finally generalizations presented in [Low and Chuang](https://arxiv.org/abs/1610.06546).</span></span> <span data-ttu-id="da597-149">En bra översikt över hela det här utrymmet (som det rör Hamiltonian simulering) gavs av [Dominic bär](http://www.dominicberry.org/presentations/Durban.pdf).</span><span class="sxs-lookup"><span data-stu-id="da597-149">A nice overview presentation of this entire area (as it relates to Hamiltonian Simulation) was given by [Dominic Berry](http://www.dominicberry.org/presentations/Durban.pdf).</span></span>

## <a name="quantum-fourier-transform"></a><span data-ttu-id="da597-150">Quantum Fourier-transformering</span><span class="sxs-lookup"><span data-stu-id="da597-150">Quantum Fourier Transform</span></span> ##

<span data-ttu-id="da597-151">Fourier Transform är ett grundläggande verktyg för klassisk analys och är precis lika viktigt för Quantum-beräkningar.</span><span class="sxs-lookup"><span data-stu-id="da597-151">The Fourier transform is a fundamental tool of classical analysis and is just as important for quantum computations.</span></span>
<span data-ttu-id="da597-152">Dessutom överskrider *Fourier-transformeringens* effektivitet (QFT) mycket vad som är möjligt på en klassisk dator som gör det till ett av de första verktyg som du väljer när du skapar en Quantum-algoritm.</span><span class="sxs-lookup"><span data-stu-id="da597-152">In addition, the efficiency of the *quantum Fourier transform* (QFT) far surpasses what is possible on a classical machine making it one of the first tools of choice when designing a quantum algorithm.</span></span>

<span data-ttu-id="da597-153">Som en ungefärlig generalisering av QFT tillhandahåller vi den <xref:microsoft.quantum.canon.approximateqft> åtgärd som möjliggör ytterligare optimering genom att rensa rotationer som inte är absolut nödvändiga för önskad algoritms noggrannhet.</span><span class="sxs-lookup"><span data-stu-id="da597-153">As an approximate generalization of the QFT, we provide the <xref:microsoft.quantum.canon.approximateqft> operation that allows for further optimizations by pruning rotations that aren't strictly necessary for the desired algorithmic accuracy.</span></span>
<span data-ttu-id="da597-154">Den ungefärliga QFT kräver att dyadic $Z $-rotations åtgärd <xref:microsoft.quantum.intrinsic.rfrac> och <xref:microsoft.quantum.intrinsic.h> åtgärden.</span><span class="sxs-lookup"><span data-stu-id="da597-154">The approximate QFT requires the dyadic $Z$-rotation operation <xref:microsoft.quantum.intrinsic.rfrac> as well as the <xref:microsoft.quantum.intrinsic.h> operation.</span></span>
<span data-ttu-id="da597-155">Indata och utdata antas vara kodade i big endian encoding---det vill säga qubit med indexet `0` är kodat i det vänstra (högsta) biten i den binära heltals representationen.</span><span class="sxs-lookup"><span data-stu-id="da597-155">The input and output are assumed to be encoded in big endian encoding---that is, the qubit with index `0` is encoded in the left-most (highest) bit of the binary integer representation.</span></span>
<span data-ttu-id="da597-156">Detta justeras med [ket-notation](xref:microsoft.quantum.concepts.dirac), som ett register över tre qubits i tillstånd $ \ket {100} $ motsvarar $q _0 $ är i tillstånd $ \ket {1} $ medan $q _1 $ och $q _2 $ är både i tillstånd $ \ket {0} $.</span><span class="sxs-lookup"><span data-stu-id="da597-156">This aligns with [ket notation](xref:microsoft.quantum.concepts.dirac), as a register of three qubits in the state $\ket{100}$ corresponds to $q_0$ being in the state $\ket{1}$ while $q_1$ and $q_2$ are both in state $\ket{0}$.</span></span>
<span data-ttu-id="da597-157">Den ungefärliga parametern $a $ fastställer rensnings nivån för $Z $-rotationer, t. ex. $a \in [0.. n] $.</span><span class="sxs-lookup"><span data-stu-id="da597-157">The approximation parameter $a$ determines the pruning level of the $Z$-rotations, i.e., $a \in [0..n]$.</span></span>
<span data-ttu-id="da597-158">I detta fall alla $Z $-rotationer $2 \ Pi/2 ^ k $ där $k > en $ tas bort från QFT-kretsen.</span><span class="sxs-lookup"><span data-stu-id="da597-158">In this case all $Z$-rotations $2\pi/2^k$ where $k > a$ are removed from the QFT circuit.</span></span>
<span data-ttu-id="da597-159">Det är känt att för $k \ge \ log_2 (n) + \ log_2 (1/\epsilon) + $3.</span><span class="sxs-lookup"><span data-stu-id="da597-159">It is known that for $k \ge \log_2(n) + \log_2(1 / \epsilon) + 3$.</span></span> <span data-ttu-id="da597-160">en kan vara kopplad till $ \\ | \operatorname{QFT}-\operatorname{AQFT} \\ | < \epsilon $.</span><span class="sxs-lookup"><span data-stu-id="da597-160">one can bound $\\| \operatorname{QFT} - \operatorname{AQFT} \\| < \epsilon$.</span></span>
<span data-ttu-id="da597-161">Här $ \\ | \cdot \\ | $ är operator norm, som i det här fallet kvadratroten av den största [eigenvalue](xref:microsoft.quantum.concepts.matrix-advanced) $ (\operatorname{QFT}-\operatorname{AQFT}) (\operatorname{QFT}-\operatorname{AQFT}) ^ \dagger $.</span><span class="sxs-lookup"><span data-stu-id="da597-161">Here $\\|\cdot\\|$ is the operator norm which in this case is the square root of the largest [eigenvalue](xref:microsoft.quantum.concepts.matrix-advanced) of $(\operatorname{QFT} - \operatorname{AQFT})(\operatorname{QFT} - \operatorname{AQFT})^\dagger$.</span></span>

## <a name="arithmetic"></a><span data-ttu-id="da597-162">Aritmetisk</span><span class="sxs-lookup"><span data-stu-id="da597-162">Arithmetic</span></span> ##

<span data-ttu-id="da597-163">Precis som aritmetiskt spelar en central roll i klassisk data behandling, är det också inte nödvändigt i Quantum Computing.</span><span class="sxs-lookup"><span data-stu-id="da597-163">Just as arithmetic plays a central role in classical computing, it is also indispensable in quantum computing.</span></span>  <span data-ttu-id="da597-164">Algoritmer som Shor, Quantum simulerings metoder och många Oracular-algoritmer förlitar sig på sammanhängande aritmetiska åtgärder.</span><span class="sxs-lookup"><span data-stu-id="da597-164">Algorithms such as Shor's factoring algorithm, quantum simulation methods as well as many oracular algorithms rely upon coherent arithmetic operations.</span></span>  <span data-ttu-id="da597-165">De flesta metoder för aritmetiska byggen vid Quantum egenskapsangivning-kretsar.</span><span class="sxs-lookup"><span data-stu-id="da597-165">Most approaches to arithmetic build upon quantum adder circuits.</span></span>  <span data-ttu-id="da597-166">Den enklaste egenskapsangivning tar en klassisk in$b $ och lägger till värdet i ett Quantum-tillstånd som innehåller ett heltal $ \ket{a} $.</span><span class="sxs-lookup"><span data-stu-id="da597-166">The simplest adder takes a classical input $b$ and adds the value to a quantum state holding an integer $\ket{a}$.</span></span>  <span data-ttu-id="da597-167">Matematiskt, egenskapsangivning (som vi betecknar $ \operatorname{Add} (b) $ för klassisk in$b $) har egenskapen som</span><span class="sxs-lookup"><span data-stu-id="da597-167">Mathematically, the adder (which we denote $\operatorname{Add}(b)$ for classical input $b$) has the property that</span></span>

<span data-ttu-id="da597-168">$ $ \operatorname{Add} (b) \ket{a} = \ket{a + b}.</span><span class="sxs-lookup"><span data-stu-id="da597-168">$$ \operatorname{Add}(b)\ket{a}=\ket{a + b}.</span></span>
<span data-ttu-id="da597-169">$ $ Den här grundläggande egenskapsangivning-kretsen är mer av en ökning än en egenskapsangivning.</span><span class="sxs-lookup"><span data-stu-id="da597-169">$$ This basic adder circuit is more of an incrementer than an adder.</span></span>
<span data-ttu-id="da597-170">Den kan konverteras till en egenskapsangivning som har två Quantum-indata via $ $ \operatorname{Add}\ket{a}\ket{b} = \ket{a}\ket{a + b}, $ $ med $n $ kontrollerade program för Adders av formuläret & \begin{align} \operatorname{Add} \ket{a} \ket{b} \Lambda = \Left \_ {a \_ 0} \operatorname{Add} (\right (1) \Lambda) \_ { \_ 1} \left (\operatorname{Add} (2) \right) \Lambda \_ {a \_ 2} \left (\operatorname{Add} (4) \right) \cdots \Lambda \_ { \_ n-1}} \left (\operatorname{Add} ({{n-1}}) \right) \ket{a}\ket{b} \\ \\ & = \ket{a} \ket{b + a}, \end{align} för $n $-bitars heltal $a $ och $b $ och additionen modulo $2 ^ n $.</span><span class="sxs-lookup"><span data-stu-id="da597-170">It can be converted into an adder that has two quantum inputs via $$ \operatorname{Add}\ket{a}\ket{b}=\ket{a}\ket{a+b}, $$ using $n$ controlled applications of adders of the form \begin{align} \operatorname{Add} \ket{a} \ket{b} & = \Lambda\_{a\_0} \left(\operatorname{Add}(1) \right) \Lambda\_{a\_1} \left(\operatorname{Add}(2) \right) \Lambda\_{a\_2} \left(\operatorname{Add}(4) \right) \cdots \Lambda\_{a\_{n-1}} \left(\operatorname{Add}({{n-1}}) \right) \ket{a}\ket{b} \\\\ & = \ket{a} \ket{b + a}, \end{align} for $n$-bit integers $a$ and $b$ and addition modulo $2^n$.</span></span>  <span data-ttu-id="da597-171">Kom ihåg att notationen $ \Lambda \_ x (A) $ refererar, för alla åtgärder $A $, till den kontrollerade versionen av åtgärden med qubit-$x $ as-kontrollen.</span><span class="sxs-lookup"><span data-stu-id="da597-171">Recall that the notation $\Lambda\_x(A)$ refers, for any operation $A$, to the controlled version of that operation with the qubit $x$ as control.</span></span>

<span data-ttu-id="da597-172">På samma sätt kan en klassisk och kontrollerad multiplikation (en modulär form av som är viktig för Shor) utföras med hjälp av en liknande serie med kontrollerade tillägg: \begin{align} \operatorname{Mult} (a) \ket{x}\ket{b} & = \Lambda \_ {x \_ 0} \Left (\operatorname{Add} (2 ^ 0 a) \Right) \Lambda \_ {a \_ 1} \left (\operatorname{Add} (2 ^ 1a) \right) \Lambda \_ {a \_ 2} \left (\operatorname{Add} (2 ^ 2 a) \right) \cdots \Lambda \_ {x \_ {n-1}} \left (\operatorname{Add} ({2 ^ {n-1}} a) \right) \ket{x}\ket{b} \\ \\ & = \ket{x}\ket{b + AX}.</span><span class="sxs-lookup"><span data-stu-id="da597-172">Similarly, classically controlled multiplication (a modular form of which is essential for Shor's factoring algorithm) can be performed by using a similar series of controlled  additions: \begin{align} \operatorname{Mult}(a)\ket{x}\ket{b} & = \Lambda\_{x\_0}\left(\operatorname{Add}(2^0 a)\right) \Lambda\_{a\_1}\left(\operatorname{Add}(2^1a)\right) \Lambda\_{a\_2}\left(\operatorname{Add}(2^2 a)\right) \cdots \Lambda\_{x\_{n-1}} \left(\operatorname{Add}({2^{n-1}}a) \right)\ket{x}\ket{b} \\\\ & = \ket{x}\ket{b+ax}.</span></span>
<span data-ttu-id="da597-173">\end{align} det finns en subtlety med multiplikation på quantum-datorer som du kan märka från definitionen av $ \operatorname{Mult} $ ovan.</span><span class="sxs-lookup"><span data-stu-id="da597-173">\end{align} There is a subtlety with multiplication on quantum computers that you may notice from the definition of $\operatorname{Mult}$ above.</span></span>  <span data-ttu-id="da597-174">Till skillnad från addition lagrar den Quantum-versionen av den här kretsen produkten av indata i ett hjälp register i stället för i inmatnings register.</span><span class="sxs-lookup"><span data-stu-id="da597-174">Unlike addition, the quantum version of this circuit stores the product of the inputs in an ancillary register rather than in the input register.</span></span>  <span data-ttu-id="da597-175">I det här exemplet initieras registreringen med värdet $b $, men vanligt vis börjar det att ha värdet noll.</span><span class="sxs-lookup"><span data-stu-id="da597-175">In this example, the register is initialized with the value $b$, but typically it will start holding the value zero.</span></span>  <span data-ttu-id="da597-176">Detta krävs i eftersom det inte finns någon multiplicative-invers för General $a $ och $x $.</span><span class="sxs-lookup"><span data-stu-id="da597-176">This is needed in because in general there is not a multiplicative inverse for general $a$ and $x$.</span></span>  <span data-ttu-id="da597-177">Eftersom alla Quantum-åtgärder sparar måttet, måste vi ha tillräckligt med information runt för att invertera multiplikationen.</span><span class="sxs-lookup"><span data-stu-id="da597-177">Since all quantum operations, save measurement, are reversible we need to keep enough information around to invert the multiplication.</span></span>  <span data-ttu-id="da597-178">Av den anledningen lagras resultatet i en separat matris.</span><span class="sxs-lookup"><span data-stu-id="da597-178">For this reason the result is stored in a separate array.</span></span>  <span data-ttu-id="da597-179">Detta är ett exempel på hur du sparar utdata från en oåterkallelig åtgärd, som multiplikation, i ett separat register kallas "Bennette stick" efter Kalle Bennett och är ett grundläggande verktyg i både reversibel och Quantum data behandling.</span><span class="sxs-lookup"><span data-stu-id="da597-179">This trick of saving the output of an irreversible operation, like multiplication, in a separate register is known as the "Bennett trick" after Charlie Bennett and is a fundamental tool in both reversible and quantum computing.</span></span>

<span data-ttu-id="da597-180">Många Quantum-kretsar har föreslagits för addition och var och en har en annan kompromiss avseende antalet qubits (utrymme) och antalet grind åtgärder (tid) som krävs.</span><span class="sxs-lookup"><span data-stu-id="da597-180">Many quantum circuits have been proposed for addition and each explores a different tradeoff in terms of the number of qubits (space) and the number of gate operations (time) required.</span></span>  <span data-ttu-id="da597-181">Vi går igenom två mycket utrymmes effektiva Adders nedan kallad Draper egenskapsangivning och Beauregard egenskapsangivning.</span><span class="sxs-lookup"><span data-stu-id="da597-181">We review two highly space efficient adders below known as the Draper adder and the Beauregard adder.</span></span>

### <a name="draper-adder"></a><span data-ttu-id="da597-182">Draper Egenskapsangivning</span><span class="sxs-lookup"><span data-stu-id="da597-182">Draper Adder</span></span> ###

<span data-ttu-id="da597-183">Draper-egenskapsangivning är utan tvekan en av de mest eleganta Quantum-Adders, eftersom det direkt anropar Quantum-egenskaperna för att utföra addition.</span><span class="sxs-lookup"><span data-stu-id="da597-183">The Draper adder is arguably one of the most elegant quantum adders, as it directly invokes quantum properties to perform addition.</span></span>  <span data-ttu-id="da597-184">Insikterna bakom Draper-egenskapsangivning är att Fourier-transformeringen kan användas för att översätta fas växlingar till en bit-Shift.</span><span class="sxs-lookup"><span data-stu-id="da597-184">The insight behind the Draper adder is that the Fourier transform can be used to translate phase shifts into a bit shift.</span></span>  <span data-ttu-id="da597-185">Därefter följer det genom att använda en Fourier-transformering, tillämpa lämpliga fas växlingar och sedan ångra Fourier-transformeringen kan du implementera en egenskapsangivning.</span><span class="sxs-lookup"><span data-stu-id="da597-185">It then follows that by applying a Fourier transform, applying appropriate phase shifts, and then undoing the Fourier transform you can implement an adder.</span></span>  <span data-ttu-id="da597-186">Till skillnad från många andra Adders som har föreslagits använder Draper-egenskapsangivning Quantum-effekter som introduceras genom Quantum Fourier-transformeringen.</span><span class="sxs-lookup"><span data-stu-id="da597-186">Unlike many other adders that have been proposed, the Draper adder explicitly uses quantum effects introduced through the quantum Fourier transform.</span></span>  <span data-ttu-id="da597-187">Den har ingen naturlig klassisk motsvarighet.</span><span class="sxs-lookup"><span data-stu-id="da597-187">It does not have a natural classical counterpart.</span></span>  <span data-ttu-id="da597-188">De speciella stegen i Draper-egenskapsangivning anges nedan.</span><span class="sxs-lookup"><span data-stu-id="da597-188">The specific steps of the Draper adder are given below.</span></span>

<span data-ttu-id="da597-189">Anta att du har två $n $-bitars qubit-register som lagrar heltalen $a $ och $b $ och sedan för alla $a $ $ $ \operatorname{QFT}\ket{a} = \frac {1} {\sqrt{2 ^ n}} \sum \_ {j = 0} ^ {2 ^ n-1} e ^ {i2\pi (aj)/2 ^ n} \ket{j}.</span><span class="sxs-lookup"><span data-stu-id="da597-189">Assume that you have two $n$-bit qubit registers storing the integers $a$ and $b$ then for all $a$ $$ \operatorname{QFT}\ket{a}= \frac{1}{\sqrt{2^n}}\sum\_{j=0}^{2^n-1} e^{i2\pi(aj)/2^n} \ket{j}.</span></span>
<span data-ttu-id="da597-190">$ $ Om vi definierar $ $ \ket{\phi \_ k (a)} = \frac {1} {\sqrt {2} } \left (\ket {0} + e ^ {i2\pi a/2 ^ k} \ket {1} \right), $ $ efter vissa algebra kan du se att $ $ \operatorname{QFT}\ket{a} = \ket{\phi \_ 1 (a)} \otimes \cdots \otimes \ket{\phi \_ n (a)}.</span><span class="sxs-lookup"><span data-stu-id="da597-190">$$ If we define $$ \ket{\phi\_k(a)} = \frac{1}{\sqrt{2}}\left(\ket{0} + e^{i2\pi a /2^k}\ket{1} \right), $$ then after some algebra you can see that $$ \operatorname{QFT}\ket{a}=\ket{\phi\_1(a)}\otimes \cdots \otimes \ket{\phi\_n(a)}.</span></span>
<span data-ttu-id="da597-191">$ $ Sökvägen för att utföra en egenskapsangivning blir sedan tydlig efter att du har iakttagit att summan av indata kan skrivas som $ $ \ket{a + b} = \operatorname{QFT} ^ {-1} \ket{\phi \_ 1 (a + b)} \otimes \cdots \otimes \ket{\phi \_ n (a + b)}.</span><span class="sxs-lookup"><span data-stu-id="da597-191">$$ The path towards performing an adder then becomes clear after observing that the sum of the inputs can be written as $$ \ket{a+b}=\operatorname{QFT}^{-1}\ket{\phi\_1(a+b)}\otimes \cdots \otimes \ket{\phi\_n(a+b)}.</span></span>
<span data-ttu-id="da597-192">$ $ Heltalen $b $ och $a $ kan sedan läggas till genom att utföra rotation med styrd fas på varje qubits i nedbrytningen med hjälp av bitarna i $b $ som kontroller.</span><span class="sxs-lookup"><span data-stu-id="da597-192">$$ The integers $b$ and $a$ can then be added by performing controlled-phase rotation on each of the qubits in the decomposition using the bits of $b$ as controls.</span></span>

<span data-ttu-id="da597-193">Den här utökningen kan för enklas ytterligare genom att notera att för alla heltal $j $ och reella tal $x $, $e ^ {i2\pi (x + j)} = e ^ {i2\pi x} $.</span><span class="sxs-lookup"><span data-stu-id="da597-193">This expansion can be further simplified by noting that for any integer $j$ and real number $x$, $e^{i2\pi(x+j)}=e^{i2\pi x}$.</span></span>  <span data-ttu-id="da597-194">Detta beror på att om du roterar $360 ^ {\circ} $ grader ($ 2 \ pi $ radianer) i en cirkel så slutar du exakt där du startade.</span><span class="sxs-lookup"><span data-stu-id="da597-194">This is because if you rotate $360^{\circ}$ degrees ($2\pi$ radians) in a circle then you end up precisely where you started.</span></span>  <span data-ttu-id="da597-195">Den enda viktiga delen av $x $ för $e ^ {i2\pi x} $ är därför bråk delen av $x $.</span><span class="sxs-lookup"><span data-stu-id="da597-195">The only important part of $x$ for $e^{i2\pi x}$ is therefore the fractional part of $x$.</span></span>  <span data-ttu-id="da597-196">Mer specifikt, om vi har en binär expansion av formuläret $x = y-+0. x \_ 0x \_ 2 \ ldots x \_ n $ och $e sedan ^ {i2\pi x} = e ^ {i2\pi (0. x \_ 0x \_ 2 \ ldots x \_ {n-1})} $ och därmed $ $ \ket{\phi \_ k (a + b)} = \frac {1} {\sqrt {2} } \left (\ket {0} + e ^ {i2\pi [a/2 ^ k +0. b \_ K\ldots b \_ 1]} \ket {1} \right). $ $ det innebär att om vi utför addition genom att öka de olika styrkorts faktorerna i utökningen av Fourier-omvandlingen för $ \ket{a} $, minskar antalet rotationer som $k $ minskar.</span><span class="sxs-lookup"><span data-stu-id="da597-196">Specifically, if we have a binary expansion of the form $x=y+0.x\_0x\_2\ldots x\_n$ then $e^{i2\pi x}=e^{i2\pi (0.x\_0x\_2\ldots x\_{n-1})}$ and hence $$\ket{\phi\_k(a+b)}=\frac{1}{\sqrt{2}}\left(\ket{0} + e^{i2\pi [a/2^k+0.b\_k\ldots b\_1]}\ket{1} \right).$$ This means that if we perform addition by incrementing each of the tensor factors in the expansion of the Fourier transform of $\ket{a}$ then the number of rotations shrinks as $k$ decreases.</span></span>  <span data-ttu-id="da597-197">Detta minskar avsevärt antalet Quantum-grindar som krävs i egenskapsangivning.</span><span class="sxs-lookup"><span data-stu-id="da597-197">This substantially reduces the number of quantum gates needed in the adder.</span></span>  <span data-ttu-id="da597-198">Vi betecknar Fourier Transform, Phase addition och inverterade Fourier-transformationer som utgör Draper egenskapsangivning som $ \operatorname{QFT} ^ {-1} \left (\Phi \\ \! \operatorname{Add}\right) \operatorname{QFT} $.</span><span class="sxs-lookup"><span data-stu-id="da597-198">We denote the Fourier transform, phase addition and the inverse Fourier transform steps that comprise the Draper adder as $\operatorname{QFT}^{-1} \left(\phi\\\!\operatorname{ADD}\right) \operatorname{QFT}$.</span></span> <span data-ttu-id="da597-199">En Quantum-krets som använder denna förenkling för att implementera hela processen kan visas nedan.</span><span class="sxs-lookup"><span data-stu-id="da597-199">A quantum circuit that uses this simplification to implement the entire process can be seen below.</span></span>

![Draper egenskapsangivning visas som krets diagram](~/media/draper.svg)

<span data-ttu-id="da597-201">Varje kontrollerad $e ^ {i2 \ PI/k} $ grind i kretsen refererar till en kontrollerad fas-grind.</span><span class="sxs-lookup"><span data-stu-id="da597-201">Each controlled $e^{i2\pi/k}$ gate in the circuit refers to a controlled-phase gate.</span></span>  <span data-ttu-id="da597-202">Sådana grindar har den egenskap som finns på det qubits som de agerar på, $ \ket {00} \mapsto \ket {00} $ men $ \ket {11} \mapsto e ^ {i2 \ PI/k} \ ket {11} $.</span><span class="sxs-lookup"><span data-stu-id="da597-202">Such gates have the property that on the pair of qubits on which they act, $\ket{00}\mapsto \ket{00}$ but $\ket{11}\mapsto e^{i2\pi/k}\ket{11}$.</span></span>  <span data-ttu-id="da597-203">Med den här kretsen kan vi utföra addition genom att inte använda ytterligare qubits förutom de som behövs för att lagra indata och utdata.</span><span class="sxs-lookup"><span data-stu-id="da597-203">This circuit allows us to perform addition using no additional qubits apart from those needed to store the inputs and the outputs.</span></span>

### <a name="beauregard-adder"></a><span data-ttu-id="da597-204">Beauregard Egenskapsangivning</span><span class="sxs-lookup"><span data-stu-id="da597-204">Beauregard Adder</span></span> ###

<span data-ttu-id="da597-205">Beauregard-egenskapsangivning är en Quantum modulär egenskapsangivning som använder Draper-egenskapsangivning för att utföra ytterligare modulo $N $ för ett godtyckligt värde med positivt heltal $N $.</span><span class="sxs-lookup"><span data-stu-id="da597-205">The Beauregard adder is a quantum modular adder that uses the Draper adder in order to perform addition modulo $N$ for an arbitrary value positive integer $N$.</span></span>  <span data-ttu-id="da597-206">Betydelsen av Quantum modulära Adders, t. ex. Beauregard-egenskapsangivning, står i stor utsträckning från användningen i modulärt exponent steg inom Shor-algoritmen för factoring.</span><span class="sxs-lookup"><span data-stu-id="da597-206">The significance of quantum modular adders, such as the Beauregard adder, stems to a large extent from their use in the modular exponentiation step within Shor's algorithm for factoring.</span></span>  <span data-ttu-id="da597-207">En Quantum modulär egenskapsangivning har följande åtgärd för Quantum-ingången $ \ket{b} $ och klassisk in$a $ där $a $ och $b $ har utlovats som heltals mod $N $, vilket innebär att de är i intervallet $ [0, \ldots, N-1] $.</span><span class="sxs-lookup"><span data-stu-id="da597-207">A quantum modular adder has the following action for quantum input $\ket{b}$ and classical input $a$ where $a$ and $b$ are promised to be integers mod $N$, meaning that they are in the interval $[0,\ldots, N-1]$.</span></span>

<span data-ttu-id="da597-208">$ $ \ket{b}\rightarrow \ket{b + \text{mod} N} = \begin{Cases} \ket{b + a}, & b + a < N \\ \\ \ket{b + a-N}, & (b + a) \ge N \end{cases}.</span><span class="sxs-lookup"><span data-stu-id="da597-208">$$ \ket{b}\rightarrow \ket{b+a \text{ mod }N}=\begin{cases} \ket{b+a},& b+a < N\\\\ \ket{b+a-N},& (b+a)\ge N \end{cases}.</span></span>
$$

<span data-ttu-id="da597-209">Beauregard-egenskapsangivning använder Draper-egenskapsangivning, eller mer specifikt $ \phi \\ \! \operatorname{Add} $, för att lägga till $a $ och $b $ i fas.</span><span class="sxs-lookup"><span data-stu-id="da597-209">The Beauregard adder uses the Draper adder, or more specifically $\phi\\\!\operatorname{ADD}$, to add $a$ and $b$ in phase.</span></span>  <span data-ttu-id="da597-210">Den använder sedan samma åtgärd för att identifiera om $a + b <N $ genom att subtrahera $N $ och testa om $a + b-N<$0.</span><span class="sxs-lookup"><span data-stu-id="da597-210">It then uses the same operation to identify whether $a+b <N$ by subtracting $N$ and testing if $a+b-N<0$.</span></span>  <span data-ttu-id="da597-211">Kretsen lagrar den här informationen i en hjälp qubit och lägger sedan till $N $ tillbaka registret om $a + b<N $.</span><span class="sxs-lookup"><span data-stu-id="da597-211">The circuit stores this information in an ancillary qubit and then adds $N$ back the register if $a+b<N$.</span></span>  <span data-ttu-id="da597-212">Den kommer sedan att ingå i den här hjälp biten (det här steget krävs för att säkerställa att Ancilla kan avallokeras när egenskapsangivning har anropats).</span><span class="sxs-lookup"><span data-stu-id="da597-212">It then concludes by uncomputing this ancillary bit (this step is needed to ensure that the ancilla can be de-allocated after calling the adder).</span></span>  <span data-ttu-id="da597-213">Kretsen för Beauregard-egenskapsangivning anges nedan.</span><span class="sxs-lookup"><span data-stu-id="da597-213">The circuit for the Beauregard adder is given below.</span></span>

![Beauregard egenskapsangivning visas som krets diagram](~/media/beau.svg)

<span data-ttu-id="da597-215">Här är grinden $ \Phi \\ \! \operatorname{Add} $ samma form som $ \Phi \\ \! \operatorname{Add} $, förutom att i den här kontexten är indatamängden klassisk i stället för Quantum.</span><span class="sxs-lookup"><span data-stu-id="da597-215">Here the gate $\Phi\\\!\operatorname{ADD}$ takes the same form as $\phi\\\!\operatorname{ADD}$ except that in this context the input is classical rather than quantum.</span></span>  <span data-ttu-id="da597-216">På så sätt kan de kontrollerade faserna i $ \Phi \\ \! \operatorname{Add} $ ersättas med fas grindar som sedan kan kompileras tillsammans till färre åtgärder för att minska antalet qubits och antalet portar som behövs för egenskapsangivning.</span><span class="sxs-lookup"><span data-stu-id="da597-216">This allows the controlled phases in $\Phi\\\!\operatorname{ADD}$ to be replaced with phase gates that can then be compiled together into fewer operations to reduce both the number of qubits and number of gates needed for the adder.</span></span>

<span data-ttu-id="da597-217">Mer information finns i [M. Roetteler, Th. Beth](http://doi.org/10.1007/s00200-008-0072-2 ) och [D. Coppersmith](https://arxiv.org/abs/quant-ph/0201067).</span><span class="sxs-lookup"><span data-stu-id="da597-217">For more details, please refer to [M. Roetteler, Th. Beth](http://doi.org/10.1007/s00200-008-0072-2 ) and [D. Coppersmith](https://arxiv.org/abs/quant-ph/0201067).</span></span>

### <a name="quantum-phase-estimation"></a><span data-ttu-id="da597-218">Uppskattning av kvantfasen</span><span class="sxs-lookup"><span data-stu-id="da597-218">Quantum Phase Estimation</span></span> ###

<span data-ttu-id="da597-219">En särskilt viktig tillämpning av Quantum Fourier-transformeringen är att lära sig Eigenvalues av goda operatörer, ett problem som är känt som *fas uppskattning*.</span><span class="sxs-lookup"><span data-stu-id="da597-219">One particularly important application of the quantum Fourier transform is to learn the eigenvalues of unitary operators, a problem known as *phase estimation*.</span></span>
<span data-ttu-id="da597-220">Överväg en enhetlig $U $ och ett tillstånd $ \ket{\phi} $ så att $ \ket{\phi} $ är en eigenstate av $U $ med okänd eigenvalue $ \phi $, \begin{Equation} U\ket {\ Fi} = \phi\ket{\phi}.</span><span class="sxs-lookup"><span data-stu-id="da597-220">Consider a unitary $U$ and a state $\ket{\phi}$ such that $\ket{\phi}$ is an eigenstate of $U$ with unknown eigenvalue $\phi$, \begin{equation} U\ket{\phi} = \phi\ket{\phi}.</span></span>
<span data-ttu-id="da597-221">\end{Equation} om vi bara har åtkomst till $U $ som Oracle, kan vi lära dig fasen $ \phi $ genom att använda $Z $-rotationer som tillämpas på målet för en kontrollerad åtgärd som sprids tillbaka till kontrollen.</span><span class="sxs-lookup"><span data-stu-id="da597-221">\end{equation} If we only have access to $U$ as an oracle, then we can learn the phase $\phi$ by utilizing that $Z$ rotations applied to the target of a controlled operation propagate back onto the control.</span></span>

<span data-ttu-id="da597-222">Anta att $V $ är en kontrollerad tillämpning av $U $, till exempel \begin{align} V (\ket {0} \otimes \ket{\phi}) & = \ket {0} \otimes \ket{\phi} \textrm{ \\ \\ och} V (\ket {1} \otimes \ket{\phi}) & = e ^ {i \phi} \ket {1} \otimes \ket{\phi}.</span><span class="sxs-lookup"><span data-stu-id="da597-222">Suppose that $V$ is a controlled application of $U$, such that \begin{align} V (\ket{0} \otimes \ket{\phi}) & =            \ket{0} \otimes \ket{\phi} \\\\ \textrm{ and } V (\ket{1} \otimes \ket{\phi}) & = e^{i \phi} \ket{1} \otimes \ket{\phi}.</span></span>
<span data-ttu-id="da597-223">\end{align} sedan linjärt, \begin{align} V (\ket{+} \otimes \ket{\phi}) & = \frac{(\ket {0} \otimes \ket{\phi}) + e ^ {i \phi} (\ket {1} \otimes \ket{\phi})} {\sqrt {2} }.</span><span class="sxs-lookup"><span data-stu-id="da597-223">\end{align} Then, by linearity, \begin{align} V(\ket{+} \otimes \ket{\phi}) & = \frac{ (\ket{0} \otimes \ket{\phi}) + e^{i \phi} (\ket{1} \otimes \ket{\phi}) }{\sqrt{2}}.</span></span>
<span data-ttu-id="da597-224">\end{align} vi kan samla in villkor för att hitta \begin{align} V (\ket{+} \otimes \ket{\phi}) & = \frac{\ket {0} + e ^ {i \phi} \ket {1} } {\sqrt {2} } \otimes \ket{\phi} \\ \\ & = (R_1 (\phi) \ket{+}) \otimes \ket{\phi}, \end{align} där $R _1 $ är den volym som används av <xref:microsoft.quantum.intrinsic.r1> åtgärden.</span><span class="sxs-lookup"><span data-stu-id="da597-224">\end{align} We can collect terms to find that \begin{align} V(\ket{+} \otimes \ket{\phi}) & = \frac{\ket{0} + e^{i \phi} \ket{1}}{\sqrt{2}} \otimes \ket{\phi} \\\\ & = (R_1(\phi) \ket{+}) \otimes \ket{\phi}, \end{align} where $R_1$ is the unitary applied by the <xref:microsoft.quantum.intrinsic.r1> operation.</span></span>
<span data-ttu-id="da597-225">Det är på ett annat sätt att tillämpa $V $ på samma sätt som att använda $R _1 $ med en okänd vinkel, trots att vi bara har åtkomst till $V $ som Oracle.</span><span class="sxs-lookup"><span data-stu-id="da597-225">Put differently, the effect of applying $V$ is precisely the same as applying $R_1$ with an unknown angle, even though we only have access to $V$ as an oracle.</span></span>
<span data-ttu-id="da597-226">För resten av denna diskussion kommer vi därför att diskutera fasens uppskattning i termer av $R _1 (\phi) $, som vi implementerar med hjälp av så kallade *fas Kickback*.</span><span class="sxs-lookup"><span data-stu-id="da597-226">Thus, for the rest of this discussion we will discuss phase estimation in terms of $R_1(\phi)$, which we implement by using so-called *phase kickback*.</span></span>

<span data-ttu-id="da597-227">Eftersom kontroll-och mål registret fortfarande är untangled efter den här processen kan vi återanvända $ \ket{\phi} $ som mål för ett kontrollerat program med $U ^ $2 för att förbereda en andra kontroll qubit i tillstånd $R _1 (2 \phi) \ket{+} $.</span><span class="sxs-lookup"><span data-stu-id="da597-227">Since the control and target register remain untangled after this process, we can reuse $\ket{\phi}$ as the target of a controlled application of $U^2$ to prepare a second control qubit in the state $R_1(2 \phi) \ket{+}$.</span></span>
<span data-ttu-id="da597-228">Om du fortsätter på det här sättet kan vi hämta ett register över formatet \begin{align} \ket{\psi} & = \ sum_ {j = 0} ^ n R_1 (2 ^ j \phi) \ket{+} \\ \\ & \propto \ bigotimes_ {j = 0} ^ {n} \left (\ket {0} + \exp (i 2 ^ {j} \phi) \ket {1} \right) \\ \\ & \propto \ sum_ {k = 0} ^ {2 ^ n-1} \exp (i \phi k) \ket{k} \end{align} där $n $ är antalet precisions bitar som vi behöver, och där vi har använt $ {} \propto {} $ för att visa att vi har ignorerat normaliserings faktorn för $1/\sqrt{2 ^ n} $.</span><span class="sxs-lookup"><span data-stu-id="da597-228">Continuing in this way, we can obtain a register of the form \begin{align} \ket{\psi} & = \sum_{j = 0}^n R_1(2^j \phi) \ket{+} \\\\ & \propto \bigotimes_{j=0}^{n} \left(\ket{0} + \exp(i 2^{j} \phi) \ket{1}\right) \\\\ & \propto \sum_{k = 0}^{2^n - 1} \exp(i \phi k) \ket{k} \end{align} where $n$ is the number of bits of precision that we require, and where we have used ${} \propto {}$ to indicate that we have suppressed the normalization factor of $1 / \sqrt{2^n}$.</span></span>

<span data-ttu-id="da597-229">Om vi antar att $ \phi = 2 \pi p/2 ^ k $ för ett heltal $p $, känner vi igen detta som $ \ket{\psi} = \operatorname{QFT} \ket{p_0 p_1 \dots p_n} $, där $p _j $ är $j ^ {\textrm{th}} $ bit $2 \pi $.</span><span class="sxs-lookup"><span data-stu-id="da597-229">If we assume that $\phi = 2 \pi p / 2^k$ for an integer $p$, then we recognize this as $\ket{\psi} = \operatorname{QFT} \ket{p_0 p_1 \dots p_n}$, where $p_j$ is the $j^{\textrm{th}}$ bit of $2 \pi \phi$.</span></span>
<span data-ttu-id="da597-230">Genom att använda det angränsande av Quantum Fourier-transformeringen får vi därför en binär representation av fasen som är kodad som ett Quantum-tillstånd.</span><span class="sxs-lookup"><span data-stu-id="da597-230">Applying the adjoint of the quantum Fourier transform, we therefore obtain the binary representation of the phase encoded as a quantum state.</span></span>

<span data-ttu-id="da597-231">I Q# implementeras detta av <xref:microsoft.quantum.characterization.quantumphaseestimation> åtgärden, som använder ett <xref:microsoft.quantum.oracles.discreteoracle> implementerings program av $U ^ m $ som en funktion av positiva heltal $m $.</span><span class="sxs-lookup"><span data-stu-id="da597-231">In Q#, this is implemented by the <xref:microsoft.quantum.characterization.quantumphaseestimation> operation, which takes a <xref:microsoft.quantum.oracles.discreteoracle> implementing application of $U^m$ as a function of positive integers $m$.</span></span>
