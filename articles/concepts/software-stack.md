---
title: Program varu stack | Microsoft Docs
description: Program varu stack
author: QuantumWriter
uid: microsoft.quantum.concepts.software-stack
ms.author: nawiebe@microsoft.com
ms.date: 12/11/2017
ms.topic: article
ms.openlocfilehash: f97dfacf6cde5fa92e1f368efaae36554a5c944d
ms.sourcegitcommit: 8becfb03eb60ba205c670a634ff4daa8071bcd06
ms.translationtype: MT
ms.contentlocale: sv-SE
ms.lasthandoff: 10/28/2019
ms.locfileid: "73184737"
---
# <a name="software-stack-for-quantum-computing"></a><span data-ttu-id="7eaab-103">Program varu stack för Quantum Computing</span><span class="sxs-lookup"><span data-stu-id="7eaab-103">Software stack for quantum computing</span></span>
<span data-ttu-id="7eaab-104">Normalt när vi tänker på en dator vi Envision en enda enhet som kör ett program, men moderna dator miljöer är mycket mer komplexa och avancerade.</span><span class="sxs-lookup"><span data-stu-id="7eaab-104">Normally when we think of a computer we envision a single device running an application, but modern computing environments are much more complex and advanced.</span></span> <span data-ttu-id="7eaab-105">Det program vi interagerar med brukar finnas på flera lager program som tillhandahåller program körningen på maskin varu nivå.</span><span class="sxs-lookup"><span data-stu-id="7eaab-105">The application we interact with typically rests on multiple layers of software that provide for the application's execution down to the hardware level.</span></span> <span data-ttu-id="7eaab-106">De här program varu lagren är nödvändiga för att kunna sammanfatta utvecklingen av en program lösning från den underliggande komplexiteten hos hela data behandlings systemet.</span><span class="sxs-lookup"><span data-stu-id="7eaab-106">These software layers are necessary to abstract the development of an application solution from the underlying complexity of the complete computing system.</span></span> <span data-ttu-id="7eaab-107">Om en utvecklare måste tänka på buss, cache-arkitekturer, kommunikations protokoll och mer när du skriver en enkel smartphone-app skulle uppgiften bli mycket mer komplex.</span><span class="sxs-lookup"><span data-stu-id="7eaab-107">If a developer had to think about bus, cache architectures, communication protocols, and more while writing a simple smartphone app, the task would become much more complex.</span></span>  <span data-ttu-id="7eaab-108">Begreppet *program varu stack* har utvecklats i klassiskt data behandling för att åtgärda problemen.</span><span class="sxs-lookup"><span data-stu-id="7eaab-108">The concept of a *software stack* was developed in classical computing to address these issues.</span></span>  <span data-ttu-id="7eaab-109">Om du lånar från det klassiska konceptet är en program varu stack också en viktig del av insikten bakom Quantum Computing med Q #.</span><span class="sxs-lookup"><span data-stu-id="7eaab-109">Borrowing from the classical concept, a software stack is also a key part of the vision behind quantum computing with Q#.</span></span>

## <a name="conventional-stack"></a><span data-ttu-id="7eaab-110">Konventionell stack</span><span class="sxs-lookup"><span data-stu-id="7eaab-110">Conventional stack</span></span>
<span data-ttu-id="7eaab-111">Den viktiga idén bakom en program varu stack är rekursion.</span><span class="sxs-lookup"><span data-stu-id="7eaab-111">The key idea behind a software stack is recursion.</span></span>  <span data-ttu-id="7eaab-112">Det består av flera kapslade lager med gränssnitt som sammanfattar information om de lägre nivåerna av enheten bort från utvecklaren.</span><span class="sxs-lookup"><span data-stu-id="7eaab-112">It consists of several nested layers of interfaces that abstract the details of the lower levels of the device away from the developer.</span></span>  <span data-ttu-id="7eaab-113">En vanlig program varu stack inbegriper till exempel att köra ASP.NET (ett programmeringsspråk), ovanpå SQL Server (ett Relations databas hanterings system), som körs ovanpå Internet Information Services (en webb server) som körs ovanpå Windows Server (en operativ system), som driver dator maskin varan.</span><span class="sxs-lookup"><span data-stu-id="7eaab-113">For example, a commonly used software stack involves running ASP.NET (a programming language), on top of SQL server (a relational database management system), which runs on top of Internet Information Services (a web server), which runs on top of Windows server (an operating system), which drives the computer hardware.</span></span>  <span data-ttu-id="7eaab-114">Genom att titta på program vara som en hierarki kan du skriva program vara i ASP.NET utan att behöva förstå information på låg nivå för all program vara under den.</span><span class="sxs-lookup"><span data-stu-id="7eaab-114">By looking at software as a hierarchy, one can write software in ASP.NET without needing to understand the low-level details of all the software below it.</span></span>

## <a name="quantum-stack"></a><span data-ttu-id="7eaab-115">Quantum-stack</span><span class="sxs-lookup"><span data-stu-id="7eaab-115">Quantum stack</span></span>

<span data-ttu-id="7eaab-116">Program varu stacken i Quantum Computing är inte annorlunda i princip, och i praktiken fungerar en lägre nivå än traditionella stackar.</span><span class="sxs-lookup"><span data-stu-id="7eaab-116">The software stack in quantum computing is no different in principle, and in practice operates at a lower level than traditional stacks.</span></span>  <span data-ttu-id="7eaab-117">Vad ser en Quantum-stack ut?</span><span class="sxs-lookup"><span data-stu-id="7eaab-117">What does a quantum stack look like?</span></span>  <span data-ttu-id="7eaab-118">En Quantum-dator ersätter inte traditionella (ofta kallade klassiska) datorer.</span><span class="sxs-lookup"><span data-stu-id="7eaab-118">A quantum computer is not a replacement for traditional (often called classical) computers.</span></span>  <span data-ttu-id="7eaab-119">Quantum-datorer kommer i själva verket att arbeta tillsammans med klassiska datorer för att lösa beräknings problem.</span><span class="sxs-lookup"><span data-stu-id="7eaab-119">In fact, quantum computers will almost certainly work in tandem with classical computers to solve computational problems.</span></span>  <span data-ttu-id="7eaab-120">Detta beror delvis på fragility av Quantum-data.</span><span class="sxs-lookup"><span data-stu-id="7eaab-120">In part, this arises because of the fragility of quantum data.</span></span>  <span data-ttu-id="7eaab-121">Quantum data är så känsliga att om du tittar på det nästan verkligen skadar du informationen som observeras.</span><span class="sxs-lookup"><span data-stu-id="7eaab-121">Quantum data is so fragile that if you even look at it you almost certainly damage the information being observed.</span></span>  <span data-ttu-id="7eaab-122">Quantum-datorer måste därför utformas med Quantum-fel korrigering i åtanke så att lösa interaktioner från dess fysiska miljö inte oavsiktligt skadar informationen och beräkningen.</span><span class="sxs-lookup"><span data-stu-id="7eaab-122">Quantum computers will thus need to be designed with quantum error correction in mind so that stray interactions from its physical environment do not inadvertently damage the information and computation.</span></span> <span data-ttu-id="7eaab-123">Av den anledningen är ett naturligt mål för Q # en felkorrigerad Quantum-dator (kallas ofta en *feltolerant* Quantum-dator) som accepterar en lista med Quantum-instruktioner (kallas grindar eller grind åtgärder) och tillämpar anvisningarna på Quantum data som lagras i den.</span><span class="sxs-lookup"><span data-stu-id="7eaab-123">For this reason, a natural target for Q# is an error-corrected quantum computer (often called a *fault-tolerant* quantum computer) that accepts a list of quantum instructions (called gates or gate operations) and applies those instructions to the quantum data stored within it.</span></span>  <span data-ttu-id="7eaab-124">Observera att om antalet qubits-och grind åtgärder i en Quantum-algoritm eller ett program är tillräckligt litet, kanske fel korrigeringen inte är absolut nödvändig.</span><span class="sxs-lookup"><span data-stu-id="7eaab-124">Note that if the number of qubits and gate operations in a quantum algorithm or program is small enough, error correction may not be absolutely necessary.</span></span>  <span data-ttu-id="7eaab-125">Men eftersom antalet qubits-och grind åtgärder växer är det mer effektivt att ha ett krav, vilket innebär att vi skapar vår program varu stack och Q # till aptly och effektivt hanterar fel korrigering och möjliggör skalbar, feltolerant Quantum-bearbetning.</span><span class="sxs-lookup"><span data-stu-id="7eaab-125">However as the number of qubits and gate operations grow, it will more certainly be a requirement, thus we architect our software stack and Q# to aptly and efficiently handle error correction and enable scalable, fault-tolerant quantum computing.</span></span>

### <a name="error-correction"></a><span data-ttu-id="7eaab-126">Fel korrigering</span><span class="sxs-lookup"><span data-stu-id="7eaab-126">Error correction</span></span>
<span data-ttu-id="7eaab-127">Vid fel korrigering krävs en snabb och tillförlitlig klassisk dator som kan köras tillsammans med Quantum-datorn för att korrigera fel när de visas i Quantum-beräkningen.</span><span class="sxs-lookup"><span data-stu-id="7eaab-127">Error correction requires a fast and reliable classical computer to be run in concert with the quantum computer to correct errors as they appear in the quantum computation.</span></span>  <span data-ttu-id="7eaab-128">I praktiken kan komponenter som till exempel FPGAs (Field-programmerbara grind mat ris) eller snabba cryogenic-processorer behövas för att identifiera och korrigera felen snabbare än de naturligt ackumulerade i Quantum-datorn.</span><span class="sxs-lookup"><span data-stu-id="7eaab-128">In practice, components such as field-programmable gate arrays (FPGAs) or fast cryogenic processors may be needed to identify and correct the errors faster than they naturally accumulate in the quantum computer.</span></span>  <span data-ttu-id="7eaab-129">Därför är en Quantum-dator en hybrid dator som består av flera olika beräknings enheter som fungerar över en mängd olika temperaturer.</span><span class="sxs-lookup"><span data-stu-id="7eaab-129">As a result, a quantum computer is a hybrid machine comprised of several different computational devices that operate over a wide range of temperatures.</span></span>  <span data-ttu-id="7eaab-130">Därför är det mycket mer användbart att tänka på att programmering av en Quantum-dator genom en program varu Stacks lins, eftersom det finns många lager av maskin vara och program vara (klassisk och Quantum) som krävs för att slutligen uppnå implementeringen av en Quantum algoritm på en Quantum-dator.</span><span class="sxs-lookup"><span data-stu-id="7eaab-130">For this reason, it is much more helpful to think about programming a quantum computer through the lens of a software stack, as there are many layers of hardware and software (classical and quantum) required to ultimately achieve the implementation of a quantum algorithm on a quantum computer.</span></span>

### <a name="quantum-conceptual-stack"></a><span data-ttu-id="7eaab-131">Quantum konceptuell stack</span><span class="sxs-lookup"><span data-stu-id="7eaab-131">Quantum conceptual stack</span></span>
<span data-ttu-id="7eaab-132">En konceptuell stack som illustrerar det funktionella flödet av factoring 8704143553785700723 i en Quantum computing-miljö visas nedan:</span><span class="sxs-lookup"><span data-stu-id="7eaab-132">A conceptual stack that illustrates the functional flow of factoring 8704143553785700723 in a quantum computing environment is shown below:</span></span>

![Program varu stack](~/media/concepts_stack.png)

### <a name="specification-and-algorithm"></a><span data-ttu-id="7eaab-134">Specifikation och algoritm</span><span class="sxs-lookup"><span data-stu-id="7eaab-134">Specification and algorithm</span></span>
<span data-ttu-id="7eaab-135">Det finns flera olika stadier i programmering, till exempel en Quantum-beräkning.</span><span class="sxs-lookup"><span data-stu-id="7eaab-135">There are several broad stages of programming such a quantum computation.</span></span>  <span data-ttu-id="7eaab-136">Den första och utan tvekan mest utmanande fasen är att ange det problem som en vill lösa.</span><span class="sxs-lookup"><span data-stu-id="7eaab-136">The first, and arguably most challenging phase, is specifying the problem that one wishes to solve.</span></span>  <span data-ttu-id="7eaab-137">I det här fallet är problemet att Factor the Number 8704143553785700723 i en produkt med två primtal.</span><span class="sxs-lookup"><span data-stu-id="7eaab-137">In this case, the problem is to factor the number 8704143553785700723  into a product of two prime numbers.</span></span>  <span data-ttu-id="7eaab-138">Nästa steg innebär att utforma en algoritm för att lösa det här beräknings problemet.</span><span class="sxs-lookup"><span data-stu-id="7eaab-138">The next step involves designing an algorithm for solving this computational problem.</span></span>  <span data-ttu-id="7eaab-139">I det här fallet kan Shor berömda Quantum factoring-algoritmen användas för att hitta faktorerna.</span><span class="sxs-lookup"><span data-stu-id="7eaab-139">In this case, Shor's famous quantum factoring algorithm can be used to find the factors.</span></span>  <span data-ttu-id="7eaab-140">Den här algoritmen uttrycks i Q # och sedan är en sekvens med Quantum-åtgärder utdata som kan köras på en idealisk dator utan problem.</span><span class="sxs-lookup"><span data-stu-id="7eaab-140">This algorithm is expressed in Q# and then a sequence of quantum operations is output that could be run on an idealized error-free quantum computer.</span></span>  

### <a name="physical-gates"></a><span data-ttu-id="7eaab-141">Fysiska portar</span><span class="sxs-lookup"><span data-stu-id="7eaab-141">Physical gates</span></span>
<span data-ttu-id="7eaab-142">I det här exemplet är det inte så av typen att tillhandahålla en felfri Quantum-dator, så efterföljande steg tar de åtgärder som släpps av Q # och översätter dem med hjälp av mallar som anges av den Quantum-fel korrigerings metod som valts i fysiska grindar som den grundläggande maskin varan kan köras.</span><span class="sxs-lookup"><span data-stu-id="7eaab-142">In this example, assume nature is not so kind as to provide an error-free quantum computer so the subsequent step takes the operations emitted by Q# and translates them using templates specified by the quantum error correction method chosen into physical gates that the basic hardware can execute.</span></span>  <span data-ttu-id="7eaab-143">Den här processen omfattar att ersätta varje logisk qubit som beskrivs i den tidigare modellen med en värd med fysiska qubits som används för att lagra och skydda informationen i en enskild qubit i en redundant miljö som kan motstå lokala fel på den fysiska komponenten qubits tillräckligt länge för att sådana fel ska kunna identifieras och korrigeras.</span><span class="sxs-lookup"><span data-stu-id="7eaab-143">This process involves replacing every logical qubit described in the previous model with a host of physical qubits that are used to store and protect the information within a single qubit in a redundant fashion that can resist local errors on the constituent physical qubits long enough for such errors to be detected and corrected.</span></span>  <span data-ttu-id="7eaab-144">Precis som de logiska qubits som beskrivs av Q #-koden måste ersättas med många fysiska qubits, så måste varje Quantum-grind som beskrivs i utdata översättas till en sekvens med fysiska portar som fungerar på den fysiska qubits.</span><span class="sxs-lookup"><span data-stu-id="7eaab-144">Just as the logical qubits described by the Q# code need to be replaced with many physical qubits, similarly each quantum gate described in the output needs to be translated into a sequence of physical gates that act upon the physical qubits.</span></span>  <span data-ttu-id="7eaab-145">Därför är utmatningen av Q # sällan det slutliga målet för Quantum Computing och ytterligare nivåer av abstraktion krävs för att köra koden på maskin vara på ett Oblivious sätt.</span><span class="sxs-lookup"><span data-stu-id="7eaab-145">For this reason, the output of Q# is seldom the final target for quantum computing and further levels of abstraction are needed to execute the code on hardware in an oblivious fashion.</span></span>

### <a name="control-computer"></a><span data-ttu-id="7eaab-146">Kontrol lera dator</span><span class="sxs-lookup"><span data-stu-id="7eaab-146">Control computer</span></span>
<span data-ttu-id="7eaab-147">Den fysiska gaten läses sedan in i en vanlig dator som skickar instruktionerna till en kontroll dator som är gränssnitts direkt med den Quantum-datorn.</span><span class="sxs-lookup"><span data-stu-id="7eaab-147">The physical gate sequence is then loaded into an ordinary computer that sends these instructions down to a control computer that interfaces directly with the quantum computer.</span></span>  <span data-ttu-id="7eaab-148">Detta skikt i program varu stacken hanteras ofta av experimentell kontroll program som [QCoDeS](http://qcodes.github.io/Qcodes/).</span><span class="sxs-lookup"><span data-stu-id="7eaab-148">This layer within the software stack is often handled by experimental control software such as [QCoDeS](http://qcodes.github.io/Qcodes/).</span></span>

### <a name="interface-computer"></a><span data-ttu-id="7eaab-149">Gränssnitts dator</span><span class="sxs-lookup"><span data-stu-id="7eaab-149">Interface computer</span></span>
<span data-ttu-id="7eaab-150">Det sista steget i den här processen omfattar att gränssnitts datorn först strömma portarna efter behov till en snabb kontroll dator.</span><span class="sxs-lookup"><span data-stu-id="7eaab-150">The final step in this process involves the interface computer first streaming the gates as needed to a fast control computer.</span></span> <span data-ttu-id="7eaab-151">Sedan använder den snabba kontroll datorn de spänningar som krävs (vanligt vis kallade pulser) för att implementera de nödvändiga portarna på qubits.</span><span class="sxs-lookup"><span data-stu-id="7eaab-151">Then the fast control computer applies the voltages needed (commonly called pulses) to implement the required gates on qubits.</span></span> <span data-ttu-id="7eaab-152">Detta måste göras när du korrigerar eventuella fel som observeras genom Quantum Error-korrigering.</span><span class="sxs-lookup"><span data-stu-id="7eaab-152">This has to be done while correcting any errors that are observed through quantum error correction.</span></span>  <span data-ttu-id="7eaab-153">Cryogenic FPGAs eller annan exotiska maskin vara kan behövas för att utföra dessa steg inom de stränga tids krav som anges av den hastighet med vilken fel visas på datorn Quantum.</span><span class="sxs-lookup"><span data-stu-id="7eaab-153">Cryogenic FPGAs or other exotic hardware may be needed to perform these steps within the stringent time requirements imposed by the rate at which errors appear in the quantum computer.</span></span>  <span data-ttu-id="7eaab-154">Mål språket på den här nivån är ofta [VHDL](https://en.wikipedia.org/wiki/VHDL), vilket kräver ett tydligt sätt att fundera från det som används längst upp i stacken för att analysera en beskrivning av en Quantum-algoritm.</span><span class="sxs-lookup"><span data-stu-id="7eaab-154">The target language on this level is often [VHDL](https://en.wikipedia.org/wiki/VHDL), which requires a distinct way of thinking from that which is used at the top end of the stack to parse a description of a quantum algorithm.</span></span>

### <a name="the-q-quantum-programming-language"></a><span data-ttu-id="7eaab-155">Programmeringsspråket Q # Quantum</span><span class="sxs-lookup"><span data-stu-id="7eaab-155">The Q# quantum programming language</span></span>
<span data-ttu-id="7eaab-156">Syftet med Q # är att tillhandahålla ett enkelt språk som gör det möjligt för utvecklare att skriva kod som är riktad till en mängd olika plattformar och gränssnitt med de mellanliggande lagren av program vara som ligger mellan användaren och Quantum-enheten.</span><span class="sxs-lookup"><span data-stu-id="7eaab-156">The aim of Q# is to provide a simple language that allows developers to write code that targets a wealth of quantum computing platforms and interface with the intervening layers of software that stand between the user and the quantum device.</span></span>  <span data-ttu-id="7eaab-157">Språket fören klar detta genom att använda begreppet program varu stack och att sammanföra många detaljer i den underliggande Quantum-datorn samtidigt som du tillåter andra nivåer av stacken, som visas på ett språk som C#, för att utföra nödvändiga översättningar från Q # Code till grundläggande åtgärder.</span><span class="sxs-lookup"><span data-stu-id="7eaab-157">The language facilitates this by embracing the notion of a software stack and abstracting many of the details of the underlying quantum computer while allowing other levels of the stack, exposed through a language such as C#, to perform the necessary translations from Q# code to fundamental operations.</span></span>  <span data-ttu-id="7eaab-158">Detta gör att utvecklaren kan fokusera på vad de gör bäst: att utforma algoritmer och lösa problem.</span><span class="sxs-lookup"><span data-stu-id="7eaab-158">This allows the developer to focus on what they do best: designing algorithms and solving problems.</span></span>
