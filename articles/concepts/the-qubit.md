---
title: Qubit i Quantum Computing
description: Lär dig mer om qubits, den grundläggande informations enheten i Quantum Computing.
author: QuantumWriter
uid: microsoft.quantum.concepts.qubit
ms.author: nawiebe@microsoft.com
ms.date: 12/11/2017
ms.topic: article
ms.openlocfilehash: f5e5c2a66899c552ad39e63703c34718818b1452
ms.sourcegitcommit: 2317473fdf2b80de58db0f43b9fcfb57f56aefff
ms.translationtype: MT
ms.contentlocale: sv-SE
ms.lasthandoff: 05/15/2020
ms.locfileid: "83426962"
---
# <a name="the-qubit"></a><span data-ttu-id="374f4-103">Qubit</span><span class="sxs-lookup"><span data-stu-id="374f4-103">The Qubit</span></span>

<span data-ttu-id="374f4-104">Precis som BITS är det grundläggande informations objektet i klassisk data behandling, [*qubits*](https://en.wikipedia.org/wiki/Qubit) (Quantum bitar) är det grundläggande objektet av information i Quantum Computing.</span><span class="sxs-lookup"><span data-stu-id="374f4-104">Just as bits are the fundamental object of information in classical computing, [*qubits*](https://en.wikipedia.org/wiki/Qubit) (quantum bits) are the fundamental object of information in quantum computing.</span></span>  <span data-ttu-id="374f4-105">För att förstå den här korrespondensen ska vi titta på det enklaste exemplet: en enda qubit.</span><span class="sxs-lookup"><span data-stu-id="374f4-105">To understand this correspondence, let's look at the simplest example: a single qubit.</span></span>

## <a name="representing-a-qubit"></a><span data-ttu-id="374f4-106">Representerar en qubit</span><span class="sxs-lookup"><span data-stu-id="374f4-106">Representing a Qubit</span></span>

<span data-ttu-id="374f4-107">En bit, eller binär siffra, kan ha värdet antingen $0 $ eller $1 $, men en qubit kan ha ett värde som är antingen av dessa eller en Quantum överposition av $0 $ och $1 $.</span><span class="sxs-lookup"><span data-stu-id="374f4-107">While a bit, or binary digit, can have value either $0$ or $1$, a qubit can have a value that is either of these or a quantum superposition of $0$ and $1$.</span></span>

<span data-ttu-id="374f4-108">Status för en enda qubit kan beskrivas av en tvådimensionell kolumn vektor av enhets norm, det vill säga storleken i fyrkant måste vara sum till $1 $.</span><span class="sxs-lookup"><span data-stu-id="374f4-108">The state of a single qubit can be described by a two-dimensional column vector of unit norm, that is, the magnitude squared of its entries must sum to $1$.</span></span> <span data-ttu-id="374f4-109">Den här vektorn, som kallas Quantum State Vector, innehåller all information som behövs för att beskriva det qubit Quantum-systemet precis som en enskild bit innehåller all information som behövs för att beskriva statusen för en binär variabel.</span><span class="sxs-lookup"><span data-stu-id="374f4-109">This vector, called the quantum state vector, holds all the information needed to describe the one-qubit quantum system just as a single bit holds all of the information needed to describe the state of a binary variable.</span></span>

<span data-ttu-id="374f4-110">Alla tvådimensionella kolumn vektorer med reella eller komplexa tal med norm $1 $ är ett möjligt Quantum-tillstånd som innehas av en qubit.</span><span class="sxs-lookup"><span data-stu-id="374f4-110">Any two-dimensional column vector of real or complex numbers with norm $1$ represents a possible quantum state held by a qubit.</span></span> <span data-ttu-id="374f4-111">Därför representerar $ \begin{bmatrix} \alpha \\ \\ \beta \end{bmatrix} $ ett qubit-tillstånd om $ \alpha $ och $ \beta $ är komplexa tal som uppfyller $ | \alpha | ^ 2 + | \beta | ^ 2 = $1.</span><span class="sxs-lookup"><span data-stu-id="374f4-111">Thus $\begin{bmatrix} \alpha \\\\  \beta \end{bmatrix}$ represents a qubit state if $\alpha$ and $\beta$ are complex numbers satisfying $|\alpha|^2 + |\beta|^2 = 1$.</span></span> <span data-ttu-id="374f4-112">Några exempel på giltiga Quantum State-vektorer som representerar qubits include</span><span class="sxs-lookup"><span data-stu-id="374f4-112">Some examples of valid quantum state vectors representing qubits include</span></span>

<span data-ttu-id="374f4-113">$ $ \begin{bmatrix} 1 \\ \\ 0 \end{bmatrix}, \begin{bmatrix} 0 \\ \\ 1 \end{bmatrix}, \begin{bmatrix} \frac {1} {\sqrt {2} } \\ \\ \frac {1} {\sqrt {2} } \end{bmatrix}, \begin{bmatrix} \frac {1} {\sqrt {2} } \\ \\ \frac {-1} {\sqrt {2} } \end{bmatrix}, \text{och} \begin{bmatrix} \frac {1} {\sqrt {2} } \\ \\ \frac{i}{\sqrt {2} } \end{bmatrix}. $ $</span><span class="sxs-lookup"><span data-stu-id="374f4-113">$$\begin{bmatrix} 1 \\\\  0 \end{bmatrix}, \begin{bmatrix} 0 \\\\  1 \end{bmatrix}, \begin{bmatrix} \frac{1}{\sqrt{2}} \\\\  \frac{1}{\sqrt{2}} \end{bmatrix}, \begin{bmatrix} \frac{1}{\sqrt{2}} \\\\  \frac{-1}{\sqrt{2}} \end{bmatrix}, \text{ and }\begin{bmatrix} \frac{1}{\sqrt{2}} \\\\  \frac{i}{\sqrt{2}} \end{bmatrix}.$$</span></span>

<span data-ttu-id="374f4-114">Quantum State-vektorerna $ \begin{bmatrix} 1 \\ \\ 0 \end{bmatrix} $ och $ \begin{bmatrix} 0 \\ \\ 1 \end{bmatrix} $ tar en speciell roll.</span><span class="sxs-lookup"><span data-stu-id="374f4-114">The quantum state vectors $\begin{bmatrix} 1 \\\\  0 \end{bmatrix}$ and $\begin{bmatrix} 0 \\\\  1 \end{bmatrix}$ take a special role.</span></span> <span data-ttu-id="374f4-115">Dessa två vektorer utgör grunden för det vektor utrymme som beskriver qubit status.</span><span class="sxs-lookup"><span data-stu-id="374f4-115">These two vectors form a basis for the vector space that describes the qubit's state.</span></span> <span data-ttu-id="374f4-116">Det innebär att alla Quantum State Vector kan skrivas som en summa av dessa bas vektorer.</span><span class="sxs-lookup"><span data-stu-id="374f4-116">This means that any quantum state vector can be written as a sum of these basis vectors.</span></span> <span data-ttu-id="374f4-117">Mer specifikt kan vektorn $ \begin{bmatrix} x \\ \\ y \end{bmatrix} $ skrivas som $x \begin{bmatrix} 1 \\ \\ 0 \end{bmatrix} + y \begin{bmatrix} 0 \\ \\ 1 \end{bmatrix} $.</span><span class="sxs-lookup"><span data-stu-id="374f4-117">Specifically, the vector $\begin{bmatrix} x \\\\  y \end{bmatrix}$ can be written as $x \begin{bmatrix} 1 \\\\ 0 \end{bmatrix} + y \begin{bmatrix} 0 \\\\  1 \end{bmatrix}$.</span></span> <span data-ttu-id="374f4-118">Även om en rotation av dessa vektorer skulle fungera som en perfekt giltig grund för qubit, väljer vi att ge den behörigheten genom att anropa den till *beräknings grunden*.</span><span class="sxs-lookup"><span data-stu-id="374f4-118">While any rotation of these vectors would serve as a perfectly valid basis for the qubit, we choose to privilege this one, by calling it the *computational basis*.</span></span>

<span data-ttu-id="374f4-119">Vi tar de här två Quantum staterna för att motsvara de två tillstånden i en klassisk bit, nämligen $0 $ och $1 $.</span><span class="sxs-lookup"><span data-stu-id="374f4-119">We take these two quantum states to correspond to the two states of a classical bit, namely $0$ and $1$.</span></span> <span data-ttu-id="374f4-120">Standard konventionen är att välja</span><span class="sxs-lookup"><span data-stu-id="374f4-120">The standard convention is to choose</span></span>

<span data-ttu-id="374f4-121">$ $0 \ equiv \begin{bmatrix} 1 \\ \\ 0 \end{bmatrix}, \qquad 1 \equiv \begin{bmatrix} 0 \\ \\ 1 \end{bmatrix}, $ $</span><span class="sxs-lookup"><span data-stu-id="374f4-121">$$0\equiv \begin{bmatrix} 1 \\\\  0 \end{bmatrix}, \qquad 1 \equiv \begin{bmatrix} 0 \\\\  1 \end{bmatrix},$$</span></span>

<span data-ttu-id="374f4-122">även om det motsatta valet kan göras lika bra.</span><span class="sxs-lookup"><span data-stu-id="374f4-122">although the opposite choice could equally well be taken.</span></span> <span data-ttu-id="374f4-123">Därför, från det oändliga antalet möjliga qubit Quantum State Vectors, är det bara två som motsvarar tillstånd för klassiska bitar. alla andra Quantum-tillstånd gör inte det.</span><span class="sxs-lookup"><span data-stu-id="374f4-123">Thus, out of the infinite number of possible single-qubit quantum state vectors, only two correspond to states of classical bits; all other quantum states do not.</span></span>

## <a name="measuring-a-qubit"></a><span data-ttu-id="374f4-124">Mäta en qubit</span><span class="sxs-lookup"><span data-stu-id="374f4-124">Measuring a Qubit</span></span>

<span data-ttu-id="374f4-125">Nu när vi vet hur man representerar en qubit kan vi få en del intuition för vad dessa tillstånd representerar genom att diskutera begreppet [*mått*](https://en.wikipedia.org/wiki/Measurement_in_quantum_mechanics).</span><span class="sxs-lookup"><span data-stu-id="374f4-125">Now that we know how to represent a qubit, we can gain some intuition for what these states represent by discussing the concept of [*measurement*](https://en.wikipedia.org/wiki/Measurement_in_quantum_mechanics).</span></span> <span data-ttu-id="374f4-126">Ett mått motsvarar den formella idén "tittar" på en qubit, som direkt minimerar Quantum-tillståndet till något av de två klassiska tillstånden $ \begin{bmatrix} 1 \\ \\ 0 \end{bmatrix} $ eller $ \begin{bmatrix} 0 \\ \\ 1 \end{bmatrix} $.</span><span class="sxs-lookup"><span data-stu-id="374f4-126">A measurement corresponds to the informal idea of “looking” at a qubit, which immediately collapses the quantum state to one of the two classical states  $\begin{bmatrix} 1 \\\\  0 \end{bmatrix}$ or  $\begin{bmatrix} 0 \\\\  1 \end{bmatrix}$.</span></span> <span data-ttu-id="374f4-127">När en qubit som anges av metoden Quantum State Vector $ \begin{bmatrix} \alpha \\ \\ \beta \end{bmatrix} $ mäts, erhåller vi resultatet $0 $ med sannolikhet $ | \alpha | ^ 2 $ och resultatet $1 $ med sannolikhet $ | \beta | ^ 2 $.</span><span class="sxs-lookup"><span data-stu-id="374f4-127">When a qubit given by the quantum state vector  $\begin{bmatrix} \alpha \\\\  \beta \end{bmatrix}$ is measured, we obtain the outcome $0$ with probability $|\alpha|^2$ and the outcome $1$  with probability $|\beta|^2$.</span></span> <span data-ttu-id="374f4-128">I resultatet $0 $ är qubit nya tillstånd $ \begin{bmatrix} 1 \\ \\ 0 \end{bmatrix} $; på resultatet $1 $ sitt tillstånd är $ \begin{bmatrix} 0 \\ \\ 1 \end{bmatrix} $.</span><span class="sxs-lookup"><span data-stu-id="374f4-128">On outcome $0$, the qubit's new state is $\begin{bmatrix} 1 \\\\  0 \end{bmatrix}$; on outcome $1$ its state is $\begin{bmatrix} 0 \\\\  1 \end{bmatrix}$.</span></span> <span data-ttu-id="374f4-129">Observera att dessa sannolikheter summerar upp till $1 $ på grund av normaliserings villkoret $ | \alpha | ^ 2 + | \beta | ^ 2 = $1.</span><span class="sxs-lookup"><span data-stu-id="374f4-129">Note that these probabilities sum up to $1$ because of the normalization condition $|\alpha|^2 + |\beta|^2 = 1$.</span></span>

<span data-ttu-id="374f4-130">Egenskaperna för måttet innebär också att den övergripande signaturen för den Quantum-tillstånds vektorn är irrelevant.</span><span class="sxs-lookup"><span data-stu-id="374f4-130">The properties of measurement also mean that the overall sign of the quantum state vector is irrelevant.</span></span> <span data-ttu-id="374f4-131">Att negera en Vector motsvarar $ \alpha \rightarrow-\alpha $ och $ \beta \rightarrow-\beta $.</span><span class="sxs-lookup"><span data-stu-id="374f4-131">Negating a vector is equivalent to $\alpha \rightarrow -\alpha$ and $\beta \rightarrow -\beta$.</span></span> <span data-ttu-id="374f4-132">Eftersom sannolikheten för att mäta $0 $ och $1 $ beror på termernas storlek i kvadraten, ändras inte sannolikheten för att infoga sådana tecken.</span><span class="sxs-lookup"><span data-stu-id="374f4-132">Because the probability of measuring $0$ and $1$ depends on the magnitude squared of the terms, inserting such signs does not change the probabilities whatsoever.</span></span> <span data-ttu-id="374f4-133">Sådana faser kallas ofta [ \`\` *globala faser*](https://en.wikipedia.org/wiki/Phase_factor) , och mer allmänt kan vara av formulär $e ^ {i \phi} $ i stället för bara $ \pm $1.</span><span class="sxs-lookup"><span data-stu-id="374f4-133">Such phases are commonly called [\`\`*global phases*''](https://en.wikipedia.org/wiki/Phase_factor) and more generally can be of the form $e^{i \phi}$ rather than just $\pm 1$.</span></span>

<span data-ttu-id="374f4-134">En slutgiltig viktig egenskap för mått är att det inte nödvändigt vis skadar alla vektorer med Quantum-tillstånd.</span><span class="sxs-lookup"><span data-stu-id="374f4-134">A final important property of measurement is that it does not necessarily damage all quantum state vectors.</span></span> <span data-ttu-id="374f4-135">Om vi börjar med en qubit i delstaten $ \begin{bmatrix} 1 \\ \\ 0 \end{bmatrix} $, som motsvarar klassiskt läge $0 $, ger detta tillstånd alltid resultatet $0 $ och lämnar Quantum-läget oförändrat.</span><span class="sxs-lookup"><span data-stu-id="374f4-135">If we start with a qubit in the state $\begin{bmatrix} 1 \\\\  0 \end{bmatrix}$, which corresponds to the classical state $0$, measuring this state will always yield the outcome $0$ and leave the quantum state unchanged.</span></span> <span data-ttu-id="374f4-136">I det här fallet, om vi bara har klassiska bitar (d.v.s. qubits som är antingen $ \begin{bmatrix}1 \\ \\ 0 \end{bmatrix} $ eller $ \begin{bmatrix}0 \\ \\ 1 \end{bmatrix} $), skadar inte systemet systemet.</span><span class="sxs-lookup"><span data-stu-id="374f4-136">In this sense, if we only have classical bits (i.e., qubits that are either $\begin{bmatrix}1 \\\\  0 \end{bmatrix}$ or $\begin{bmatrix}0 \\\\  1 \end{bmatrix}$) then measurement does not damage the system.</span></span> <span data-ttu-id="374f4-137">Det innebär att vi kan replikera klassiska data och ändra dem på en Quantum-dator på samma sätt som ett kan göra på en klassisk dator.</span><span class="sxs-lookup"><span data-stu-id="374f4-137">This means that we can replicate classical data and manipulate it on a quantum computer just as one could do on a classical computer.</span></span> <span data-ttu-id="374f4-138">Möjligheten att lagra information i båda lägena på en gång är att öka den väntande data bearbetningen utöver vad som är möjligt i klassiskt och ytterligare Robs quantum-datorer i möjligheten att kopiera Quantum data på ett inkonsekvenser, se även [no-klonings satsen](https://en.wikipedia.org/wiki/No-cloning_theorem).</span><span class="sxs-lookup"><span data-stu-id="374f4-138">The ability, however, to store information in both states at once is what elevates quantum computing beyond what is possible classically and further robs quantum computers of the ability to copy quantum data indiscriminately, see also [the no-cloning theorem](https://en.wikipedia.org/wiki/No-cloning_theorem).</span></span>

## <a name="visualizing-qubits-and-transformations-using-the-bloch-sphere"></a><span data-ttu-id="374f4-139">Visualisera qubits och omvandlingar med hjälp av Bloch-sfären</span><span class="sxs-lookup"><span data-stu-id="374f4-139">Visualizing Qubits and Transformations using the Bloch Sphere</span></span>

<span data-ttu-id="374f4-140">Qubits kan också bildas i $3 $ D med hjälp av [*sfär*](https://en.wikipedia.org/wiki/Bloch_sphere) representationen Bloch.</span><span class="sxs-lookup"><span data-stu-id="374f4-140">Qubits may also be pictured in $3$D using the [*Bloch sphere*](https://en.wikipedia.org/wiki/Bloch_sphere) representation.</span></span>  <span data-ttu-id="374f4-141">Bloch-sfären ger ett sätt att beskriva ett qubit Quantum-tillstånd (som är en tvådimensionell komplex Vector) som en tredimensionell Vector med Real värde.</span><span class="sxs-lookup"><span data-stu-id="374f4-141">The Bloch sphere gives a way of describing a single-qubit quantum state (which is a two-dimensional complex vector) as a three-dimensional real-valued vector.</span></span>  <span data-ttu-id="374f4-142">Detta är viktigt eftersom vi gör det möjligt för oss att visualisera qubit tillstånd och därmed utveckla att det kan vara värdefullt att förstå qubit-tillstånd (där sadly Bloch sfär representationen bryts ned).</span><span class="sxs-lookup"><span data-stu-id="374f4-142">This is important because it allows us to visualize single-qubit states and thereby develop reasoning that can be invaluable in understanding multi-qubit states (where sadly the Bloch sphere representation breaks down).</span></span>  <span data-ttu-id="374f4-143">Bloch-sfären kan visualiseras på följande sätt:</span><span class="sxs-lookup"><span data-stu-id="374f4-143">The Bloch sphere can be visualized as follows:</span></span>

<!--- ![](.\media\bloch.svg){ width=50% } --->
<span data-ttu-id="374f4-144">![Bloch-sfär](~/media/concepts_bloch.png)</span><span class="sxs-lookup"><span data-stu-id="374f4-144">![Bloch sphere](~/media/concepts_bloch.png)</span></span>

<span data-ttu-id="374f4-145">Pilarna i det här diagrammet visar i vilken riktning som den blinkande läges vektorn pekar och varje omvandling av pilen kan ses som en rotation av en av kardinal axlarna.</span><span class="sxs-lookup"><span data-stu-id="374f4-145">The arrows in this diagram show the direction in which the quantum state vector is pointing and each transformation of the arrow can be thought of as a rotation about one of the cardinal axes.</span></span>
<span data-ttu-id="374f4-146">När du funderar på en Quantum-beräkning som en sekvens med rotationer är en kraftfull intuition, så det är svårt att använda den här intuition för att utforma och beskriva algoritmer.</span><span class="sxs-lookup"><span data-stu-id="374f4-146">While thinking about a quantum computation as a sequence of rotations is a powerful intuition, it is challenging to use this intuition to design and describe algorithms.</span></span> <span data-ttu-id="374f4-147">Q # minskar problemet genom att tillhandahålla ett språk för att beskriva sådana rotationer.</span><span class="sxs-lookup"><span data-stu-id="374f4-147">Q# alleviates this issue by providing a language for describing such rotations.</span></span>

## <a name="single-qubit-operations"></a><span data-ttu-id="374f4-148">Åtgärder med en qubit</span><span class="sxs-lookup"><span data-stu-id="374f4-148">Single-Qubit Operations</span></span>

<span data-ttu-id="374f4-149">Quantum Computers bearbetar data genom att använda en universell uppsättning Quantum-grindar som kan emulera all rotation av den Quantum-tillstånds vektorn.</span><span class="sxs-lookup"><span data-stu-id="374f4-149">Quantum computers process data by applying a universal set of quantum gates that can emulate any rotation of the quantum state vector.</span></span>
<span data-ttu-id="374f4-150">Detta teoretiskt sett är via för begreppet traditionell (dvs. klassisk) data behandling där en grind anses vara universell om varje omvandling av indata-bitar kan utföras med hjälp av en endensitets krets.</span><span class="sxs-lookup"><span data-stu-id="374f4-150">This notion of universality is akin to the notion of universality for traditional (i.e., classical) computing where a gate set is considered to be universal if every transformation of the input bits can be performed using a finite length circuit.</span></span>
<span data-ttu-id="374f4-151">I Quantum Computing är de giltiga omvandlingar som vi kan utföra på en qubit en enhetlig transformering och mätning.</span><span class="sxs-lookup"><span data-stu-id="374f4-151">In quantum computing, the valid transformations that we are allowed to perform on a qubit are unitary transformations and measurement.</span></span>
<span data-ttu-id="374f4-152">Den *angränsande åtgärden* eller den komplexa konjugats transponeren är av avgörande betydelse för Quantum Computing eftersom det behövs för att invertera Quantum-omvandlingar.</span><span class="sxs-lookup"><span data-stu-id="374f4-152">The *adjoint operation* or the complex conjugate transpose is of crucial importance to quantum computing because it is needed to invert quantum transformations.</span></span>
<span data-ttu-id="374f4-153">Q # visar detta genom att tillhandahålla metoder för att automatiskt kompilera grind sekvenser till deras angränsande, vilket sparar programmerare från att behöva gå över till hand kod i många fall.</span><span class="sxs-lookup"><span data-stu-id="374f4-153">Q# reflects this by providing methods to automatically compile gate sequences to their adjoint, which saves the programmer from having to hand code adjoints in many cases.</span></span> <span data-ttu-id="374f4-154">Ett exempel på detta visas nedan:</span><span class="sxs-lookup"><span data-stu-id="374f4-154">An example of this is shown below:</span></span>

```qsharp
operation PrepareSuperposition(qubit : Qubit) : Unit
is Adj { // Auto-generate the adjoint of the operation
    H(qubit);
}
```

<span data-ttu-id="374f4-155">Även om detta är ett enkelt exempel (eftersom <xref:microsoft.quantum.intrinsic.h> åtgärden är självständig) kan du se hur det blir värdefullt för mer komplicerade qubit-åtgärder.</span><span class="sxs-lookup"><span data-stu-id="374f4-155">Although this is a trivial example (as the <xref:microsoft.quantum.intrinsic.h> operation is self-adjoint), you can see how this becomes invaluable for more complicated qubit operations.</span></span>
<span data-ttu-id="374f4-156">Mer information finns i [åtgärder och funktioner](xref:microsoft.quantum.guide.operationsfunctions).</span><span class="sxs-lookup"><span data-stu-id="374f4-156">For more information, see [Operations and Functions](xref:microsoft.quantum.guide.operationsfunctions).</span></span>

<span data-ttu-id="374f4-157">Det finns bara fyra funktioner som mappar en bit till en bit på en klassisk dator.</span><span class="sxs-lookup"><span data-stu-id="374f4-157">There are only four functions that map one bit to one bit on a classical computer.</span></span> <span data-ttu-id="374f4-158">Det finns däremot ett obegränsat antal enhetliga omvandlingar för en enda qubit på en Quantum-dator.</span><span class="sxs-lookup"><span data-stu-id="374f4-158">In contrast, there are an infinite number of unitary transformations on a single qubit on a quantum computer.</span></span> <span data-ttu-id="374f4-159">Därför kan ingen begränsad uppsättning primitiva Quantum-åtgärder, som kallas [*grindar*](https://en.wikipedia.org/wiki/Quantum_logic_gate), exakt replikera den oändliga uppsättningen av enhetliga omvandlingar som tillåts i Quantum Computing.</span><span class="sxs-lookup"><span data-stu-id="374f4-159">Therefore, no finite set of primitive quantum operations, called [*gates*](https://en.wikipedia.org/wiki/Quantum_logic_gate), can exactly replicate the infinite set of unitary transformations allowed in quantum computing.</span></span> <span data-ttu-id="374f4-160">Det innebär till skillnad från klassisk dator användning, men det är omöjligt för en Quantum-dator att implementera alla möjliga Quantum-program exakt med ett begränsat antal portar.</span><span class="sxs-lookup"><span data-stu-id="374f4-160">This means, unlike classical computing, it is impossible for a quantum computer to implement every possible quantum program exactly using a finite number of gates.</span></span> <span data-ttu-id="374f4-161">Därför kan quantum-datorer inte vara universella i samma mening som klassiska datorer.</span><span class="sxs-lookup"><span data-stu-id="374f4-161">Thus quantum computers cannot be universal in the same sense of classical computers.</span></span> <span data-ttu-id="374f4-162">Det innebär att när vi säger att en uppsättning portar är *universella* för Quantum Computing, betyder det egentligen något något svagt än vad vi menar med klassisk data behandling.</span><span class="sxs-lookup"><span data-stu-id="374f4-162">As a result, when we say that a set of gates is *universal* for quantum computing we actually mean something slightly weaker than we mean with classical computing.</span></span>
<span data-ttu-id="374f4-163">För Universality kräver vi att en Quantum-dator endast *uppskattar* varje enhetlig matris inom ett begränsat fel med hjälp av en grind serie med begränsad längd.</span><span class="sxs-lookup"><span data-stu-id="374f4-163">For universality, we require that a quantum computer only *approximate* every unitary matrix within a finite error using a finite length gate sequence.</span></span>
<span data-ttu-id="374f4-164">Med andra ord är en uppsättning portar en universell grind uppsättning om en enhetlig omvandling kan vara ungefär skriven som en produkt av portar från den här uppsättningen.</span><span class="sxs-lookup"><span data-stu-id="374f4-164">In other words, a set of gates is a universal gate set if any unitary transformation can be approximately written as a product of gates from this set.</span></span> <span data-ttu-id="374f4-165">Vi kräver att för alla före skrivna fel, finns det portar $G _ {1} , G_ {2} , \ldots, G_N $ från den grind som</span><span class="sxs-lookup"><span data-stu-id="374f4-165">We require that for any prescribed error bound, there exist gates $G_{1}, G_{2},\ldots, G_N$ from the gate set such that</span></span>

<span data-ttu-id="374f4-166">$ $ G_N G_ {N-1} \cdots G_2 G_1 \approx U. $ $</span><span class="sxs-lookup"><span data-stu-id="374f4-166">$$ G_N G_{N-1} \cdots G_2 G_1 \approx U. $$</span></span>

<span data-ttu-id="374f4-167">Observera att eftersom konventionen för Matrix multiplikation är att multiplicera från höger till vänster om den första gaten i den här sekvensen, $G _N $, är den sista som tillämpas på den Quantum-tillstånds vektorn.</span><span class="sxs-lookup"><span data-stu-id="374f4-167">Note that because the convention for matrix multiplication is to multiply from right to left the first gate operation in this sequence, $G_N$, is actually the last one applied to the quantum state vector.</span></span> <span data-ttu-id="374f4-168">Mer formellt, anta att en sådan grind uppsättning är universell om för varje fel tolerans $ \epsilon>$0 finns $G _1, \ldots, G_N $ så att avståndet mellan $G _N \ldots G_1 $ och $U $ är högst $ \epsilon $.</span><span class="sxs-lookup"><span data-stu-id="374f4-168">More formally, we say that such a gate set is universal if for every error tolerance $\epsilon>0$ there exists $G_1,\ldots, G_N$ such that  the distance between $G_N\ldots G_1$ and $U$ is at most $\epsilon$.</span></span> <span data-ttu-id="374f4-169">Det bästa värdet för $N $ som behövs för att uppnå det här avståndet i $ \epsilon $ bör skala Poly-logarithmically med $1/\ Epsilon $.</span><span class="sxs-lookup"><span data-stu-id="374f4-169">Ideally the value of $N$ needed to reach this distance of $\epsilon$ should scale poly-logarithmically with $1/\epsilon$.</span></span>

<span data-ttu-id="374f4-170">Vad kan en sådan universell grind se ut i praxis?</span><span class="sxs-lookup"><span data-stu-id="374f4-170">What does such a universal gate set look like in practice?</span></span>  <span data-ttu-id="374f4-171">Den enklaste radiouniversella gaten för qubit-portar består av endast två portar: Hadamard-grinden $H $ och den så kallade $T $-grind (kallas även $ \ PI/8 $ grind):</span><span class="sxs-lookup"><span data-stu-id="374f4-171">The simplest such universal gate set for single-qubit gates consists of only two gates: the Hadamard gate $H$ and the so-called $T$-gate (also known as the $\pi/8$ gate):</span></span>

<span data-ttu-id="374f4-172">$ $ H = \frac {1} {\sqrt {2} } \begin{bmatrix} 1 & 1 \\ \\ 1 &-1 \end{bmatrix}, \qquad T = \begin{bmatrix} 1 & 0 \\ \\ 0 & e ^ {i \ PI/4} \end{bmatrix}.</span><span class="sxs-lookup"><span data-stu-id="374f4-172">$$ H=\frac{1}{\sqrt{2}}\begin{bmatrix} 1 & 1 \\\\  1 &-1  \end{bmatrix},\qquad T=\begin{bmatrix} 1 & 0 \\\\  0 & e^{i\pi/4} \end{bmatrix}.</span></span>
$$

<span data-ttu-id="374f4-173">Men av praktiska skäl som rör en Quantum-fel korrigering kan det vara bekvämare att överväga en större grind, nämligen en som kan genereras med hjälp av $H $ och $T $.</span><span class="sxs-lookup"><span data-stu-id="374f4-173">However, for practical reasons related to quantum error correction it can be more convenient to consider a larger gate set, namely one that can be generated using $H$ and $T$.</span></span>
<span data-ttu-id="374f4-174">Vi kan klassificera Quantum-grindarna i två kategorier: Clifford-grindar och $T $-grind.</span><span class="sxs-lookup"><span data-stu-id="374f4-174">We can classify the quantum gates into two categories: Clifford gates and the $T$-gate.</span></span>
<span data-ttu-id="374f4-175">Den här indelningen är användbar eftersom i många Quantum-fel korrigerings scheman så kallade Clifford-portar är enkla att implementera, det vill säga att de kräver mycket få resurser vad gäller åtgärder och qubits för att implementera feltoleranta fel, medan icke-Clifford-grindar är ganska kostsamma när fel tolerans krävs.</span><span class="sxs-lookup"><span data-stu-id="374f4-175">This subdivision is useful because in many quantum error correction schemes the so-called Clifford gates are easy to implement, that is they require very few resources in terms of operations and qubits to implement fault tolerantly, whereas non-Clifford gates are quite costly when requiring fault tolerance.</span></span> <span data-ttu-id="374f4-176">Standard uppsättningen med en-qubit Clifford-grindar [som ingår som standard i Q #](xref:microsoft.quantum.libraries.standard.prelude)inkluderar</span><span class="sxs-lookup"><span data-stu-id="374f4-176">The standard set of single-qubit Clifford gates, [included by default in Q#](xref:microsoft.quantum.libraries.standard.prelude), include</span></span>

<span data-ttu-id="374f4-177">$ $ H = \frac {1} {\sqrt {2} } \begin{bmatrix} 1 & 1 \\ \\ 1 &-1 \end{bmatrix}, \qquad S = \begin{bmatrix} 1 & 0 \\ \\ 0 & i \end{bmatrix} = T ^ 2, \qquad X = \begin{bmatrix} 0 &1 \\ \\ 1& 0 \end{bmatrix} = HT ^ 4h, $ $</span><span class="sxs-lookup"><span data-stu-id="374f4-177">$$ H=\frac{1}{\sqrt{2}}\begin{bmatrix} 1 & 1 \\\\  1 &-1  \end{bmatrix} ,\qquad S =\begin{bmatrix} 1 & 0 \\\\  0 & i \end{bmatrix}= T^2,\qquad X=\begin{bmatrix} 0 &1 \\\\  1& 0 \end{bmatrix}= HT^4H, $$</span></span>

<span data-ttu-id="374f4-178">$ $ Y = \begin{bmatrix} 0 &-i \\ \\ i & 0 \End{bmatrix} = T ^ 2HT ^ 4 HT ^ 6, \qquad Z = \begin{bmatrix}1&0 \\ \\ 0&-1 \end{bmatrix} = T ^ 4.</span><span class="sxs-lookup"><span data-stu-id="374f4-178">$$ Y = \begin{bmatrix} 0 & -i \\\\  i & 0 \end{bmatrix}=T^2HT^4  HT^6, \qquad Z=\begin{bmatrix}1&0\\\\ 0&-1 \end{bmatrix}=T^4.</span></span>
$$

<span data-ttu-id="374f4-179">Här är åtgärderna $X $, $Y $ och $Z $ används särskilt ofta och kallas Pauli- [*operatörer*](https://en.wikipedia.org/wiki/Pauli_matrices) efter att de har skapat Wolfgang Pauli.</span><span class="sxs-lookup"><span data-stu-id="374f4-179">Here the operations $X$, $Y$ and $Z$ are used especially frequently and are named [*Pauli operators*](https://en.wikipedia.org/wiki/Pauli_matrices) after their creator Wolfgang Pauli.</span></span>
<span data-ttu-id="374f4-180">Tillsammans med den icke-Clifford porten ($T $-grind) kan dessa åtgärder sammanställas för att approximera en enhetlig omvandling på en enda qubit.</span><span class="sxs-lookup"><span data-stu-id="374f4-180">Together with the non-Clifford gate (the $T$-gate), these operations can be composed to approximate any unitary transformation on a single qubit.</span></span>

<span data-ttu-id="374f4-181">För ytterligare information om dessa åtgärder, Bloch-sfär representationer och Q #-implementeringar, se [inbyggda funktioner och funktioner](xref:microsoft.quantum.libraries.standard.prelude#intrinsic-operations-and-functions).</span><span class="sxs-lookup"><span data-stu-id="374f4-181">For more information on these operations, their Bloch sphere representations and Q# implementations, see [Intrinsic Operations and Functions](xref:microsoft.quantum.libraries.standard.prelude#intrinsic-operations-and-functions).</span></span>

<span data-ttu-id="374f4-182">Som ett exempel på hur enhetlig omvandling kan skapas från dessa primitiver, motsvarar de tre omvandlingarna som visas i Bloch-Kloten ovan motsvarande grind serien $ \begin{bmatrix} 1 \\ \\ 0 \END{BMATRIX} \mapsto HZH \begin{bmatrix} 1 \\ \\ 0 \end{bmatrix} = \begin{bmatrix} 0 \\ \\ 1 \end{bmatrix} $.</span><span class="sxs-lookup"><span data-stu-id="374f4-182">As an example of how unitary transformations can be built from these primitives, the three transformations pictured in the Bloch spheres above correspond to the gate sequence $\begin{bmatrix} 1 \\\\  0 \end{bmatrix} \mapsto HZH \begin{bmatrix} 1 \\\\  0 \end{bmatrix} = \begin{bmatrix} 0 \\\\  1 \end{bmatrix}$.</span></span>

<span data-ttu-id="374f4-183">Den tidigare utgör de mest populära primitiva portarna för att beskriva åtgärder på den logiska nivån i stacken (Tänk på den logiska nivån som nivån för Quantum-algoritmen), men det är ofta praktiskt att överväga mindre grundläggande åtgärder på algoritmnivå, till exempel åtgärder närmare en funktions beskrivnings nivå.</span><span class="sxs-lookup"><span data-stu-id="374f4-183">While the previous constitute the most popular primitive gates for describing operations on the logical level of the stack (think of the logical level as the level of the quantum algorithm), it is often convenient to consider less basic operations at the algorithmic level, for example operations closer to a function description level.</span></span> <span data-ttu-id="374f4-184">Lyckligt vis har Q # också metoder som är tillgängliga för att implementera unitaries på högre nivå, vilket i sin tur gör att algoritmer på hög nivå kan implementeras utan att uttryckligen sammanföra allt till Clifford och $T $-grindar.</span><span class="sxs-lookup"><span data-stu-id="374f4-184">Fortunately, Q# also has methods available for implementing higher-level unitaries, which in turn allow high-level algorithms to be implemented without explicitly decomposing everything down to Clifford and $T$-gates.</span></span>

<span data-ttu-id="374f4-185">Den enklaste sådan primitiv är den enda qubit.</span><span class="sxs-lookup"><span data-stu-id="374f4-185">The simplest such primitive is the single qubit-rotation.</span></span> <span data-ttu-id="374f4-186">Tre enkla qubit-rotationer anses vanligt vis vara: $R _x $, $R _y $ och $R _z $.</span><span class="sxs-lookup"><span data-stu-id="374f4-186">Three single-qubit rotations are typically considered: $R_x$, $R_y$ and $R_z$.</span></span> <span data-ttu-id="374f4-187">Om du vill visualisera rotations $R _x (\theta) $, kan du till exempel föreställa dig ditt högra tumm utmed riktningen på $x $-axeln i Bloch-sfären och rotera vektorn med handen genom en vinkel på $ \ theta/2 $ radianer.</span><span class="sxs-lookup"><span data-stu-id="374f4-187">To visualize the action of the rotation $R_x(\theta)$, for example, imagine pointing your right thumb along the direction of the $x$-axis of the Bloch sphere and rotating the vector with your hand through an angle of $\theta/2$ radians.</span></span> <span data-ttu-id="374f4-188">Den här förvirrande faktorn på $2 $ uppstår från det faktum att rätvinkliga vektorer är $180 ^ \circ $ isär när de ritas på Bloch-sfären, men som i själva verket är $90 ^ \circ $ grader oberoende av varandra.</span><span class="sxs-lookup"><span data-stu-id="374f4-188">This confusing factor of $2$ arises from the fact that orthogonal vectors are $180^\circ$ apart when plotted on the Bloch sphere, yet are actually $90^\circ$ degrees apart geometrically.</span></span> <span data-ttu-id="374f4-189">Motsvarande enhetliga matriser är:</span><span class="sxs-lookup"><span data-stu-id="374f4-189">The corresponding unitary matrices are:</span></span>

<span data-ttu-id="374f4-190">\begin{align *} &R_z (\theta) = e ^ {-I\theta z/2} = \begin{bmatrix} e ^ {-i \ theta/2} & 0 \\ \\ 0& e ^ {i \ theta/2} \end{bmatrix}, \\ \\ &R_x (\theta) = e ^ {-i\theta x/2} = HR_z (\theta) H = \begin{bmatrix} \cos (\ theta/2) &-i\sin (\ theta/2) \\ \\ -i\sin (\ theta/2) & \cos (\ theta/2) \end{bmatrix}, \\ \\ &R_y (\theta) = e ^ {-i\theta y/2} = SHR_z (\theta) HS ^ \dagger = \begin{bmatrix} \cos (\ theta/2) &-\sin (\ theta/2) \\ \\ \sin (\ theta/2) & \cos (\ theta/2) \end{bmatrix}. \end{align*}</span><span class="sxs-lookup"><span data-stu-id="374f4-190">\begin{align *} &R_z(\theta) = e^{-i\theta Z/2} = \begin{bmatrix} e^{-i\theta/2} & 0\\\\  0& e^{i\theta/2} \end{bmatrix}, \\\\ &R_x(\theta) = e^{-i\theta X/2} = HR_z(\theta)H = \begin{bmatrix} \cos(\theta/2) & -i\sin(\theta/2)\\\\  -i\sin(\theta/2) & \cos(\theta/2) \end{bmatrix}, \\\\ &R_y(\theta) = e^{-i\theta Y/2} = SHR_z(\theta)HS^\dagger = \begin{bmatrix} \cos(\theta/2) & -\sin(\theta/2)\\\\  \sin(\theta/2) & \cos(\theta/2) \end{bmatrix}. \end{align*}</span></span>

<span data-ttu-id="374f4-191">Precis som tre rotationer kan kombineras tillsammans för att utföra en godtycklig rotation i tre dimensioner, kan den ses från Bloch-sfären som kan skrivas som en sekvens av tre rotationer.</span><span class="sxs-lookup"><span data-stu-id="374f4-191">Just as any three rotations can be combined together to perform an arbitrary rotation in three dimensions, it can be seen from the Bloch sphere representation that any unitary matrix can be written as a sequence of three rotations as well.</span></span> <span data-ttu-id="374f4-192">För varje enhetlig matris $U $ finns $ \alpha, \beta, \gamma, \delta $ som $U = e ^ {i\alpha} R_x (\beta) R_z (\gamma) R_x (\delta) $.</span><span class="sxs-lookup"><span data-stu-id="374f4-192">Specifically, for every unitary matrix $U$ there exists $\alpha,\beta,\gamma,\delta$ such that $U= e^{i\alpha} R_x(\beta)R_z(\gamma)R_x(\delta)$.</span></span> <span data-ttu-id="374f4-193">Därför kan $R _z (\theta) $ och $H $ också bilda en universell grind, även om det inte är en diskret uppsättning eftersom $ \theta $ kan ta ett värde.</span><span class="sxs-lookup"><span data-stu-id="374f4-193">Thus $R_z(\theta)$ and $H$ also form a universal gate set although it is not a discrete set because $\theta$ can take any value.</span></span> <span data-ttu-id="374f4-194">Av den anledningen och på grund av program i Quantum-simulering är sådana kontinuerliga portar avgörande för Quantum-beräkning, särskilt på design nivån på Quantum-algoritmen.</span><span class="sxs-lookup"><span data-stu-id="374f4-194">For this reason, and due to applications in quantum simulation, such continuous gates are crucial for quantum computation, especially at the quantum algorithm design level.</span></span> <span data-ttu-id="374f4-195">För att uppnå feltolerant maskin varu implementering kommer de i slut änden att sammanställas i diskreta grind serier som närmar sig dessa rotationer.</span><span class="sxs-lookup"><span data-stu-id="374f4-195">To achieve fault-tolerant hardware implementation, they will ultimately be compiled into discrete gate sequences that closely approximate these rotations.</span></span>
